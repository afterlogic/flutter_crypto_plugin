//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/symmetric_encryption/SymmetricEncryptorDecryptor.java
//

#include "BcPBEDataDecryptorFactory.h"
#include "BcPGPDigestCalculatorProvider.h"
#include "BcPGPObjectFactory.h"
#include "CompressionAlgorithm.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JcePBEKeyEncryptionMethodGenerator.h"
#include "JcePGPDataEncryptorBuilder.h"
#include "PGPCompressedData.h"
#include "PGPCompressedDataGenerator.h"
#include "PGPEncryptedDataGenerator.h"
#include "PGPEncryptedDataList.h"
#include "PGPException.h"
#include "PGPLiteralData.h"
#include "PGPLiteralDataGenerator.h"
#include "PGPPBEEncryptedData.h"
#include "PGPUtil.h"
#include "Passphrase.h"
#include "Streams.h"
#include "SymmetricEncryptorDecryptor.h"
#include "SymmetricKeyAlgorithm.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/security/SecureRandom.h"
#include "java/util/Date.h"

@interface LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor ()

+ (IOSByteArray *)compressWithByteArray:(IOSByteArray *)clearData
                                withInt:(jint)algorithm;

@end

__attribute__((unused)) static IOSByteArray *LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_compressWithByteArray_withInt_(IOSByteArray *clearData, jint algorithm);

@implementation LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (IOSByteArray *)symmetricallyEncryptWithByteArray:(IOSByteArray *)data
              withLibComAfterlogicPgpUtilPassphrase:(LibComAfterlogicPgpUtilPassphrase *)password
withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *)encryptionAlgorithm
withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:(LibComAfterlogicPgpAlgorithmCompressionAlgorithm *)compressionAlgorithm {
  return LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_symmetricallyEncryptWithByteArray_withLibComAfterlogicPgpUtilPassphrase_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_(data, password, encryptionAlgorithm, compressionAlgorithm);
}

+ (IOSByteArray *)symmetricallyDecryptWithByteArray:(IOSByteArray *)data
              withLibComAfterlogicPgpUtilPassphrase:(LibComAfterlogicPgpUtilPassphrase *)password {
  return LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_symmetricallyDecryptWithByteArray_withLibComAfterlogicPgpUtilPassphrase_(data, password);
}

+ (IOSByteArray *)compressWithByteArray:(IOSByteArray *)clearData
                                withInt:(jint)algorithm {
  return LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_compressWithByteArray_withInt_(clearData, algorithm);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 0, 1, 2, -1, -1, -1 },
    { NULL, "[B", 0x9, 3, 4, 2, -1, -1, -1 },
    { NULL, "[B", 0xa, 5, 6, 7, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(symmetricallyEncryptWithByteArray:withLibComAfterlogicPgpUtilPassphrase:withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:);
  methods[2].selector = @selector(symmetricallyDecryptWithByteArray:withLibComAfterlogicPgpUtilPassphrase:);
  methods[3].selector = @selector(compressWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "symmetricallyEncrypt", "[BLLibComAfterlogicPgpUtilPassphrase;LLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm;LLibComAfterlogicPgpAlgorithmCompressionAlgorithm;", "LJavaIoIOException;LLibOrgBouncycastleOpenpgpPGPException;", "symmetricallyDecrypt", "[BLLibComAfterlogicPgpUtilPassphrase;", "compress", "[BI", "LJavaIoIOException;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor = { "SymmetricEncryptorDecryptor", "lib.com.afterlogic.pgp.symmetric_encryption", ptrTable, methods, NULL, 7, 0x1, 4, 0, -1, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor;
}

@end

void LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_init(LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor *self) {
  NSObject_init(self);
}

LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor *new_LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_init() {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor, init)
}

LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor *create_LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_init() {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor, init)
}

IOSByteArray *LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_symmetricallyEncryptWithByteArray_withLibComAfterlogicPgpUtilPassphrase_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_(IOSByteArray *data, LibComAfterlogicPgpUtilPassphrase *password, LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *encryptionAlgorithm, LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm) {
  LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_initialize();
  IOSByteArray *compressedData = LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_compressWithByteArray_withInt_(data, [((LibComAfterlogicPgpAlgorithmCompressionAlgorithm *) nil_chk(compressionAlgorithm)) getAlgorithmId]);
  JavaIoByteArrayOutputStream *bOut = new_JavaIoByteArrayOutputStream_init();
  LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator *encGen = new_LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPDataEncryptorBuilder_([((LibOrgBouncycastleOpenpgpOperatorJcajceJcePGPDataEncryptorBuilder *) nil_chk([((LibOrgBouncycastleOpenpgpOperatorJcajceJcePGPDataEncryptorBuilder *) nil_chk([new_LibOrgBouncycastleOpenpgpOperatorJcajceJcePGPDataEncryptorBuilder_initWithInt_([((LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *) nil_chk(encryptionAlgorithm)) getAlgorithmId]) setWithIntegrityPacketWithBoolean:true])) setSecureRandomWithJavaSecuritySecureRandom:new_JavaSecuritySecureRandom_init()])) setProviderWithNSString:@"BC"]);
  [encGen addMethodWithLibOrgBouncycastleOpenpgpOperatorPGPKeyEncryptionMethodGenerator:[new_LibOrgBouncycastleOpenpgpOperatorJcajceJcePBEKeyEncryptionMethodGenerator_initWithCharArray_([((LibComAfterlogicPgpUtilPassphrase *) nil_chk(password)) getChars]) setProviderWithNSString:@"BC"]];
  JavaIoOutputStream *encOut = [encGen openWithJavaIoOutputStream:bOut withLong:((IOSByteArray *) nil_chk(compressedData))->size_];
  [((JavaIoOutputStream *) nil_chk(encOut)) writeWithByteArray:compressedData];
  [encOut close];
  return [bOut toByteArray];
}

IOSByteArray *LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_symmetricallyDecryptWithByteArray_withLibComAfterlogicPgpUtilPassphrase_(IOSByteArray *data, LibComAfterlogicPgpUtilPassphrase *password) {
  LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_initialize();
  LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *pbe;
  JavaIoByteArrayOutputStream *outputStream = nil;
  JavaIoBufferedInputStream *bis = new_JavaIoBufferedInputStream_initWithJavaIoInputStream_(new_JavaIoByteArrayInputStream_initWithByteArray_(data));
  JavaIoInputStream *in = LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(bis);
  @try {
    LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory *pgpF = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_(in);
    LibOrgBouncycastleOpenpgpPGPEncryptedDataList *enc;
    id o = [pgpF nextObject];
    if ([o isKindOfClass:[LibOrgBouncycastleOpenpgpPGPEncryptedDataList class]]) {
      enc = (LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) o;
    }
    else {
      enc = (LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) cast_chk([pgpF nextObject], [LibOrgBouncycastleOpenpgpPGPEncryptedDataList class]);
    }
    pbe = (LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *) cast_chk([((LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) nil_chk(enc)) getWithInt:0], [LibOrgBouncycastleOpenpgpPGPPBEEncryptedData class]);
    JavaIoInputStream *clear = [((LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *) nil_chk(pbe)) getDataStreamWithLibOrgBouncycastleOpenpgpOperatorPBEDataDecryptorFactory:new_LibOrgBouncycastleOpenpgpOperatorBcBcPBEDataDecryptorFactory_initWithCharArray_withLibOrgBouncycastleOpenpgpOperatorBcBcPGPDigestCalculatorProvider_([((LibComAfterlogicPgpUtilPassphrase *) nil_chk(password)) getChars], new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPDigestCalculatorProvider_init())];
    LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory *pgpFact = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_(clear);
    o = [pgpFact nextObject];
    if ([o isKindOfClass:[LibOrgBouncycastleOpenpgpPGPCompressedData class]]) {
      LibOrgBouncycastleOpenpgpPGPCompressedData *cData = (LibOrgBouncycastleOpenpgpPGPCompressedData *) o;
      pgpFact = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_([((LibOrgBouncycastleOpenpgpPGPCompressedData *) nil_chk(cData)) getDataStream]);
      o = [pgpFact nextObject];
    }
    LibOrgBouncycastleOpenpgpPGPLiteralData *ld = (LibOrgBouncycastleOpenpgpPGPLiteralData *) cast_chk(o, [LibOrgBouncycastleOpenpgpPGPLiteralData class]);
    JavaIoInputStream *unc = [((LibOrgBouncycastleOpenpgpPGPLiteralData *) nil_chk(ld)) getInputStream];
    @try {
      outputStream = new_JavaIoByteArrayOutputStream_init();
      LibOrgBouncycastleUtilIoStreams_pipeAllWithJavaIoInputStream_withJavaIoOutputStream_(unc, outputStream);
    }
    @finally {
      if (outputStream != nil) {
        [outputStream close];
      }
    }
  }
  @finally {
    [((JavaIoInputStream *) nil_chk(in)) close];
  }
  if ([((LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *) nil_chk(pbe)) isIntegrityProtected]) {
    if (![pbe verify]) {
      @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"Integrity check failed.");
    }
  }
  else {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"Symmetrically encrypted data is not integrity protected.");
  }
  return [((JavaIoByteArrayOutputStream *) nil_chk(outputStream)) toByteArray];
}

IOSByteArray *LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_compressWithByteArray_withInt_(IOSByteArray *clearData, jint algorithm) {
  LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor_initialize();
  JavaIoByteArrayOutputStream *bOut = new_JavaIoByteArrayOutputStream_init();
  LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator *comData = new_LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator_initWithInt_(algorithm);
  JavaIoOutputStream *cos = [comData openWithJavaIoOutputStream:bOut];
  LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator *lData = new_LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator_init();
  JavaIoOutputStream *pOut = [lData openWithJavaIoOutputStream:cos withChar:LibOrgBouncycastleOpenpgpPGPLiteralData_BINARY withNSString:LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator_CONSOLE withLong:((IOSByteArray *) nil_chk(clearData))->size_ withJavaUtilDate:new_JavaUtilDate_init()];
  [((JavaIoOutputStream *) nil_chk(pOut)) writeWithByteArray:clearData];
  [pOut close];
  [comData close];
  return [bOut toByteArray];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpSymmetric_encryptionSymmetricEncryptorDecryptor)

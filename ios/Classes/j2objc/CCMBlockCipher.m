//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/modes/CCMBlockCipher.java
//

#include "AEADParameters.h"
#include "Arrays.h"
#include "BlockCipher.h"
#include "CBCBlockCipherMac.h"
#include "CCMBlockCipher.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "Mac.h"
#include "OutputLengthException.h"
#include "ParametersWithIV.h"
#include "SICBlockCipher.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@class LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;

@interface LibOrgBouncycastleCryptoModesCCMBlockCipher () {
 @public
  id<LibOrgBouncycastleCryptoBlockCipher> cipher_;
  jint blockSize_;
  jboolean forEncryption_;
  IOSByteArray *nonce_;
  IOSByteArray *initialAssociatedText_;
  jint macSize_;
  id<LibOrgBouncycastleCryptoCipherParameters> keyParam_;
  IOSByteArray *macBlock_;
  LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *associatedText_;
  LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *data_;
}

- (jint)calculateMacWithByteArray:(IOSByteArray *)data
                          withInt:(jint)dataOff
                          withInt:(jint)dataLen
                    withByteArray:(IOSByteArray *)macBlock;

- (jint)getAssociatedTextLength;

- (jboolean)hasAssociatedText;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, cipher_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, keyParam_, id<LibOrgBouncycastleCryptoCipherParameters>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, associatedText_, LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesCCMBlockCipher, data_, LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *)

__attribute__((unused)) static jint LibOrgBouncycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(LibOrgBouncycastleCryptoModesCCMBlockCipher *self, IOSByteArray *data, jint dataOff, jint dataLen, IOSByteArray *macBlock);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(LibOrgBouncycastleCryptoModesCCMBlockCipher *self);

__attribute__((unused)) static jboolean LibOrgBouncycastleCryptoModesCCMBlockCipher_hasAssociatedText(LibOrgBouncycastleCryptoModesCCMBlockCipher *self);

@interface LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream : JavaIoByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesCCMBlockCipher:(LibOrgBouncycastleCryptoModesCCMBlockCipher *)outer$;

- (IOSByteArray *)getBuffer;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$);

__attribute__((unused)) static LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$);

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)

@implementation LibOrgBouncycastleCryptoModesCCMBlockCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)c {
  LibOrgBouncycastleCryptoModesCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, c);
  return self;
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return cipher_;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  id<LibOrgBouncycastleCryptoCipherParameters> cipherParameters;
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]]) {
    LibOrgBouncycastleCryptoParamsAEADParameters *param = (LibOrgBouncycastleCryptoParamsAEADParameters *) params;
    nonce_ = [((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    initialAssociatedText_ = [param getAssociatedText];
    macSize_ = [param getMacSize] / 8;
    cipherParameters = [param getKey];
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithIV *param = (LibOrgBouncycastleCryptoParamsParametersWithIV *) params;
    nonce_ = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    initialAssociatedText_ = nil;
    macSize_ = ((IOSByteArray *) nil_chk(macBlock_))->size_ / 2;
    cipherParameters = [param getParameters];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"invalid parameters passed to CCM: ", [[((id<LibOrgBouncycastleCryptoCipherParameters>) nil_chk(params)) java_getClass] getName]));
  }
  if (cipherParameters != nil) {
    keyParam_ = cipherParameters;
  }
  if (nonce_ == nil || nonce_->size_ < 7 || nonce_->size_ > 13) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"nonce must have length from 7 to 13 octets");
  }
  [self reset];
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) getAlgorithmName], @"/CCM");
}

- (void)processAADByteWithByte:(jbyte)inArg {
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithInt:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithByteArray:inArg withInt:inOff withInt:len];
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithInt:inArg];
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)inLen
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + inLen)) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithByteArray:inArg withInt:inOff withInt:inLen];
  return 0;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  jint len = [self processPacketWithByteArray:[((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:[((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] withByteArray:outArg withInt:outOff];
  [self reset];
  return len;
}

- (void)reset {
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) reset];
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) reset];
  [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) reset];
}

- (IOSByteArray *)getMac {
  IOSByteArray *mac = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac, 0, mac->size_);
  return mac;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return 0;
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size];
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (IOSByteArray *)processPacketWithByteArray:(IOSByteArray *)inArg
                                     withInt:(jint)inOff
                                     withInt:(jint)inLen {
  IOSByteArray *output;
  if (forEncryption_) {
    output = [IOSByteArray newArrayWithLength:inLen + macSize_];
  }
  else {
    if (inLen < macSize_) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    output = [IOSByteArray newArrayWithLength:inLen - macSize_];
  }
  [self processPacketWithByteArray:inArg withInt:inOff withInt:inLen withByteArray:output withInt:0];
  return output;
}

- (jint)processPacketWithByteArray:(IOSByteArray *)inArg
                           withInt:(jint)inOff
                           withInt:(jint)inLen
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outOff {
  if (keyParam_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"CCM cipher unitialized.");
  }
  jint n = ((IOSByteArray *) nil_chk(nonce_))->size_;
  jint q = 15 - n;
  if (q < 4) {
    jint limitLen = JreLShift32(1, (8 * q));
    if (inLen >= limitLen) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"CCM packet too large for choice of q.");
    }
  }
  IOSByteArray *iv = [IOSByteArray newArrayWithLength:blockSize_];
  *IOSByteArray_GetRef(iv, 0) = (jbyte) ((q - 1) & (jint) 0x7);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(nonce_, 0, iv, 1, nonce_->size_);
  id<LibOrgBouncycastleCryptoBlockCipher> ctrCipher = new_LibOrgBouncycastleCryptoModesSICBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(cipher_);
  [ctrCipher init__WithBoolean:forEncryption_ withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(keyParam_, iv)];
  jint outputLen;
  jint inIndex = inOff;
  jint outIndex = outOff;
  if (forEncryption_) {
    outputLen = inLen + macSize_;
    if (((IOSByteArray *) nil_chk(output))->size_ < (outputLen + outOff)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short.");
    }
    LibOrgBouncycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, inArg, inOff, inLen, macBlock_);
    IOSByteArray *encMac = [IOSByteArray newArrayWithLength:blockSize_];
    [ctrCipher processBlockWithByteArray:macBlock_ withInt:0 withByteArray:encMac withInt:0];
    while (inIndex < (inOff + inLen - blockSize_)) {
      [ctrCipher processBlockWithByteArray:inArg withInt:inIndex withByteArray:output withInt:outIndex];
      outIndex += blockSize_;
      inIndex += blockSize_;
    }
    IOSByteArray *block = [IOSByteArray newArrayWithLength:blockSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inIndex, block, 0, inLen + inOff - inIndex);
    [ctrCipher processBlockWithByteArray:block withInt:0 withByteArray:block withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(block, 0, output, outIndex, inLen + inOff - inIndex);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(encMac, 0, output, outOff + inLen, macSize_);
  }
  else {
    if (inLen < macSize_) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    outputLen = inLen - macSize_;
    if (((IOSByteArray *) nil_chk(output))->size_ < (outputLen + outOff)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short.");
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff + outputLen, macBlock_, 0, macSize_);
    [ctrCipher processBlockWithByteArray:macBlock_ withInt:0 withByteArray:macBlock_ withInt:0];
    for (jint i = macSize_; i != ((IOSByteArray *) nil_chk(macBlock_))->size_; i++) {
      *IOSByteArray_GetRef(macBlock_, i) = 0;
    }
    while (inIndex < (inOff + outputLen - blockSize_)) {
      [ctrCipher processBlockWithByteArray:inArg withInt:inIndex withByteArray:output withInt:outIndex];
      outIndex += blockSize_;
      inIndex += blockSize_;
    }
    IOSByteArray *block = [IOSByteArray newArrayWithLength:blockSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inIndex, block, 0, outputLen - (inIndex - inOff));
    [ctrCipher processBlockWithByteArray:block withInt:0 withByteArray:block withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(block, 0, output, outIndex, outputLen - (inIndex - inOff));
    IOSByteArray *calculatedMacBlock = [IOSByteArray newArrayWithLength:blockSize_];
    LibOrgBouncycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, output, outOff, outputLen, calculatedMacBlock);
    if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(macBlock_, calculatedMacBlock)) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check in CCM failed");
    }
  }
  return outputLen;
}

- (jint)calculateMacWithByteArray:(IOSByteArray *)data
                          withInt:(jint)dataOff
                          withInt:(jint)dataLen
                    withByteArray:(IOSByteArray *)macBlock {
  return LibOrgBouncycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, data, dataOff, dataLen, macBlock);
}

- (jint)getAssociatedTextLength {
  return LibOrgBouncycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self);
}

- (jboolean)hasAssociatedText {
  return LibOrgBouncycastleCryptoModesCCMBlockCipher_hasAssociatedText(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 8, 9, 10, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 10, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 17, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 19, 7, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 19, 12, 20, -1, -1, -1 },
    { NULL, "I", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[1].selector = @selector(getUnderlyingCipher);
  methods[2].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(processAADByteWithByte:);
  methods[5].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[6].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[7].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[8].selector = @selector(doFinalWithByteArray:withInt:);
  methods[9].selector = @selector(reset);
  methods[10].selector = @selector(getMac);
  methods[11].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[12].selector = @selector(getOutputSizeWithInt:);
  methods[13].selector = @selector(processPacketWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(processPacketWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[15].selector = @selector(calculateMacWithByteArray:withInt:withInt:withByteArray:);
  methods[16].selector = @selector(getAssociatedTextLength);
  methods[17].selector = @selector(hasAssociatedText);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cipher_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blockSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "keyParam_", "LLibOrgBouncycastleCryptoCipherParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "associatedText_", "LLibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "data_", "LLibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "processAADByte", "B", "processAADBytes", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;", "getUpdateOutputSize", "I", "getOutputSize", "processPacket", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;LLibOrgBouncycastleCryptoDataLengthException;", "calculateMac", "[BII[B", "LLibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesCCMBlockCipher = { "CCMBlockCipher", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 18, 10, -1, 23, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesCCMBlockCipher;
}

@end

void LibOrgBouncycastleCryptoModesCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> c) {
  NSObject_init(self);
  self->associatedText_ = new_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(self);
  self->data_ = new_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(self);
  self->cipher_ = c;
  self->blockSize_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(c)) getBlockSize];
  self->macBlock_ = [IOSByteArray newArrayWithLength:self->blockSize_];
  if (self->blockSize_ != 16) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cipher required with a block size of 16.");
  }
}

LibOrgBouncycastleCryptoModesCCMBlockCipher *new_LibOrgBouncycastleCryptoModesCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> c) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, c)
}

LibOrgBouncycastleCryptoModesCCMBlockCipher *create_LibOrgBouncycastleCryptoModesCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> c) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, c)
}

jint LibOrgBouncycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(LibOrgBouncycastleCryptoModesCCMBlockCipher *self, IOSByteArray *data, jint dataOff, jint dataLen, IOSByteArray *macBlock) {
  id<LibOrgBouncycastleCryptoMac> cMac = new_LibOrgBouncycastleCryptoMacsCBCBlockCipherMac_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self->cipher_, self->macSize_ * 8);
  [cMac init__WithLibOrgBouncycastleCryptoCipherParameters:self->keyParam_];
  IOSByteArray *b0 = [IOSByteArray newArrayWithLength:16];
  if (LibOrgBouncycastleCryptoModesCCMBlockCipher_hasAssociatedText(self)) {
    *IOSByteArray_GetRef(b0, 0) |= (jint) 0x40;
  }
  *IOSByteArray_GetRef(b0, 0) |= JreLShift32(((([cMac getMacSize] - 2) / 2) & (jint) 0x7), 3);
  *IOSByteArray_GetRef(b0, 0) |= ((15 - ((IOSByteArray *) nil_chk(self->nonce_))->size_) - 1) & (jint) 0x7;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->nonce_, 0, b0, 1, self->nonce_->size_);
  jint q = dataLen;
  jint count = 1;
  while (q > 0) {
    *IOSByteArray_GetRef(b0, b0->size_ - count) = (jbyte) (q & (jint) 0xff);
    JreURShiftAssignInt(&q, 8);
    count++;
  }
  [cMac updateWithByteArray:b0 withInt:0 withInt:b0->size_];
  if (LibOrgBouncycastleCryptoModesCCMBlockCipher_hasAssociatedText(self)) {
    jint extra;
    jint textLength = LibOrgBouncycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self);
    if (textLength < ((JreLShift32(1, 16)) - (JreLShift32(1, 8)))) {
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 8))];
      [cMac updateWithByte:(jbyte) textLength];
      extra = 2;
    }
    else {
      [cMac updateWithByte:(jbyte) (jint) 0xff];
      [cMac updateWithByte:(jbyte) (jint) 0xfe];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 24))];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 16))];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 8))];
      [cMac updateWithByte:(jbyte) textLength];
      extra = 6;
    }
    if (self->initialAssociatedText_ != nil) {
      [cMac updateWithByteArray:self->initialAssociatedText_ withInt:0 withInt:self->initialAssociatedText_->size_];
    }
    if ([((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size] > 0) {
      [cMac updateWithByteArray:[((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) getBuffer] withInt:0 withInt:[((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size]];
    }
    extra = (extra + textLength) % 16;
    if (extra != 0) {
      for (jint i = extra; i != 16; i++) {
        [cMac updateWithByte:(jbyte) (jint) 0x00];
      }
    }
  }
  [cMac updateWithByteArray:data withInt:dataOff withInt:dataLen];
  return [cMac doFinalWithByteArray:macBlock withInt:0];
}

jint LibOrgBouncycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(LibOrgBouncycastleCryptoModesCCMBlockCipher *self) {
  return [((LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size] + ((self->initialAssociatedText_ == nil) ? 0 : ((IOSByteArray *) nil_chk(self->initialAssociatedText_))->size_);
}

jboolean LibOrgBouncycastleCryptoModesCCMBlockCipher_hasAssociatedText(LibOrgBouncycastleCryptoModesCCMBlockCipher *self) {
  return LibOrgBouncycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self) > 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesCCMBlockCipher)

@implementation LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesCCMBlockCipher:(LibOrgBouncycastleCryptoModesCCMBlockCipher *)outer$ {
  LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(self, outer$);
  return self;
}

- (IOSByteArray *)getBuffer {
  return self->buf_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoModesCCMBlockCipher:);
  methods[1].selector = @selector(getBuffer);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoModesCCMBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream = { "ExposedByteArrayOutputStream", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, NULL, 7, 0x2, 2, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;
}

@end

void LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$) {
  JavaIoByteArrayOutputStream_init(self);
}

LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_, outer$)
}

LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_(LibOrgBouncycastleCryptoModesCCMBlockCipher *outer$) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesCCMBlockCipher_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)

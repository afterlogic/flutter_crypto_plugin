//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/agreement/jpake/JPAKEParticipant.java
//

#include "Arrays.h"
#include "CryptoServicesRegistrar.h"
#include "Digest.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JPAKEParticipant.h"
#include "JPAKEPrimeOrderGroup.h"
#include "JPAKEPrimeOrderGroups.h"
#include "JPAKERound1Payload.h"
#include "JPAKERound2Payload.h"
#include "JPAKERound3Payload.h"
#include "JPAKEUtil.h"
#include "SHA256Digest.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/math/BigInteger.h"
#include "java/security/SecureRandom.h"

@interface LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant () {
 @public
  NSString *participantId_;
  IOSCharArray *password_;
  id<LibOrgBouncycastleCryptoDigest> digest_;
  JavaSecuritySecureRandom *random_;
  JavaMathBigInteger *p_;
  JavaMathBigInteger *q_;
  JavaMathBigInteger *g_;
  NSString *partnerParticipantId_;
  JavaMathBigInteger *x1_;
  JavaMathBigInteger *x2_;
  JavaMathBigInteger *gx1_;
  JavaMathBigInteger *gx2_;
  JavaMathBigInteger *gx3_;
  JavaMathBigInteger *gx4_;
  JavaMathBigInteger *b_;
  jint state_;
}

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, participantId_, NSString *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, password_, IOSCharArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, digest_, id<LibOrgBouncycastleCryptoDigest>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, random_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, p_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, q_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, g_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, partnerParticipantId_, NSString *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, x1_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, x2_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, gx1_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, gx2_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, gx3_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, gx4_, JavaMathBigInteger *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, b_, JavaMathBigInteger *)

@implementation LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant

+ (jint)STATE_INITIALIZED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_INITIALIZED;
}

+ (jint)STATE_ROUND_1_CREATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_CREATED;
}

+ (jint)STATE_ROUND_1_VALIDATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED;
}

+ (jint)STATE_ROUND_2_CREATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_CREATED;
}

+ (jint)STATE_ROUND_2_VALIDATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_VALIDATED;
}

+ (jint)STATE_KEY_CALCULATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED;
}

+ (jint)STATE_ROUND_3_CREATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_CREATED;
}

+ (jint)STATE_ROUND_3_VALIDATED {
  return LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_VALIDATED;
}

- (instancetype)initWithNSString:(NSString *)participantId
                   withCharArray:(IOSCharArray *)password {
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_(self, participantId, password);
  return self;
}

- (instancetype)initWithNSString:(NSString *)participantId
                   withCharArray:(IOSCharArray *)password
withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup:(LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *)group {
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_(self, participantId, password, group);
  return self;
}

- (instancetype)initWithNSString:(NSString *)participantId
                   withCharArray:(IOSCharArray *)password
withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup:(LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *)group
withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)digest
    withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(self, participantId, password, group, digest, random);
  return self;
}

- (jint)getState {
  return self->state_;
}

- (LibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload *)createRound1PayloadToSend {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_CREATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round1 payload already created for ", participantId_));
  }
  self->x1_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_generateX1WithJavaMathBigInteger_withJavaSecuritySecureRandom_(q_, random_);
  self->x2_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_generateX2WithJavaMathBigInteger_withJavaSecuritySecureRandom_(q_, random_);
  self->gx1_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateGxWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, g_, x1_);
  self->gx2_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateGxWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, g_, x2_);
  IOSObjectArray *knowledgeProofForX1 = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withNSString_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(p_, q_, g_, gx1_, x1_, participantId_, digest_, random_);
  IOSObjectArray *knowledgeProofForX2 = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withNSString_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(p_, q_, g_, gx2_, x2_, participantId_, digest_, random_);
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_CREATED;
  return new_LibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload_initWithNSString_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigIntegerArray_withJavaMathBigIntegerArray_(participantId_, gx1_, gx2_, knowledgeProofForX1, knowledgeProofForX2);
}

- (void)validateRound1PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload:(LibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload *)round1PayloadReceived {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Validation already attempted for round1 payload for", participantId_));
  }
  self->partnerParticipantId_ = [((LibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload *) nil_chk(round1PayloadReceived)) getParticipantId];
  self->gx3_ = [round1PayloadReceived getGx1];
  self->gx4_ = [round1PayloadReceived getGx2];
  IOSObjectArray *knowledgeProofForX3 = [round1PayloadReceived getKnowledgeProofForX1];
  IOSObjectArray *knowledgeProofForX4 = [round1PayloadReceived getKnowledgeProofForX2];
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateParticipantIdsDifferWithNSString_withNSString_(participantId_, [round1PayloadReceived getParticipantId]);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateGx4WithJavaMathBigInteger_(gx4_);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigIntegerArray_withNSString_withLibOrgBouncycastleCryptoDigest_(p_, q_, g_, gx3_, knowledgeProofForX3, [round1PayloadReceived getParticipantId], digest_);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigIntegerArray_withNSString_withLibOrgBouncycastleCryptoDigest_(p_, q_, g_, gx4_, knowledgeProofForX4, [round1PayloadReceived getParticipantId], digest_);
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED;
}

- (LibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload *)createRound2PayloadToSend {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_CREATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round2 payload already created for ", self->participantId_));
  }
  if (self->state_ < LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round1 payload must be validated prior to creating Round2 payload for ", self->participantId_));
  }
  JavaMathBigInteger *gA = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateGAWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, gx1_, gx3_, gx4_);
  JavaMathBigInteger *s = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateSWithCharArray_(password_);
  JavaMathBigInteger *x2s = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateX2sWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(q_, x2_, s);
  JavaMathBigInteger *A = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateAWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, q_, gA, x2s);
  IOSObjectArray *knowledgeProofForX2s = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withNSString_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(p_, q_, gA, A, x2s, participantId_, digest_, random_);
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_CREATED;
  return new_LibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload_initWithNSString_withJavaMathBigInteger_withJavaMathBigIntegerArray_(participantId_, A, knowledgeProofForX2s);
}

- (void)validateRound2PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload:(LibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload *)round2PayloadReceived {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Validation already attempted for round2 payload for", participantId_));
  }
  if (self->state_ < LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round1 payload must be validated prior to validating Round2 payload for ", self->participantId_));
  }
  JavaMathBigInteger *gB = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateGAWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, gx3_, gx1_, gx2_);
  self->b_ = [((LibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload *) nil_chk(round2PayloadReceived)) getA];
  IOSObjectArray *knowledgeProofForX4s = [round2PayloadReceived getKnowledgeProofForX2s];
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateParticipantIdsDifferWithNSString_withNSString_(participantId_, [round2PayloadReceived getParticipantId]);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateParticipantIdsEqualWithNSString_withNSString_(self->partnerParticipantId_, [round2PayloadReceived getParticipantId]);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateGaWithJavaMathBigInteger_(gB);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateZeroKnowledgeProofWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigIntegerArray_withNSString_withLibOrgBouncycastleCryptoDigest_(p_, q_, gB, b_, knowledgeProofForX4s, [round2PayloadReceived getParticipantId], digest_);
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_VALIDATED;
}

- (JavaMathBigInteger *)calculateKeyingMaterial {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Key already calculated for ", participantId_));
  }
  if (self->state_ < LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round2 payload must be validated prior to creating key for ", participantId_));
  }
  JavaMathBigInteger *s = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateSWithCharArray_(password_);
  LibOrgBouncycastleUtilArrays_fillWithCharArray_withChar_(password_, (jchar) 0);
  self->password_ = nil;
  JavaMathBigInteger *keyingMaterial = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateKeyingMaterialWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_(p_, q_, gx4_, x2_, s, b_);
  self->x1_ = nil;
  self->x2_ = nil;
  self->b_ = nil;
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED;
  return keyingMaterial;
}

- (LibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload *)createRound3PayloadToSendWithJavaMathBigInteger:(JavaMathBigInteger *)keyingMaterial {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_CREATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Round3 payload already created for ", self->participantId_));
  }
  if (self->state_ < LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Keying material must be calculated prior to creating Round3 payload for ", self->participantId_));
  }
  JavaMathBigInteger *macTag = LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_calculateMacTagWithNSString_withNSString_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withLibOrgBouncycastleCryptoDigest_(self->participantId_, self->partnerParticipantId_, self->gx1_, self->gx2_, self->gx3_, self->gx4_, keyingMaterial, self->digest_);
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_CREATED;
  return new_LibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload_initWithNSString_withJavaMathBigInteger_(participantId_, macTag);
}

- (void)validateRound3PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload:(LibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload *)round3PayloadReceived
                                                                           withJavaMathBigInteger:(JavaMathBigInteger *)keyingMaterial {
  if (self->state_ >= LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_VALIDATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Validation already attempted for round3 payload for", participantId_));
  }
  if (self->state_ < LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", @"Keying material must be calculated validated prior to validating Round3 payload for ", self->participantId_));
  }
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateParticipantIdsDifferWithNSString_withNSString_(participantId_, [((LibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload *) nil_chk(round3PayloadReceived)) getParticipantId]);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateParticipantIdsEqualWithNSString_withNSString_(self->partnerParticipantId_, [round3PayloadReceived getParticipantId]);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateMacTagWithNSString_withNSString_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withLibOrgBouncycastleCryptoDigest_withJavaMathBigInteger_(self->participantId_, self->partnerParticipantId_, self->gx1_, self->gx2_, self->gx3_, self->gx4_, keyingMaterial, self->digest_, [round3PayloadReceived getMacTag]);
  self->gx1_ = nil;
  self->gx2_ = nil;
  self->gx3_ = nil;
  self->gx4_ = nil;
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_VALIDATED;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, 5, -1, -1, -1 },
    { NULL, "LJavaMathBigInteger;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload;", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, 5, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:withCharArray:);
  methods[1].selector = @selector(initWithNSString:withCharArray:withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup:);
  methods[2].selector = @selector(initWithNSString:withCharArray:withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup:withLibOrgBouncycastleCryptoDigest:withJavaSecuritySecureRandom:);
  methods[3].selector = @selector(getState);
  methods[4].selector = @selector(createRound1PayloadToSend);
  methods[5].selector = @selector(validateRound1PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload:);
  methods[6].selector = @selector(createRound2PayloadToSend);
  methods[7].selector = @selector(validateRound2PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload:);
  methods[8].selector = @selector(calculateKeyingMaterial);
  methods[9].selector = @selector(createRound3PayloadToSendWithJavaMathBigInteger:);
  methods[10].selector = @selector(validateRound3PayloadReceivedWithLibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload:withJavaMathBigInteger:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "STATE_INITIALIZED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_INITIALIZED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_1_CREATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_CREATED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_1_VALIDATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_1_VALIDATED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_2_CREATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_CREATED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_2_VALIDATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_2_VALIDATED, 0x19, -1, -1, -1, -1 },
    { "STATE_KEY_CALCULATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_KEY_CALCULATED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_3_CREATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_CREATED, 0x19, -1, -1, -1, -1 },
    { "STATE_ROUND_3_VALIDATED", "I", .constantValue.asInt = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_ROUND_3_VALIDATED, 0x19, -1, -1, -1, -1 },
    { "participantId_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "password_", "[C", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "digest_", "LLibOrgBouncycastleCryptoDigest;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "random_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "p_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "q_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "g_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "partnerParticipantId_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x1_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x2_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "gx1_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "gx2_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "gx3_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "gx4_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "b_", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "state_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;[C", "LNSString;[CLLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup;", "LNSString;[CLLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup;LLibOrgBouncycastleCryptoDigest;LJavaSecuritySecureRandom;", "validateRound1PayloadReceived", "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound1Payload;", "LLibOrgBouncycastleCryptoCryptoException;", "validateRound2PayloadReceived", "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound2Payload;", "createRound3PayloadToSend", "LJavaMathBigInteger;", "validateRound3PayloadReceived", "LLibOrgBouncycastleCryptoAgreementJpakeJPAKERound3Payload;LJavaMathBigInteger;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant = { "JPAKEParticipant", "lib.org.bouncycastle.crypto.agreement.jpake", ptrTable, methods, fields, 7, 0x1, 11, 24, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant;
}

@end

void LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *self, NSString *participantId, IOSCharArray *password) {
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_(self, participantId, password, JreLoadStatic(LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroups, NIST_3072));
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *new_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_(NSString *participantId, IOSCharArray *password) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_, participantId, password)
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *create_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_(NSString *participantId, IOSCharArray *password) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_, participantId, password)
}

void LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *self, NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group) {
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(self, participantId, password, group, new_LibOrgBouncycastleCryptoDigestsSHA256Digest_init(), LibOrgBouncycastleCryptoCryptoServicesRegistrar_getSecureRandom());
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *new_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_(NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_, participantId, password, group)
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *create_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_(NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_, participantId, password, group)
}

void LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *self, NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group, id<LibOrgBouncycastleCryptoDigest> digest, JavaSecuritySecureRandom *random) {
  NSObject_init(self);
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateNotNullWithId_withNSString_(participantId, @"participantId");
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateNotNullWithId_withNSString_(password, @"password");
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateNotNullWithId_withNSString_(group, @"p");
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateNotNullWithId_withNSString_(digest, @"digest");
  LibOrgBouncycastleCryptoAgreementJpakeJPAKEUtil_validateNotNullWithId_withNSString_(random, @"random");
  if (((IOSCharArray *) nil_chk(password))->size_ == 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Password must not be empty.");
  }
  self->participantId_ = participantId;
  self->password_ = LibOrgBouncycastleUtilArrays_copyOfWithCharArray_withInt_(password, password->size_);
  self->p_ = [((LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *) nil_chk(group)) getP];
  self->q_ = [group getQ];
  self->g_ = [group getG];
  self->digest_ = digest;
  self->random_ = random;
  self->state_ = LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_STATE_INITIALIZED;
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *new_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group, id<LibOrgBouncycastleCryptoDigest> digest, JavaSecuritySecureRandom *random) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_, participantId, password, group, digest, random)
}

LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant *create_LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant_initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_(NSString *participantId, IOSCharArray *password, LibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup *group, id<LibOrgBouncycastleCryptoDigest> digest, JavaSecuritySecureRandom *random) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant, initWithNSString_withCharArray_withLibOrgBouncycastleCryptoAgreementJpakeJPAKEPrimeOrderGroup_withLibOrgBouncycastleCryptoDigest_withJavaSecuritySecureRandom_, participantId, password, group, digest, random)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoAgreementJpakeJPAKEParticipant)

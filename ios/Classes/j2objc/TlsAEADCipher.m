//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/TlsAEADCipher.java
//

#include "AEADBlockCipher.h"
#include "AEADParameters.h"
#include "AlertDescription.h"
#include "Arrays.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "ProtocolVersion.h"
#include "TlsAEADCipher.h"
#include "TlsContext.h"
#include "TlsFatalAlert.h"
#include "TlsUtils.h"
#include "java/lang/Exception.h"
#include "java/lang/System.h"

@implementation LibOrgBouncycastleCryptoTlsTlsAEADCipher

+ (jint)NONCE_RFC5288 {
  return LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288;
}

+ (jint)NONCE_DRAFT_CHACHA20_POLY1305 {
  return LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_DRAFT_CHACHA20_POLY1305;
}

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
             withLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)clientWriteCipher
             withLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)serverWriteCipher
                                                      withInt:(jint)cipherKeySize
                                                      withInt:(jint)macSize {
  LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_(self, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
             withLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)clientWriteCipher
             withLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)serverWriteCipher
                                                      withInt:(jint)cipherKeySize
                                                      withInt:(jint)macSize
                                                      withInt:(jint)nonceMode {
  LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_(self, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize, nonceMode);
  return self;
}

- (jint)getPlaintextLimitWithInt:(jint)ciphertextLimit {
  return ciphertextLimit - macSize_ - record_iv_length_;
}

- (IOSByteArray *)encodePlaintextWithLong:(jlong)seqNo
                                withShort:(jshort)type
                            withByteArray:(IOSByteArray *)plaintext
                                  withInt:(jint)offset
                                  withInt:(jint)len {
  IOSByteArray *nonce = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(encryptImplicitNonce_))->size_ + record_iv_length_];
  switch (nonceMode_) {
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288:
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(encryptImplicitNonce_, 0, nonce, 0, encryptImplicitNonce_->size_);
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, nonce, ((IOSByteArray *) nil_chk(encryptImplicitNonce_))->size_);
    break;
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_DRAFT_CHACHA20_POLY1305:
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, nonce, nonce->size_ - 8);
    for (jint i = 0; i < ((IOSByteArray *) nil_chk(encryptImplicitNonce_))->size_; ++i) {
      *IOSByteArray_GetRef(nonce, i) ^= IOSByteArray_Get(encryptImplicitNonce_, i);
    }
    break;
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  jint plaintextOffset = offset;
  jint plaintextLength = len;
  jint ciphertextLength = [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(encryptCipher_)) getOutputSizeWithInt:plaintextLength];
  IOSByteArray *output = [IOSByteArray newArrayWithLength:record_iv_length_ + ciphertextLength];
  if (record_iv_length_ != 0) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(nonce, nonce->size_ - record_iv_length_, output, 0, record_iv_length_);
  }
  jint outputPos = record_iv_length_;
  IOSByteArray *additionalData = [self getAdditionalDataWithLong:seqNo withShort:type withInt:plaintextLength];
  LibOrgBouncycastleCryptoParamsAEADParameters *parameters = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_withByteArray_(nil, 8 * macSize_, nonce, additionalData);
  @try {
    [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(encryptCipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:parameters];
    outputPos += [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(encryptCipher_)) processBytesWithByteArray:plaintext withInt:plaintextOffset withInt:plaintextLength withByteArray:output withInt:outputPos];
    outputPos += [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(encryptCipher_)) doFinalWithByteArray:output withInt:outputPos];
  }
  @catch (JavaLangException *e) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
  if (outputPos != output->size_) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  return output;
}

- (IOSByteArray *)decodeCiphertextWithLong:(jlong)seqNo
                                 withShort:(jshort)type
                             withByteArray:(IOSByteArray *)ciphertext
                                   withInt:(jint)offset
                                   withInt:(jint)len {
  if ([self getPlaintextLimitWithInt:len] < 0) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
  }
  IOSByteArray *nonce = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(decryptImplicitNonce_))->size_ + record_iv_length_];
  switch (nonceMode_) {
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288:
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(decryptImplicitNonce_, 0, nonce, 0, decryptImplicitNonce_->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ciphertext, offset, nonce, nonce->size_ - record_iv_length_, record_iv_length_);
    break;
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_DRAFT_CHACHA20_POLY1305:
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, nonce, nonce->size_ - 8);
    for (jint i = 0; i < ((IOSByteArray *) nil_chk(decryptImplicitNonce_))->size_; ++i) {
      *IOSByteArray_GetRef(nonce, i) ^= IOSByteArray_Get(decryptImplicitNonce_, i);
    }
    break;
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  jint ciphertextOffset = offset + record_iv_length_;
  jint ciphertextLength = len - record_iv_length_;
  jint plaintextLength = [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(decryptCipher_)) getOutputSizeWithInt:ciphertextLength];
  IOSByteArray *output = [IOSByteArray newArrayWithLength:plaintextLength];
  jint outputPos = 0;
  IOSByteArray *additionalData = [self getAdditionalDataWithLong:seqNo withShort:type withInt:plaintextLength];
  LibOrgBouncycastleCryptoParamsAEADParameters *parameters = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_withByteArray_(nil, 8 * macSize_, nonce, additionalData);
  @try {
    [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(decryptCipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:parameters];
    outputPos += [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(decryptCipher_)) processBytesWithByteArray:ciphertext withInt:ciphertextOffset withInt:ciphertextLength withByteArray:output withInt:outputPos];
    outputPos += [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(decryptCipher_)) doFinalWithByteArray:output withInt:outputPos];
  }
  @catch (JavaLangException *e) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_bad_record_mac, e);
  }
  if (outputPos != output->size_) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  return output;
}

- (IOSByteArray *)getAdditionalDataWithLong:(jlong)seqNo
                                  withShort:(jshort)type
                                    withInt:(jint)len {
  IOSByteArray *additional_data = [IOSByteArray newArrayWithLength:13];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, additional_data, 0);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withByteArray_withInt_(type, additional_data, 8);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withByteArray_withInt_([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context_)) getServerVersion], additional_data, 9);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withByteArray_withInt_(len, additional_data, 11);
  return additional_data;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, 1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, 1, -1, -1, -1 },
    { NULL, "I", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 5, 6, 1, -1, -1, -1 },
    { NULL, "[B", 0x1, 7, 6, 1, -1, -1, -1 },
    { NULL, "[B", 0x4, 8, 9, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoModesAEADBlockCipher:withLibOrgBouncycastleCryptoModesAEADBlockCipher:withInt:withInt:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoModesAEADBlockCipher:withLibOrgBouncycastleCryptoModesAEADBlockCipher:withInt:withInt:withInt:);
  methods[2].selector = @selector(getPlaintextLimitWithInt:);
  methods[3].selector = @selector(encodePlaintextWithLong:withShort:withByteArray:withInt:withInt:);
  methods[4].selector = @selector(decodeCiphertextWithLong:withShort:withByteArray:withInt:withInt:);
  methods[5].selector = @selector(getAdditionalDataWithLong:withShort:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NONCE_RFC5288", "I", .constantValue.asInt = LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288, 0x19, -1, -1, -1, -1 },
    { "NONCE_DRAFT_CHACHA20_POLY1305", "I", .constantValue.asInt = LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_DRAFT_CHACHA20_POLY1305, 0x18, -1, -1, -1, -1 },
    { "context_", "LLibOrgBouncycastleCryptoTlsTlsContext;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "record_iv_length_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "encryptCipher_", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "decryptCipher_", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "encryptImplicitNonce_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "decryptImplicitNonce_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "nonceMode_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoModesAEADBlockCipher;LLibOrgBouncycastleCryptoModesAEADBlockCipher;II", "LJavaIoIOException;", "LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoModesAEADBlockCipher;LLibOrgBouncycastleCryptoModesAEADBlockCipher;III", "getPlaintextLimit", "I", "encodePlaintext", "JS[BII", "decodeCiphertext", "getAdditionalData", "JSI" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsAEADCipher = { "TlsAEADCipher", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 6, 10, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsAEADCipher;
}

@end

void LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_(LibOrgBouncycastleCryptoTlsTlsAEADCipher *self, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize) {
  LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_(self, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize, LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288);
}

LibOrgBouncycastleCryptoTlsTlsAEADCipher *new_LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsAEADCipher, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize)
}

LibOrgBouncycastleCryptoTlsTlsAEADCipher *create_LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsAEADCipher, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize)
}

void LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_(LibOrgBouncycastleCryptoTlsTlsAEADCipher *self, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize, jint nonceMode) {
  NSObject_init(self);
  if (!LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(context)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  self->nonceMode_ = nonceMode;
  jint fixed_iv_length;
  switch (nonceMode) {
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_RFC5288:
    fixed_iv_length = 4;
    self->record_iv_length_ = 8;
    break;
    case LibOrgBouncycastleCryptoTlsTlsAEADCipher_NONCE_DRAFT_CHACHA20_POLY1305:
    fixed_iv_length = 12;
    self->record_iv_length_ = 0;
    break;
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  self->context_ = context;
  self->macSize_ = macSize;
  jint key_block_size = (2 * cipherKeySize) + (2 * fixed_iv_length);
  IOSByteArray *key_block = LibOrgBouncycastleCryptoTlsTlsUtils_calculateKeyBlockWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(context, key_block_size);
  jint offset = 0;
  LibOrgBouncycastleCryptoParamsKeyParameter *client_write_key = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key_block, offset, cipherKeySize);
  offset += cipherKeySize;
  LibOrgBouncycastleCryptoParamsKeyParameter *server_write_key = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key_block, offset, cipherKeySize);
  offset += cipherKeySize;
  IOSByteArray *client_write_IV = LibOrgBouncycastleUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(key_block, offset, offset + fixed_iv_length);
  offset += fixed_iv_length;
  IOSByteArray *server_write_IV = LibOrgBouncycastleUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(key_block, offset, offset + fixed_iv_length);
  offset += fixed_iv_length;
  if (offset != key_block_size) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  LibOrgBouncycastleCryptoParamsKeyParameter *encryptKey;
  LibOrgBouncycastleCryptoParamsKeyParameter *decryptKey;
  if ([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context)) isServer]) {
    self->encryptCipher_ = serverWriteCipher;
    self->decryptCipher_ = clientWriteCipher;
    self->encryptImplicitNonce_ = server_write_IV;
    self->decryptImplicitNonce_ = client_write_IV;
    encryptKey = server_write_key;
    decryptKey = client_write_key;
  }
  else {
    self->encryptCipher_ = clientWriteCipher;
    self->decryptCipher_ = serverWriteCipher;
    self->encryptImplicitNonce_ = client_write_IV;
    self->decryptImplicitNonce_ = server_write_IV;
    encryptKey = client_write_key;
    decryptKey = server_write_key;
  }
  IOSByteArray *dummyNonce = [IOSByteArray newArrayWithLength:fixed_iv_length + self->record_iv_length_];
  [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(self->encryptCipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_(encryptKey, 8 * macSize, dummyNonce)];
  [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(self->decryptCipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_(decryptKey, 8 * macSize, dummyNonce)];
}

LibOrgBouncycastleCryptoTlsTlsAEADCipher *new_LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize, jint nonceMode) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsAEADCipher, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize, nonceMode)
}

LibOrgBouncycastleCryptoTlsTlsAEADCipher *create_LibOrgBouncycastleCryptoTlsTlsAEADCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> clientWriteCipher, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> serverWriteCipher, jint cipherKeySize, jint macSize, jint nonceMode) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsAEADCipher, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withLibOrgBouncycastleCryptoModesAEADBlockCipher_withInt_withInt_withInt_, context, clientWriteCipher, serverWriteCipher, cipherKeySize, macSize, nonceMode)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsAEADCipher)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/modes/EAXBlockCipher.java
//

#include "AEADParameters.h"
#include "Arrays.h"
#include "BlockCipher.h"
#include "CMac.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "EAXBlockCipher.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "Mac.h"
#include "OutputLengthException.h"
#include "ParametersWithIV.h"
#include "SICBlockCipher.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoModesEAXBlockCipher () {
 @public
  LibOrgBouncycastleCryptoModesSICBlockCipher *cipher_;
  jboolean forEncryption_;
  jint blockSize_;
  id<LibOrgBouncycastleCryptoMac> mac_;
  IOSByteArray *nonceMac_;
  IOSByteArray *associatedTextMac_;
  IOSByteArray *macBlock_;
  jint macSize_;
  IOSByteArray *bufBlock_;
  jint bufOff_;
  jboolean cipherInitialized_;
  IOSByteArray *initialAssociatedText_;
}

- (void)initCipher OBJC_METHOD_FAMILY_NONE;

- (void)calculateMac;

- (void)resetWithBoolean:(jboolean)clearMac;

- (jint)processWithByte:(jbyte)b
          withByteArray:(IOSByteArray *)outArg
                withInt:(jint)outOff;

- (jboolean)verifyMacWithByteArray:(IOSByteArray *)mac
                           withInt:(jint)off;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, cipher_, LibOrgBouncycastleCryptoModesSICBlockCipher *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, mac_, id<LibOrgBouncycastleCryptoMac>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, nonceMac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, associatedTextMac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, bufBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesEAXBlockCipher, initialAssociatedText_, IOSByteArray *)

inline jbyte LibOrgBouncycastleCryptoModesEAXBlockCipher_get_nTAG(void);
#define LibOrgBouncycastleCryptoModesEAXBlockCipher_nTAG 0
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesEAXBlockCipher, nTAG, jbyte)

inline jbyte LibOrgBouncycastleCryptoModesEAXBlockCipher_get_hTAG(void);
#define LibOrgBouncycastleCryptoModesEAXBlockCipher_hTAG 1
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesEAXBlockCipher, hTAG, jbyte)

inline jbyte LibOrgBouncycastleCryptoModesEAXBlockCipher_get_cTAG(void);
#define LibOrgBouncycastleCryptoModesEAXBlockCipher_cTAG 2
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesEAXBlockCipher, cTAG, jbyte)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(LibOrgBouncycastleCryptoModesEAXBlockCipher *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesEAXBlockCipher_calculateMac(LibOrgBouncycastleCryptoModesEAXBlockCipher *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, jboolean clearMac);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoModesEAXBlockCipher_processWithByte_withByteArray_withInt_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, jbyte b, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static jboolean LibOrgBouncycastleCryptoModesEAXBlockCipher_verifyMacWithByteArray_withInt_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, IOSByteArray *mac, jint off);

@implementation LibOrgBouncycastleCryptoModesEAXBlockCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, cipher);
  return self;
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName], @"/EAX");
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) getUnderlyingCipher];
}

- (jint)getBlockSize {
  return [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) getBlockSize];
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  IOSByteArray *nonce;
  id<LibOrgBouncycastleCryptoCipherParameters> keyParam;
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]]) {
    LibOrgBouncycastleCryptoParamsAEADParameters *param = (LibOrgBouncycastleCryptoParamsAEADParameters *) params;
    nonce = [((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    initialAssociatedText_ = [param getAssociatedText];
    macSize_ = [param getMacSize] / 8;
    keyParam = [param getKey];
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithIV *param = (LibOrgBouncycastleCryptoParamsParametersWithIV *) params;
    nonce = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    initialAssociatedText_ = nil;
    macSize_ = [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) getMacSize] / 2;
    keyParam = [param getParameters];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"invalid parameters passed to EAX");
  }
  bufBlock_ = [IOSByteArray newArrayWithLength:forEncryption ? blockSize_ : (blockSize_ + macSize_)];
  IOSByteArray *tag = [IOSByteArray newArrayWithLength:blockSize_];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) init__WithLibOrgBouncycastleCryptoCipherParameters:keyParam];
  *IOSByteArray_GetRef(tag, blockSize_ - 1) = LibOrgBouncycastleCryptoModesEAXBlockCipher_nTAG;
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:tag withInt:0 withInt:blockSize_];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:nonce withInt:0 withInt:((IOSByteArray *) nil_chk(nonce))->size_];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) doFinalWithByteArray:nonceMac_ withInt:0];
  [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(nil, nonceMac_)];
  [self reset];
}

- (void)initCipher {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(self);
}

- (void)calculateMac {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_calculateMac(self);
}

- (void)reset {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(self, true);
}

- (void)resetWithBoolean:(jboolean)clearMac {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(self, clearMac);
}

- (void)processAADByteWithByte:(jbyte)inArg {
  if (cipherInitialized_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"AAD data cannot be added after encryption/decryption processing has begun.");
  }
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByte:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  if (cipherInitialized_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"AAD data cannot be added after encryption/decryption processing has begun.");
  }
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:inArg withInt:inOff withInt:len];
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(self);
  return LibOrgBouncycastleCryptoModesEAXBlockCipher_processWithByte_withByteArray_withInt_(self, inArg, outArg, outOff);
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(self);
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + len)) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  jint resultLen = 0;
  for (jint i = 0; i != len; i++) {
    resultLen += LibOrgBouncycastleCryptoModesEAXBlockCipher_processWithByte_withByteArray_withInt_(self, IOSByteArray_Get(inArg, inOff + i), outArg, outOff + resultLen);
  }
  return resultLen;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(self);
  jint extra = bufOff_;
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(bufBlock_))->size_];
  bufOff_ = 0;
  if (forEncryption_) {
    if (((IOSByteArray *) nil_chk(outArg))->size_ < (outOff + extra + macSize_)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
    [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) processBlockWithByteArray:bufBlock_ withInt:0 withByteArray:tmp withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, outArg, outOff, extra);
    [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:tmp withInt:0 withInt:extra];
    LibOrgBouncycastleCryptoModesEAXBlockCipher_calculateMac(self);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, outArg, outOff + extra, macSize_);
    LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(self, false);
    return extra + macSize_;
  }
  else {
    if (extra < macSize_) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    if (((IOSByteArray *) nil_chk(outArg))->size_ < (outOff + extra - macSize_)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
    if (extra > macSize_) {
      [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:bufBlock_ withInt:0 withInt:extra - macSize_];
      [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(cipher_)) processBlockWithByteArray:bufBlock_ withInt:0 withByteArray:tmp withInt:0];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, outArg, outOff, extra - macSize_);
    }
    LibOrgBouncycastleCryptoModesEAXBlockCipher_calculateMac(self);
    if (!LibOrgBouncycastleCryptoModesEAXBlockCipher_verifyMacWithByteArray_withInt_(self, bufBlock_, extra - macSize_)) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check in EAX failed");
    }
    LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(self, false);
    return extra - macSize_;
  }
}

- (IOSByteArray *)getMac {
  IOSByteArray *mac = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac, 0, macSize_);
  return mac;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (!forEncryption_) {
    if (totalData < macSize_) {
      return 0;
    }
    totalData -= macSize_;
  }
  return totalData - totalData % blockSize_;
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (jint)processWithByte:(jbyte)b
          withByteArray:(IOSByteArray *)outArg
                withInt:(jint)outOff {
  return LibOrgBouncycastleCryptoModesEAXBlockCipher_processWithByte_withByteArray_withInt_(self, b, outArg, outOff);
}

- (jboolean)verifyMacWithByteArray:(IOSByteArray *)mac
                           withInt:(jint)off {
  return LibOrgBouncycastleCryptoModesEAXBlockCipher_verifyMacWithByteArray_withInt_(self, mac, off);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 10, 11, 12, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, 12, -1, -1, -1 },
    { NULL, "I", 0x1, 15, 16, 17, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 20, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 21, 11, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 22, 16, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[1].selector = @selector(getAlgorithmName);
  methods[2].selector = @selector(getUnderlyingCipher);
  methods[3].selector = @selector(getBlockSize);
  methods[4].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[5].selector = @selector(initCipher);
  methods[6].selector = @selector(calculateMac);
  methods[7].selector = @selector(reset);
  methods[8].selector = @selector(resetWithBoolean:);
  methods[9].selector = @selector(processAADByteWithByte:);
  methods[10].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[11].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[12].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(doFinalWithByteArray:withInt:);
  methods[14].selector = @selector(getMac);
  methods[15].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[16].selector = @selector(getOutputSizeWithInt:);
  methods[17].selector = @selector(processWithByte:withByteArray:withInt:);
  methods[18].selector = @selector(verifyMacWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "nTAG", "B", .constantValue.asChar = LibOrgBouncycastleCryptoModesEAXBlockCipher_nTAG, 0x1a, -1, -1, -1, -1 },
    { "hTAG", "B", .constantValue.asChar = LibOrgBouncycastleCryptoModesEAXBlockCipher_hTAG, 0x1a, -1, -1, -1, -1 },
    { "cTAG", "B", .constantValue.asChar = LibOrgBouncycastleCryptoModesEAXBlockCipher_cTAG, 0x1a, -1, -1, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleCryptoModesSICBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blockSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mac_", "LLibOrgBouncycastleCryptoMac;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonceMac_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "associatedTextMac_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufOff_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cipherInitialized_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "reset", "Z", "processAADByte", "B", "processAADBytes", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;", "getUpdateOutputSize", "I", "getOutputSize", "process", "verifyMac" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesEAXBlockCipher = { "EAXBlockCipher", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 19, 15, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesEAXBlockCipher;
}

@end

void LibOrgBouncycastleCryptoModesEAXBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  NSObject_init(self);
  self->blockSize_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher)) getBlockSize];
  self->mac_ = new_LibOrgBouncycastleCryptoMacsCMac_initWithLibOrgBouncycastleCryptoBlockCipher_(cipher);
  self->macBlock_ = [IOSByteArray newArrayWithLength:self->blockSize_];
  self->associatedTextMac_ = [IOSByteArray newArrayWithLength:[self->mac_ getMacSize]];
  self->nonceMac_ = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) getMacSize]];
  self->cipher_ = new_LibOrgBouncycastleCryptoModesSICBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(cipher);
}

LibOrgBouncycastleCryptoModesEAXBlockCipher *new_LibOrgBouncycastleCryptoModesEAXBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesEAXBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

LibOrgBouncycastleCryptoModesEAXBlockCipher *create_LibOrgBouncycastleCryptoModesEAXBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesEAXBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

void LibOrgBouncycastleCryptoModesEAXBlockCipher_initCipher(LibOrgBouncycastleCryptoModesEAXBlockCipher *self) {
  if (self->cipherInitialized_) {
    return;
  }
  self->cipherInitialized_ = true;
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) doFinalWithByteArray:self->associatedTextMac_ withInt:0];
  IOSByteArray *tag = [IOSByteArray newArrayWithLength:self->blockSize_];
  *IOSByteArray_GetRef(tag, self->blockSize_ - 1) = LibOrgBouncycastleCryptoModesEAXBlockCipher_cTAG;
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) updateWithByteArray:tag withInt:0 withInt:self->blockSize_];
}

void LibOrgBouncycastleCryptoModesEAXBlockCipher_calculateMac(LibOrgBouncycastleCryptoModesEAXBlockCipher *self) {
  IOSByteArray *outC = [IOSByteArray newArrayWithLength:self->blockSize_];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) doFinalWithByteArray:outC withInt:0];
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(self->macBlock_))->size_; i++) {
    *IOSByteArray_GetRef(self->macBlock_, i) = (jbyte) (IOSByteArray_Get(nil_chk(self->nonceMac_), i) ^ IOSByteArray_Get(nil_chk(self->associatedTextMac_), i) ^ IOSByteArray_Get(outC, i));
  }
}

void LibOrgBouncycastleCryptoModesEAXBlockCipher_resetWithBoolean_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, jboolean clearMac) {
  [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(self->cipher_)) reset];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) reset];
  self->bufOff_ = 0;
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->bufBlock_, (jbyte) 0);
  if (clearMac) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->macBlock_, (jbyte) 0);
  }
  IOSByteArray *tag = [IOSByteArray newArrayWithLength:self->blockSize_];
  *IOSByteArray_GetRef(tag, self->blockSize_ - 1) = LibOrgBouncycastleCryptoModesEAXBlockCipher_hTAG;
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) updateWithByteArray:tag withInt:0 withInt:self->blockSize_];
  self->cipherInitialized_ = false;
  if (self->initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:self->initialAssociatedText_ withInt:0 withInt:self->initialAssociatedText_->size_];
  }
}

jint LibOrgBouncycastleCryptoModesEAXBlockCipher_processWithByte_withByteArray_withInt_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, jbyte b, IOSByteArray *outArg, jint outOff) {
  *IOSByteArray_GetRef(nil_chk(self->bufBlock_), self->bufOff_++) = b;
  if (self->bufOff_ == self->bufBlock_->size_) {
    if (((IOSByteArray *) nil_chk(outArg))->size_ < (outOff + self->blockSize_)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer is too short");
    }
    jint size;
    if (self->forEncryption_) {
      size = [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(self->cipher_)) processBlockWithByteArray:self->bufBlock_ withInt:0 withByteArray:outArg withInt:outOff];
      [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) updateWithByteArray:outArg withInt:outOff withInt:self->blockSize_];
    }
    else {
      [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) updateWithByteArray:self->bufBlock_ withInt:0 withInt:self->blockSize_];
      size = [((LibOrgBouncycastleCryptoModesSICBlockCipher *) nil_chk(self->cipher_)) processBlockWithByteArray:self->bufBlock_ withInt:0 withByteArray:outArg withInt:outOff];
    }
    self->bufOff_ = 0;
    if (!self->forEncryption_) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->bufBlock_, self->blockSize_, self->bufBlock_, 0, self->macSize_);
      self->bufOff_ = self->macSize_;
    }
    return size;
  }
  return 0;
}

jboolean LibOrgBouncycastleCryptoModesEAXBlockCipher_verifyMacWithByteArray_withInt_(LibOrgBouncycastleCryptoModesEAXBlockCipher *self, IOSByteArray *mac, jint off) {
  jint nonEqual = 0;
  for (jint i = 0; i < self->macSize_; i++) {
    nonEqual |= (IOSByteArray_Get(nil_chk(self->macBlock_), i) ^ IOSByteArray_Get(nil_chk(mac), off + i));
  }
  return nonEqual == 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesEAXBlockCipher)

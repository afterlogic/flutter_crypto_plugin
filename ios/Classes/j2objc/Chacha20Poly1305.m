//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/Chacha20Poly1305.java
//

#include "AlertDescription.h"
#include "Arrays.h"
#include "ChaCha7539Engine.h"
#include "Chacha20Poly1305.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "Mac.h"
#include "Pack.h"
#include "ParametersWithIV.h"
#include "Poly1305.h"
#include "ProtocolVersion.h"
#include "StreamCipher.h"
#include "TlsContext.h"
#include "TlsFatalAlert.h"
#include "TlsUtils.h"
#include "java/lang/System.h"

inline IOSByteArray *LibOrgBouncycastleCryptoTlsChacha20Poly1305_get_ZEROES(void);
static IOSByteArray *LibOrgBouncycastleCryptoTlsChacha20Poly1305_ZEROES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoTlsChacha20Poly1305, ZEROES, IOSByteArray *)

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoTlsChacha20Poly1305)

@implementation LibOrgBouncycastleCryptoTlsChacha20Poly1305

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context {
  LibOrgBouncycastleCryptoTlsChacha20Poly1305_initWithLibOrgBouncycastleCryptoTlsTlsContext_(self, context);
  return self;
}

- (jint)getPlaintextLimitWithInt:(jint)ciphertextLimit {
  return ciphertextLimit - 16;
}

- (IOSByteArray *)encodePlaintextWithLong:(jlong)seqNo
                                withShort:(jshort)type
                            withByteArray:(IOSByteArray *)plaintext
                                  withInt:(jint)offset
                                  withInt:(jint)len {
  LibOrgBouncycastleCryptoParamsKeyParameter *macKey = [self initRecordWithLibOrgBouncycastleCryptoStreamCipher:encryptCipher_ withBoolean:true withLong:seqNo withByteArray:encryptIV_];
  IOSByteArray *output = [IOSByteArray newArrayWithLength:len + 16];
  [((LibOrgBouncycastleCryptoEnginesChaCha7539Engine *) nil_chk(encryptCipher_)) processBytesWithByteArray:plaintext withInt:offset withInt:len withByteArray:output withInt:0];
  IOSByteArray *additionalData = [self getAdditionalDataWithLong:seqNo withShort:type withInt:len];
  IOSByteArray *mac = [self calculateRecordMACWithLibOrgBouncycastleCryptoParamsKeyParameter:macKey withByteArray:additionalData withByteArray:output withInt:0 withInt:len];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(mac, 0, output, len, ((IOSByteArray *) nil_chk(mac))->size_);
  return output;
}

- (IOSByteArray *)decodeCiphertextWithLong:(jlong)seqNo
                                 withShort:(jshort)type
                             withByteArray:(IOSByteArray *)ciphertext
                                   withInt:(jint)offset
                                   withInt:(jint)len {
  if ([self getPlaintextLimitWithInt:len] < 0) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
  }
  LibOrgBouncycastleCryptoParamsKeyParameter *macKey = [self initRecordWithLibOrgBouncycastleCryptoStreamCipher:decryptCipher_ withBoolean:false withLong:seqNo withByteArray:decryptIV_];
  jint plaintextLength = len - 16;
  IOSByteArray *additionalData = [self getAdditionalDataWithLong:seqNo withShort:type withInt:plaintextLength];
  IOSByteArray *calculatedMAC = [self calculateRecordMACWithLibOrgBouncycastleCryptoParamsKeyParameter:macKey withByteArray:additionalData withByteArray:ciphertext withInt:offset withInt:plaintextLength];
  IOSByteArray *receivedMAC = LibOrgBouncycastleUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(ciphertext, offset + plaintextLength, offset + len);
  if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(calculatedMAC, receivedMAC)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_bad_record_mac);
  }
  IOSByteArray *output = [IOSByteArray newArrayWithLength:plaintextLength];
  [((LibOrgBouncycastleCryptoEnginesChaCha7539Engine *) nil_chk(decryptCipher_)) processBytesWithByteArray:ciphertext withInt:offset withInt:plaintextLength withByteArray:output withInt:0];
  return output;
}

- (LibOrgBouncycastleCryptoParamsKeyParameter *)initRecordWithLibOrgBouncycastleCryptoStreamCipher:(id<LibOrgBouncycastleCryptoStreamCipher>)cipher
                                                                                       withBoolean:(jboolean)forEncryption
                                                                                          withLong:(jlong)seqNo
                                                                                     withByteArray:(IOSByteArray *)iv {
  IOSByteArray *nonce = [self calculateNonceWithLong:seqNo withByteArray:iv];
  [((id<LibOrgBouncycastleCryptoStreamCipher>) nil_chk(cipher)) init__WithBoolean:forEncryption withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(nil, nonce)];
  return [self generateRecordMACKeyWithLibOrgBouncycastleCryptoStreamCipher:cipher];
}

- (IOSByteArray *)calculateNonceWithLong:(jlong)seqNo
                           withByteArray:(IOSByteArray *)iv {
  IOSByteArray *nonce = [IOSByteArray newArrayWithLength:12];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, nonce, 4);
  for (jint i = 0; i < 12; ++i) {
    *IOSByteArray_GetRef(nonce, i) ^= IOSByteArray_Get(nil_chk(iv), i);
  }
  return nonce;
}

- (LibOrgBouncycastleCryptoParamsKeyParameter *)generateRecordMACKeyWithLibOrgBouncycastleCryptoStreamCipher:(id<LibOrgBouncycastleCryptoStreamCipher>)cipher {
  IOSByteArray *firstBlock = [IOSByteArray newArrayWithLength:64];
  [((id<LibOrgBouncycastleCryptoStreamCipher>) nil_chk(cipher)) processBytesWithByteArray:firstBlock withInt:0 withInt:firstBlock->size_ withByteArray:firstBlock withInt:0];
  LibOrgBouncycastleCryptoParamsKeyParameter *macKey = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(firstBlock, 0, 32);
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(firstBlock, (jbyte) 0);
  return macKey;
}

- (IOSByteArray *)calculateRecordMACWithLibOrgBouncycastleCryptoParamsKeyParameter:(LibOrgBouncycastleCryptoParamsKeyParameter *)macKey
                                                                     withByteArray:(IOSByteArray *)additionalData
                                                                     withByteArray:(IOSByteArray *)buf
                                                                           withInt:(jint)off
                                                                           withInt:(jint)len {
  id<LibOrgBouncycastleCryptoMac> mac = new_LibOrgBouncycastleCryptoMacsPoly1305_init();
  [mac init__WithLibOrgBouncycastleCryptoCipherParameters:macKey];
  [self updateRecordMACTextWithLibOrgBouncycastleCryptoMac:mac withByteArray:additionalData withInt:0 withInt:((IOSByteArray *) nil_chk(additionalData))->size_];
  [self updateRecordMACTextWithLibOrgBouncycastleCryptoMac:mac withByteArray:buf withInt:off withInt:len];
  [self updateRecordMACLengthWithLibOrgBouncycastleCryptoMac:mac withInt:additionalData->size_];
  [self updateRecordMACLengthWithLibOrgBouncycastleCryptoMac:mac withInt:len];
  IOSByteArray *output = [IOSByteArray newArrayWithLength:[mac getMacSize]];
  [mac doFinalWithByteArray:output withInt:0];
  return output;
}

- (void)updateRecordMACLengthWithLibOrgBouncycastleCryptoMac:(id<LibOrgBouncycastleCryptoMac>)mac
                                                     withInt:(jint)len {
  IOSByteArray *longLen = LibOrgBouncycastleUtilPack_longToLittleEndianWithLong_(len & (jlong) 0xFFFFFFFFLL);
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac)) updateWithByteArray:longLen withInt:0 withInt:((IOSByteArray *) nil_chk(longLen))->size_];
}

- (void)updateRecordMACTextWithLibOrgBouncycastleCryptoMac:(id<LibOrgBouncycastleCryptoMac>)mac
                                             withByteArray:(IOSByteArray *)buf
                                                   withInt:(jint)off
                                                   withInt:(jint)len {
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac)) updateWithByteArray:buf withInt:off withInt:len];
  jint partial = len % 16;
  if (partial != 0) {
    [mac updateWithByteArray:LibOrgBouncycastleCryptoTlsChacha20Poly1305_ZEROES withInt:0 withInt:16 - partial];
  }
}

- (IOSByteArray *)getAdditionalDataWithLong:(jlong)seqNo
                                  withShort:(jshort)type
                                    withInt:(jint)len {
  IOSByteArray *additional_data = [IOSByteArray newArrayWithLength:13];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, additional_data, 0);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withByteArray_withInt_(type, additional_data, 8);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withByteArray_withInt_([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context_)) getServerVersion], additional_data, 9);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withByteArray_withInt_(len, additional_data, 11);
  return additional_data;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, 1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 4, 5, 1, -1, -1, -1 },
    { NULL, "[B", 0x1, 6, 5, 1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoParamsKeyParameter;", 0x4, 7, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 9, 10, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoParamsKeyParameter;", 0x4, 11, 12, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 17, 18, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 19, 20, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsContext:);
  methods[1].selector = @selector(getPlaintextLimitWithInt:);
  methods[2].selector = @selector(encodePlaintextWithLong:withShort:withByteArray:withInt:withInt:);
  methods[3].selector = @selector(decodeCiphertextWithLong:withShort:withByteArray:withInt:withInt:);
  methods[4].selector = @selector(initRecordWithLibOrgBouncycastleCryptoStreamCipher:withBoolean:withLong:withByteArray:);
  methods[5].selector = @selector(calculateNonceWithLong:withByteArray:);
  methods[6].selector = @selector(generateRecordMACKeyWithLibOrgBouncycastleCryptoStreamCipher:);
  methods[7].selector = @selector(calculateRecordMACWithLibOrgBouncycastleCryptoParamsKeyParameter:withByteArray:withByteArray:withInt:withInt:);
  methods[8].selector = @selector(updateRecordMACLengthWithLibOrgBouncycastleCryptoMac:withInt:);
  methods[9].selector = @selector(updateRecordMACTextWithLibOrgBouncycastleCryptoMac:withByteArray:withInt:withInt:);
  methods[10].selector = @selector(getAdditionalDataWithLong:withShort:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ZEROES", "[B", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "context_", "LLibOrgBouncycastleCryptoTlsTlsContext;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "encryptCipher_", "LLibOrgBouncycastleCryptoEnginesChaCha7539Engine;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "decryptCipher_", "LLibOrgBouncycastleCryptoEnginesChaCha7539Engine;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "encryptIV_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "decryptIV_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsTlsContext;", "LJavaIoIOException;", "getPlaintextLimit", "I", "encodePlaintext", "JS[BII", "decodeCiphertext", "initRecord", "LLibOrgBouncycastleCryptoStreamCipher;ZJ[B", "calculateNonce", "J[B", "generateRecordMACKey", "LLibOrgBouncycastleCryptoStreamCipher;", "calculateRecordMAC", "LLibOrgBouncycastleCryptoParamsKeyParameter;[B[BII", "updateRecordMACLength", "LLibOrgBouncycastleCryptoMac;I", "updateRecordMACText", "LLibOrgBouncycastleCryptoMac;[BII", "getAdditionalData", "JSI", &LibOrgBouncycastleCryptoTlsChacha20Poly1305_ZEROES };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsChacha20Poly1305 = { "Chacha20Poly1305", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 11, 6, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsChacha20Poly1305;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoTlsChacha20Poly1305 class]) {
    LibOrgBouncycastleCryptoTlsChacha20Poly1305_ZEROES = [IOSByteArray newArrayWithLength:15];
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoTlsChacha20Poly1305)
  }
}

@end

void LibOrgBouncycastleCryptoTlsChacha20Poly1305_initWithLibOrgBouncycastleCryptoTlsTlsContext_(LibOrgBouncycastleCryptoTlsChacha20Poly1305 *self, id<LibOrgBouncycastleCryptoTlsTlsContext> context) {
  NSObject_init(self);
  if (!LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(context)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  self->context_ = context;
  jint cipherKeySize = 32;
  jint fixed_iv_length = 12;
  jint key_block_size = (2 * cipherKeySize) + (2 * fixed_iv_length);
  IOSByteArray *key_block = LibOrgBouncycastleCryptoTlsTlsUtils_calculateKeyBlockWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(context, key_block_size);
  jint offset = 0;
  LibOrgBouncycastleCryptoParamsKeyParameter *client_write_key = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key_block, offset, cipherKeySize);
  offset += cipherKeySize;
  LibOrgBouncycastleCryptoParamsKeyParameter *server_write_key = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key_block, offset, cipherKeySize);
  offset += cipherKeySize;
  IOSByteArray *client_write_IV = LibOrgBouncycastleUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(key_block, offset, offset + fixed_iv_length);
  offset += fixed_iv_length;
  IOSByteArray *server_write_IV = LibOrgBouncycastleUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(key_block, offset, offset + fixed_iv_length);
  offset += fixed_iv_length;
  if (offset != key_block_size) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  self->encryptCipher_ = new_LibOrgBouncycastleCryptoEnginesChaCha7539Engine_init();
  self->decryptCipher_ = new_LibOrgBouncycastleCryptoEnginesChaCha7539Engine_init();
  LibOrgBouncycastleCryptoParamsKeyParameter *encryptKey;
  LibOrgBouncycastleCryptoParamsKeyParameter *decryptKey;
  if ([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context)) isServer]) {
    encryptKey = server_write_key;
    decryptKey = client_write_key;
    self->encryptIV_ = server_write_IV;
    self->decryptIV_ = client_write_IV;
  }
  else {
    encryptKey = client_write_key;
    decryptKey = server_write_key;
    self->encryptIV_ = client_write_IV;
    self->decryptIV_ = server_write_IV;
  }
  [((LibOrgBouncycastleCryptoEnginesChaCha7539Engine *) nil_chk(self->encryptCipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(encryptKey, self->encryptIV_)];
  [((LibOrgBouncycastleCryptoEnginesChaCha7539Engine *) nil_chk(self->decryptCipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(decryptKey, self->decryptIV_)];
}

LibOrgBouncycastleCryptoTlsChacha20Poly1305 *new_LibOrgBouncycastleCryptoTlsChacha20Poly1305_initWithLibOrgBouncycastleCryptoTlsTlsContext_(id<LibOrgBouncycastleCryptoTlsTlsContext> context) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsChacha20Poly1305, initWithLibOrgBouncycastleCryptoTlsTlsContext_, context)
}

LibOrgBouncycastleCryptoTlsChacha20Poly1305 *create_LibOrgBouncycastleCryptoTlsChacha20Poly1305_initWithLibOrgBouncycastleCryptoTlsTlsContext_(id<LibOrgBouncycastleCryptoTlsTlsContext> context) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsChacha20Poly1305, initWithLibOrgBouncycastleCryptoTlsTlsContext_, context)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsChacha20Poly1305)

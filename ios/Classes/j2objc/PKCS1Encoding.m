//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/encodings/PKCS1Encoding.java
//

#include "Arrays.h"
#include "AsymmetricBlockCipher.h"
#include "AsymmetricKeyParameter.h"
#include "CipherParameters.h"
#include "CryptoServicesRegistrar.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "PKCS1Encoding.h"
#include "ParametersWithRandom.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/security/AccessController.h"
#include "java/security/PrivilegedAction.h"
#include "java/security/SecureRandom.h"

@interface LibOrgBouncycastleCryptoEncodingsPKCS1Encoding () {
 @public
  JavaSecuritySecureRandom *random_;
  id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine_;
  jboolean forEncryption_;
  jboolean forPrivateKey_;
  jboolean useStrictLength_;
  jint pLen_;
  IOSByteArray *fallback_;
  IOSByteArray *blockBuffer_;
}

- (jboolean)useStrict;

- (IOSByteArray *)encodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen;

+ (jint)checkPkcs1EncodingWithByteArray:(IOSByteArray *)encoded
                                withInt:(jint)pLen;

- (IOSByteArray *)decodeBlockOrRandomWithByteArray:(IOSByteArray *)inArg
                                           withInt:(jint)inOff
                                           withInt:(jint)inLen;

- (IOSByteArray *)decodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen;

- (jint)findStartWithByte:(jbyte)type
            withByteArray:(IOSByteArray *)block;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, random_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, engine_, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, fallback_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, blockBuffer_, IOSByteArray *)

inline jint LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_get_HEADER_LENGTH(void);
#define LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_HEADER_LENGTH 10
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, HEADER_LENGTH, jint)

__attribute__((unused)) static jboolean LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_encodeBlockWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_checkPkcs1EncodingWithByteArray_withInt_(IOSByteArray *encoded, jint pLen);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockOrRandomWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_findStartWithByte_withByteArray_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, jbyte type, IOSByteArray *block);

@interface LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 : NSObject < JavaSecurityPrivilegedAction >

- (instancetype)init;

- (id)run;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1)

__attribute__((unused)) static void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *self);

__attribute__((unused)) static LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init(void);

@interface LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 : NSObject < JavaSecurityPrivilegedAction >

- (instancetype)init;

- (id)run;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2)

__attribute__((unused)) static void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *self);

__attribute__((unused)) static LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init(void);

NSString *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_STRICT_LENGTH_ENABLED_PROPERTY = @"lib.org.bouncycastle.pkcs1.strict";
NSString *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_NOT_STRICT_LENGTH_ENABLED_PROPERTY = @"lib.org.bouncycastle.pkcs1.not_strict";

@implementation LibOrgBouncycastleCryptoEncodingsPKCS1Encoding

+ (NSString *)STRICT_LENGTH_ENABLED_PROPERTY {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_STRICT_LENGTH_ENABLED_PROPERTY;
}

+ (NSString *)NOT_STRICT_LENGTH_ENABLED_PROPERTY {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_NOT_STRICT_LENGTH_ENABLED_PROPERTY;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, cipher);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher
                                                              withInt:(jint)pLen {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_(self, cipher, pLen);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher
                                                        withByteArray:(IOSByteArray *)fallback {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_(self, cipher, fallback);
  return self;
}

- (jboolean)useStrict {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(self);
}

- (id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)getUnderlyingCipher {
  return engine_;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)param {
  LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *kParam;
  if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithRandom class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithRandom *rParam = (LibOrgBouncycastleCryptoParamsParametersWithRandom *) param;
    self->random_ = [((LibOrgBouncycastleCryptoParamsParametersWithRandom *) nil_chk(rParam)) getRandom];
    kParam = (LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *) cast_chk([rParam getParameters], [LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter class]);
  }
  else {
    kParam = (LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *) cast_chk(param, [LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter class]);
    if (![((LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *) nil_chk(kParam)) isPrivate] && forEncryption) {
      self->random_ = LibOrgBouncycastleCryptoCryptoServicesRegistrar_getSecureRandom();
    }
  }
  [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) init__WithBoolean:forEncryption withLibOrgBouncycastleCryptoCipherParameters:param];
  self->forPrivateKey_ = [((LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *) nil_chk(kParam)) isPrivate];
  self->forEncryption_ = forEncryption;
  self->blockBuffer_ = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getOutputBlockSize]];
  if (pLen_ > 0 && fallback_ == nil && random_ == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"encoder requires random");
  }
}

- (jint)getInputBlockSize {
  jint baseBlockSize = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getInputBlockSize];
  if (forEncryption_) {
    return baseBlockSize - LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_HEADER_LENGTH;
  }
  else {
    return baseBlockSize;
  }
}

- (jint)getOutputBlockSize {
  jint baseBlockSize = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getOutputBlockSize];
  if (forEncryption_) {
    return baseBlockSize;
  }
  else {
    return baseBlockSize - LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_HEADER_LENGTH;
  }
}

- (IOSByteArray *)processBlockWithByteArray:(IOSByteArray *)inArg
                                    withInt:(jint)inOff
                                    withInt:(jint)inLen {
  if (forEncryption_) {
    return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_encodeBlockWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
  }
  else {
    return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
  }
}

- (IOSByteArray *)encodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_encodeBlockWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
}

+ (jint)checkPkcs1EncodingWithByteArray:(IOSByteArray *)encoded
                                withInt:(jint)pLen {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_checkPkcs1EncodingWithByteArray_withInt_(encoded, pLen);
}

- (IOSByteArray *)decodeBlockOrRandomWithByteArray:(IOSByteArray *)inArg
                                           withInt:(jint)inOff
                                           withInt:(jint)inLen {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockOrRandomWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
}

- (IOSByteArray *)decodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
}

- (jint)findStartWithByte:(jbyte)type
            withByteArray:(IOSByteArray *)block {
  return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_findStartWithByte_withByteArray_(self, type, block);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 5, 6, 7, -1, -1, -1 },
    { NULL, "[B", 0x2, 8, 6, 7, -1, -1, -1 },
    { NULL, "I", 0xa, 9, 10, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 11, 6, 7, -1, -1, -1 },
    { NULL, "[B", 0x2, 12, 6, 7, -1, -1, -1 },
    { NULL, "I", 0x2, 13, 14, 7, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:withInt:);
  methods[2].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:withByteArray:);
  methods[3].selector = @selector(useStrict);
  methods[4].selector = @selector(getUnderlyingCipher);
  methods[5].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[6].selector = @selector(getInputBlockSize);
  methods[7].selector = @selector(getOutputBlockSize);
  methods[8].selector = @selector(processBlockWithByteArray:withInt:withInt:);
  methods[9].selector = @selector(encodeBlockWithByteArray:withInt:withInt:);
  methods[10].selector = @selector(checkPkcs1EncodingWithByteArray:withInt:);
  methods[11].selector = @selector(decodeBlockOrRandomWithByteArray:withInt:withInt:);
  methods[12].selector = @selector(decodeBlockWithByteArray:withInt:withInt:);
  methods[13].selector = @selector(findStartWithByte:withByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "STRICT_LENGTH_ENABLED_PROPERTY", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 15, -1, -1 },
    { "NOT_STRICT_LENGTH_ENABLED_PROPERTY", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 16, -1, -1 },
    { "HEADER_LENGTH", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_HEADER_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "random_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forPrivateKey_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "useStrictLength_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pLen_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "fallback_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blockBuffer_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;I", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;[B", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "processBlock", "[BII", "LLibOrgBouncycastleCryptoInvalidCipherTextException;", "encodeBlock", "checkPkcs1Encoding", "[BI", "decodeBlockOrRandom", "decodeBlock", "findStart", "B[B", &LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_STRICT_LENGTH_ENABLED_PROPERTY, &LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_NOT_STRICT_LENGTH_ENABLED_PROPERTY };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEncodingsPKCS1Encoding = { "PKCS1Encoding", "lib.org.bouncycastle.crypto.encodings", ptrTable, methods, fields, 7, 0x1, 14, 11, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding;
}

@end

void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  NSObject_init(self);
  self->pLen_ = -1;
  self->fallback_ = nil;
  self->engine_ = cipher;
  self->useStrictLength_ = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(self);
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, cipher)
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, cipher)
}

void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, jint pLen) {
  NSObject_init(self);
  self->pLen_ = -1;
  self->fallback_ = nil;
  self->engine_ = cipher;
  self->useStrictLength_ = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(self);
  self->pLen_ = pLen;
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, jint pLen) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_, cipher, pLen)
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, jint pLen) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withInt_, cipher, pLen)
}

void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, IOSByteArray *fallback) {
  NSObject_init(self);
  self->pLen_ = -1;
  self->fallback_ = nil;
  self->engine_ = cipher;
  self->useStrictLength_ = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(self);
  self->fallback_ = fallback;
  self->pLen_ = ((IOSByteArray *) nil_chk(fallback))->size_;
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, IOSByteArray *fallback) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_, cipher, fallback)
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, IOSByteArray *fallback) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withByteArray_, cipher, fallback)
}

jboolean LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_useStrict(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self) {
  NSString *strict = (NSString *) cast_chk(JavaSecurityAccessController_doPrivilegedWithJavaSecurityPrivilegedAction_(new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init()), [NSString class]);
  NSString *notStrict = (NSString *) cast_chk(JavaSecurityAccessController_doPrivilegedWithJavaSecurityPrivilegedAction_(new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init()), [NSString class]);
  if (notStrict != nil) {
    return ![notStrict isEqual:@"true"];
  }
  return strict == nil || [strict isEqual:@"true"];
}

IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_encodeBlockWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen) {
  if (inLen > [self getInputBlockSize]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"input data too large");
  }
  IOSByteArray *block = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) getInputBlockSize]];
  if (self->forPrivateKey_) {
    *IOSByteArray_GetRef(block, 0) = (jint) 0x01;
    for (jint i = 1; i != block->size_ - inLen - 1; i++) {
      *IOSByteArray_GetRef(block, i) = (jbyte) (jint) 0xFF;
    }
  }
  else {
    [((JavaSecuritySecureRandom *) nil_chk(self->random_)) nextBytesWithByteArray:block];
    *IOSByteArray_GetRef(block, 0) = (jint) 0x02;
    for (jint i = 1; i != block->size_ - inLen - 1; i++) {
      while (IOSByteArray_Get(block, i) == 0) {
        *IOSByteArray_GetRef(block, i) = (jbyte) [((JavaSecuritySecureRandom *) nil_chk(self->random_)) nextInt];
      }
    }
  }
  *IOSByteArray_GetRef(block, block->size_ - inLen - 1) = (jint) 0x00;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff, block, block->size_ - inLen, inLen);
  return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:block withInt:0 withInt:block->size_];
}

jint LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_checkPkcs1EncodingWithByteArray_withInt_(IOSByteArray *encoded, jint pLen) {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initialize();
  jint correct = 0;
  correct |= (IOSByteArray_Get(nil_chk(encoded), 0) ^ 2);
  jint plen = encoded->size_ - (pLen + 1);
  for (jint i = 1; i < plen; i++) {
    jint tmp = IOSByteArray_Get(encoded, i);
    tmp |= JreRShift32(tmp, 1);
    tmp |= JreRShift32(tmp, 2);
    tmp |= JreRShift32(tmp, 4);
    correct |= (tmp & 1) - 1;
  }
  correct |= IOSByteArray_Get(encoded, encoded->size_ - (pLen + 1));
  correct |= JreRShift32(correct, 1);
  correct |= JreRShift32(correct, 2);
  correct |= JreRShift32(correct, 4);
  return ~((correct & 1) - 1);
}

IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockOrRandomWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen) {
  if (!self->forPrivateKey_) {
    @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"sorry, this method is only for decryption, not for signing");
  }
  IOSByteArray *block = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:inArg withInt:inOff withInt:inLen];
  IOSByteArray *random;
  if (self->fallback_ == nil) {
    random = [IOSByteArray newArrayWithLength:self->pLen_];
    [((JavaSecuritySecureRandom *) nil_chk(self->random_)) nextBytesWithByteArray:random];
  }
  else {
    random = self->fallback_;
  }
  IOSByteArray *data = (self->useStrictLength_ & (((IOSByteArray *) nil_chk(block))->size_ != [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) getOutputBlockSize])) ? self->blockBuffer_ : block;
  jint correct = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_checkPkcs1EncodingWithByteArray_withInt_(data, self->pLen_);
  IOSByteArray *result = [IOSByteArray newArrayWithLength:self->pLen_];
  for (jint i = 0; i < self->pLen_; i++) {
    *IOSByteArray_GetRef(result, i) = (jbyte) ((IOSByteArray_Get(data, i + (data->size_ - self->pLen_)) & (~correct)) | (IOSByteArray_Get(random, i) & correct));
  }
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(data, (jbyte) 0);
  return result;
}

IOSByteArray *LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, IOSByteArray *inArg, jint inOff, jint inLen) {
  if (self->pLen_ != -1) {
    return LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_decodeBlockOrRandomWithByteArray_withInt_withInt_(self, inArg, inOff, inLen);
  }
  IOSByteArray *block = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:inArg withInt:inOff withInt:inLen];
  jboolean incorrectLength = (self->useStrictLength_ & (((IOSByteArray *) nil_chk(block))->size_ != [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->engine_)) getOutputBlockSize]));
  IOSByteArray *data;
  if (block->size_ < [self getOutputBlockSize]) {
    data = self->blockBuffer_;
  }
  else {
    data = block;
  }
  jbyte type = IOSByteArray_Get(nil_chk(data), 0);
  jboolean badType;
  if (self->forPrivateKey_) {
    badType = (type != 2);
  }
  else {
    badType = (type != 1);
  }
  jint start = LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_findStartWithByte_withByteArray_(self, type, data);
  start++;
  if (badType | (start < LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_HEADER_LENGTH)) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(data, (jbyte) 0);
    @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"block incorrect");
  }
  if (incorrectLength) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(data, (jbyte) 0);
    @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"block incorrect size");
  }
  IOSByteArray *result = [IOSByteArray newArrayWithLength:data->size_ - start];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, start, result, 0, result->size_);
  return result;
}

jint LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_findStartWithByte_withByteArray_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding *self, jbyte type, IOSByteArray *block) {
  jint start = -1;
  jboolean padErr = false;
  for (jint i = 1; i != ((IOSByteArray *) nil_chk(block))->size_; i++) {
    jbyte pad = IOSByteArray_Get(block, i);
    if ((pad == 0) & (start < 0)) {
      start = i;
    }
    padErr |= ((type == 1) & (start < 0) & (pad != (jbyte) (jint) 0xff));
  }
  if (padErr) {
    return -1;
  }
  return start;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding)

@implementation LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id)run {
  return JavaLangSystem_getPropertyWithNSString_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_STRICT_LENGTH_ENABLED_PROPERTY);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoEncodingsPKCS1Encoding;", "useStrict" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 = { "", "lib.org.bouncycastle.crypto.encodings", ptrTable, methods, NULL, 7, 0x8010, 2, 0, 0, -1, 1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1;
}

@end

void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *self) {
  NSObject_init(self);
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1, init)
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1 *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_1, init)
}

@implementation LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id)run {
  return JavaLangSystem_getPropertyWithNSString_(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_NOT_STRICT_LENGTH_ENABLED_PROPERTY);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoEncodingsPKCS1Encoding;", "useStrict" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 = { "", "lib.org.bouncycastle.crypto.encodings", ptrTable, methods, NULL, 7, 0x8010, 2, 0, 0, -1, 1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2;
}

@end

void LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *self) {
  NSObject_init(self);
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2, init)
}

LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2 *create_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_2, init)
}

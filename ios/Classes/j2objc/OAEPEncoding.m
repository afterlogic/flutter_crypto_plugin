//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/encodings/OAEPEncoding.java
//

#include "Arrays.h"
#include "AsymmetricBlockCipher.h"
#include "CipherParameters.h"
#include "CryptoServicesRegistrar.h"
#include "DataLengthException.h"
#include "Digest.h"
#include "DigestFactory.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "OAEPEncoding.h"
#include "ParametersWithRandom.h"
#include "java/lang/System.h"
#include "java/security/SecureRandom.h"

@interface LibOrgBouncycastleCryptoEncodingsOAEPEncoding () {
 @public
  IOSByteArray *defHash_;
  id<LibOrgBouncycastleCryptoDigest> mgf1Hash_;
  id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine_;
  JavaSecuritySecureRandom *random_;
  jboolean forEncryption_;
}

- (void)ItoOSPWithInt:(jint)i
        withByteArray:(IOSByteArray *)sp;

- (IOSByteArray *)maskGeneratorFunction1WithByteArray:(IOSByteArray *)Z
                                              withInt:(jint)zOff
                                              withInt:(jint)zLen
                                              withInt:(jint)length;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, defHash_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, mgf1Hash_, id<LibOrgBouncycastleCryptoDigest>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, engine_, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, random_, JavaSecuritySecureRandom *)

__attribute__((unused)) static void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_ItoOSPWithInt_withByteArray_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, jint i, IOSByteArray *sp);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, IOSByteArray *Z, jint zOff, jint zLen, jint length);

@implementation LibOrgBouncycastleCryptoEncodingsOAEPEncoding

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, cipher);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher
                                   withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)hash_ {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_(self, cipher, hash_);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher
                                   withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)hash_
                                                        withByteArray:(IOSByteArray *)encodingParams {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(self, cipher, hash_, encodingParams);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)cipher
                                   withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)hash_
                                   withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)mgf1Hash
                                                        withByteArray:(IOSByteArray *)encodingParams {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(self, cipher, hash_, mgf1Hash, encodingParams);
  return self;
}

- (id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)getUnderlyingCipher {
  return engine_;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)param {
  if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithRandom class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithRandom *rParam = (LibOrgBouncycastleCryptoParamsParametersWithRandom *) param;
    self->random_ = [((LibOrgBouncycastleCryptoParamsParametersWithRandom *) nil_chk(rParam)) getRandom];
  }
  else {
    self->random_ = LibOrgBouncycastleCryptoCryptoServicesRegistrar_getSecureRandom();
  }
  [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) init__WithBoolean:forEncryption withLibOrgBouncycastleCryptoCipherParameters:param];
  self->forEncryption_ = forEncryption;
}

- (jint)getInputBlockSize {
  jint baseBlockSize = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getInputBlockSize];
  if (forEncryption_) {
    return baseBlockSize - 1 - 2 * ((IOSByteArray *) nil_chk(defHash_))->size_;
  }
  else {
    return baseBlockSize;
  }
}

- (jint)getOutputBlockSize {
  jint baseBlockSize = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getOutputBlockSize];
  if (forEncryption_) {
    return baseBlockSize;
  }
  else {
    return baseBlockSize - 1 - 2 * ((IOSByteArray *) nil_chk(defHash_))->size_;
  }
}

- (IOSByteArray *)processBlockWithByteArray:(IOSByteArray *)inArg
                                    withInt:(jint)inOff
                                    withInt:(jint)inLen {
  if (forEncryption_) {
    return [self encodeBlockWithByteArray:inArg withInt:inOff withInt:inLen];
  }
  else {
    return [self decodeBlockWithByteArray:inArg withInt:inOff withInt:inLen];
  }
}

- (IOSByteArray *)encodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen {
  if (inLen > [self getInputBlockSize]) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input data too long");
  }
  IOSByteArray *block = [IOSByteArray newArrayWithLength:[self getInputBlockSize] + 1 + 2 * ((IOSByteArray *) nil_chk(defHash_))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff, block, block->size_ - inLen, inLen);
  *IOSByteArray_GetRef(block, block->size_ - inLen - 1) = (jint) 0x01;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(defHash_, 0, block, ((IOSByteArray *) nil_chk(defHash_))->size_, defHash_->size_);
  IOSByteArray *seed = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(defHash_))->size_];
  [((JavaSecuritySecureRandom *) nil_chk(random_)) nextBytesWithByteArray:seed];
  IOSByteArray *mask = LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(self, seed, 0, seed->size_, block->size_ - ((IOSByteArray *) nil_chk(defHash_))->size_);
  for (jint i = ((IOSByteArray *) nil_chk(defHash_))->size_; i != block->size_; i++) {
    *IOSByteArray_GetRef(block, i) ^= IOSByteArray_Get(nil_chk(mask), i - defHash_->size_);
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(seed, 0, block, 0, defHash_->size_);
  mask = LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(self, block, ((IOSByteArray *) nil_chk(defHash_))->size_, block->size_ - defHash_->size_, defHash_->size_);
  for (jint i = 0; i != ((IOSByteArray *) nil_chk(defHash_))->size_; i++) {
    *IOSByteArray_GetRef(block, i) ^= IOSByteArray_Get(nil_chk(mask), i);
  }
  return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:block withInt:0 withInt:block->size_];
}

- (IOSByteArray *)decodeBlockWithByteArray:(IOSByteArray *)inArg
                                   withInt:(jint)inOff
                                   withInt:(jint)inLen {
  IOSByteArray *data = [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:inArg withInt:inOff withInt:inLen];
  IOSByteArray *block = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(engine_)) getOutputBlockSize]];
  jboolean wrongData = (block->size_ < (2 * ((IOSByteArray *) nil_chk(defHash_))->size_) + 1);
  if (((IOSByteArray *) nil_chk(data))->size_ <= block->size_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, block, block->size_ - data->size_, data->size_);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, block, 0, block->size_);
    wrongData = true;
  }
  IOSByteArray *mask = LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(self, block, ((IOSByteArray *) nil_chk(defHash_))->size_, block->size_ - defHash_->size_, defHash_->size_);
  for (jint i = 0; i != ((IOSByteArray *) nil_chk(defHash_))->size_; i++) {
    *IOSByteArray_GetRef(block, i) ^= IOSByteArray_Get(nil_chk(mask), i);
  }
  mask = LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(self, block, 0, defHash_->size_, block->size_ - defHash_->size_);
  for (jint i = ((IOSByteArray *) nil_chk(defHash_))->size_; i != block->size_; i++) {
    *IOSByteArray_GetRef(block, i) ^= IOSByteArray_Get(nil_chk(mask), i - defHash_->size_);
  }
  jboolean defHashWrong = false;
  for (jint i = 0; i != defHash_->size_; i++) {
    if (IOSByteArray_Get(defHash_, i) != IOSByteArray_Get(block, defHash_->size_ + i)) {
      defHashWrong = true;
    }
  }
  jint start = block->size_;
  for (jint index = 2 * defHash_->size_; index != block->size_; index++) {
    if ((IOSByteArray_Get(block, index) != 0) & (start == block->size_)) {
      start = index;
    }
  }
  jboolean dataStartWrong = ((start > (block->size_ - 1)) | (IOSByteArray_Get(block, start) != 1));
  start++;
  if (defHashWrong | wrongData | dataStartWrong) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(block, (jbyte) 0);
    @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data wrong");
  }
  IOSByteArray *output = [IOSByteArray newArrayWithLength:block->size_ - start];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(block, start, output, 0, output->size_);
  return output;
}

- (void)ItoOSPWithInt:(jint)i
        withByteArray:(IOSByteArray *)sp {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_ItoOSPWithInt_withByteArray_(self, i, sp);
}

- (IOSByteArray *)maskGeneratorFunction1WithByteArray:(IOSByteArray *)Z
                                              withInt:(jint)zOff
                                              withInt:(jint)zLen
                                              withInt:(jint)length {
  return LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(self, Z, zOff, zLen, length);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 6, 7, 8, -1, -1, -1 },
    { NULL, "[B", 0x1, 9, 7, 8, -1, -1, -1 },
    { NULL, "[B", 0x1, 10, 7, 8, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 13, 14, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:withLibOrgBouncycastleCryptoDigest:);
  methods[2].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:withLibOrgBouncycastleCryptoDigest:withByteArray:);
  methods[3].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:withLibOrgBouncycastleCryptoDigest:withLibOrgBouncycastleCryptoDigest:withByteArray:);
  methods[4].selector = @selector(getUnderlyingCipher);
  methods[5].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[6].selector = @selector(getInputBlockSize);
  methods[7].selector = @selector(getOutputBlockSize);
  methods[8].selector = @selector(processBlockWithByteArray:withInt:withInt:);
  methods[9].selector = @selector(encodeBlockWithByteArray:withInt:withInt:);
  methods[10].selector = @selector(decodeBlockWithByteArray:withInt:withInt:);
  methods[11].selector = @selector(ItoOSPWithInt:withByteArray:);
  methods[12].selector = @selector(maskGeneratorFunction1WithByteArray:withInt:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "defHash_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mgf1Hash_", "LLibOrgBouncycastleCryptoDigest;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "random_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;LLibOrgBouncycastleCryptoDigest;", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;LLibOrgBouncycastleCryptoDigest;[B", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;LLibOrgBouncycastleCryptoDigest;LLibOrgBouncycastleCryptoDigest;[B", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "processBlock", "[BII", "LLibOrgBouncycastleCryptoInvalidCipherTextException;", "encodeBlock", "decodeBlock", "ItoOSP", "I[B", "maskGeneratorFunction1", "[BIII" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEncodingsOAEPEncoding = { "OAEPEncoding", "lib.org.bouncycastle.crypto.encodings", ptrTable, methods, fields, 7, 0x1, 13, 5, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEncodingsOAEPEncoding;
}

@end

void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(self, cipher, LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1(), nil);
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, cipher)
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *create_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, cipher)
}

void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_) {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(self, cipher, hash_, nil);
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_, cipher, hash_)
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *create_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_, cipher, hash_)
}

void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, IOSByteArray *encodingParams) {
  LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(self, cipher, hash_, hash_, encodingParams);
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, IOSByteArray *encodingParams) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_, cipher, hash_, encodingParams)
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *create_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, IOSByteArray *encodingParams) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_, cipher, hash_, encodingParams)
}

void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, id<LibOrgBouncycastleCryptoDigest> mgf1Hash, IOSByteArray *encodingParams) {
  NSObject_init(self);
  self->engine_ = cipher;
  self->mgf1Hash_ = mgf1Hash;
  self->defHash_ = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(hash_)) getDigestSize]];
  [hash_ reset];
  if (encodingParams != nil) {
    [hash_ updateWithByteArray:encodingParams withInt:0 withInt:encodingParams->size_];
  }
  [hash_ doFinalWithByteArray:self->defHash_ withInt:0];
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, id<LibOrgBouncycastleCryptoDigest> mgf1Hash, IOSByteArray *encodingParams) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_, cipher, hash_, mgf1Hash, encodingParams)
}

LibOrgBouncycastleCryptoEncodingsOAEPEncoding *create_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher, id<LibOrgBouncycastleCryptoDigest> hash_, id<LibOrgBouncycastleCryptoDigest> mgf1Hash, IOSByteArray *encodingParams) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEncodingsOAEPEncoding, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_, cipher, hash_, mgf1Hash, encodingParams)
}

void LibOrgBouncycastleCryptoEncodingsOAEPEncoding_ItoOSPWithInt_withByteArray_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, jint i, IOSByteArray *sp) {
  *IOSByteArray_GetRef(nil_chk(sp), 0) = (jbyte) (JreURShift32(i, 24));
  *IOSByteArray_GetRef(sp, 1) = (jbyte) (JreURShift32(i, 16));
  *IOSByteArray_GetRef(sp, 2) = (jbyte) (JreURShift32(i, 8));
  *IOSByteArray_GetRef(sp, 3) = (jbyte) (JreURShift32(i, 0));
}

IOSByteArray *LibOrgBouncycastleCryptoEncodingsOAEPEncoding_maskGeneratorFunction1WithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoEncodingsOAEPEncoding *self, IOSByteArray *Z, jint zOff, jint zLen, jint length) {
  IOSByteArray *mask = [IOSByteArray newArrayWithLength:length];
  IOSByteArray *hashBuf = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) getDigestSize]];
  IOSByteArray *C = [IOSByteArray newArrayWithLength:4];
  jint counter = 0;
  [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) reset];
  while (counter < (length / hashBuf->size_)) {
    LibOrgBouncycastleCryptoEncodingsOAEPEncoding_ItoOSPWithInt_withByteArray_(self, counter, C);
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) updateWithByteArray:Z withInt:zOff withInt:zLen];
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) updateWithByteArray:C withInt:0 withInt:C->size_];
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) doFinalWithByteArray:hashBuf withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(hashBuf, 0, mask, counter * hashBuf->size_, hashBuf->size_);
    counter++;
  }
  if ((counter * hashBuf->size_) < length) {
    LibOrgBouncycastleCryptoEncodingsOAEPEncoding_ItoOSPWithInt_withByteArray_(self, counter, C);
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) updateWithByteArray:Z withInt:zOff withInt:zLen];
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) updateWithByteArray:C withInt:0 withInt:C->size_];
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->mgf1Hash_)) doFinalWithByteArray:hashBuf withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(hashBuf, 0, mask, counter * hashBuf->size_, mask->size_ - (counter * hashBuf->size_));
  }
  return mask;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoEncodingsOAEPEncoding)

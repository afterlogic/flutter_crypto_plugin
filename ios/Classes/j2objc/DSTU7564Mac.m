//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/macs/DSTU7564Mac.java
//

#include "CipherParameters.h"
#include "DSTU7564Digest.h"
#include "DSTU7564Mac.h"
#include "DataLengthException.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "Pack.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoMacsDSTU7564Mac () {
 @public
  LibOrgBouncycastleCryptoDigestsDSTU7564Digest *engine_;
  jint macSize_;
  IOSByteArray *paddedKey_;
  IOSByteArray *invertedKey_;
  jlong inputLength_;
}

- (void)pad;

- (IOSByteArray *)padKeyWithByteArray:(IOSByteArray *)inArg;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsDSTU7564Mac, engine_, LibOrgBouncycastleCryptoDigestsDSTU7564Digest *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsDSTU7564Mac, paddedKey_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsDSTU7564Mac, invertedKey_, IOSByteArray *)

inline jint LibOrgBouncycastleCryptoMacsDSTU7564Mac_get_BITS_IN_BYTE(void);
#define LibOrgBouncycastleCryptoMacsDSTU7564Mac_BITS_IN_BYTE 8
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoMacsDSTU7564Mac, BITS_IN_BYTE, jint)

__attribute__((unused)) static void LibOrgBouncycastleCryptoMacsDSTU7564Mac_pad(LibOrgBouncycastleCryptoMacsDSTU7564Mac *self);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoMacsDSTU7564Mac_padKeyWithByteArray_(LibOrgBouncycastleCryptoMacsDSTU7564Mac *self, IOSByteArray *inArg);

@implementation LibOrgBouncycastleCryptoMacsDSTU7564Mac

- (instancetype)initWithInt:(jint)macBitSize {
  LibOrgBouncycastleCryptoMacsDSTU7564Mac_initWithInt_(self, macBitSize);
  return self;
}

- (void)init__WithLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsKeyParameter class]]) {
    IOSByteArray *key = [((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(((LibOrgBouncycastleCryptoParamsKeyParameter *) params))) getKey];
    invertedKey_ = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(key))->size_];
    paddedKey_ = LibOrgBouncycastleCryptoMacsDSTU7564Mac_padKeyWithByteArray_(self, key);
    for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(invertedKey_))->size_; byteIndex++) {
      *IOSByteArray_GetRef(invertedKey_, byteIndex) = (jbyte) (IOSByteArray_Get(key, byteIndex) ^ (jbyte) (jint) 0xFF);
    }
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Bad parameter passed");
  }
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) updateWithByteArray:paddedKey_ withInt:0 withInt:((IOSByteArray *) nil_chk(paddedKey_))->size_];
}

- (NSString *)getAlgorithmName {
  return @"DSTU7564Mac";
}

- (jint)getMacSize {
  return macSize_;
}

- (void)updateWithByte:(jbyte)inArg {
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) updateWithByte:inArg];
  inputLength_++;
}

- (void)updateWithByteArray:(IOSByteArray *)inArg
                    withInt:(jint)inOff
                    withInt:(jint)len {
  if (((IOSByteArray *) nil_chk(inArg))->size_ - inOff < len) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  if (paddedKey_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" not initialised"));
  }
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) updateWithByteArray:inArg withInt:inOff withInt:len];
  inputLength_ += len;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  if (paddedKey_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" not initialised"));
  }
  if (((IOSByteArray *) nil_chk(outArg))->size_ - outOff < macSize_) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
  }
  LibOrgBouncycastleCryptoMacsDSTU7564Mac_pad(self);
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) updateWithByteArray:invertedKey_ withInt:0 withInt:((IOSByteArray *) nil_chk(invertedKey_))->size_];
  inputLength_ = 0;
  return [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) doFinalWithByteArray:outArg withInt:outOff];
}

- (void)reset {
  inputLength_ = 0;
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) reset];
  if (paddedKey_ != nil) {
    [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(engine_)) updateWithByteArray:paddedKey_ withInt:0 withInt:paddedKey_->size_];
  }
}

- (void)pad {
  LibOrgBouncycastleCryptoMacsDSTU7564Mac_pad(self);
}

- (IOSByteArray *)padKeyWithByteArray:(IOSByteArray *)inArg {
  return LibOrgBouncycastleCryptoMacsDSTU7564Mac_padKeyWithByteArray_(self, inArg);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 7, 8, -1, -1, -1 },
    { NULL, "I", 0x1, 9, 10, 8, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 11, 12, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithInt:);
  methods[1].selector = @selector(init__WithLibOrgBouncycastleCryptoCipherParameters:);
  methods[2].selector = @selector(getAlgorithmName);
  methods[3].selector = @selector(getMacSize);
  methods[4].selector = @selector(updateWithByte:);
  methods[5].selector = @selector(updateWithByteArray:withInt:withInt:);
  methods[6].selector = @selector(doFinalWithByteArray:withInt:);
  methods[7].selector = @selector(reset);
  methods[8].selector = @selector(pad);
  methods[9].selector = @selector(padKeyWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BITS_IN_BYTE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoMacsDSTU7564Mac_BITS_IN_BYTE, 0x1a, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoDigestsDSTU7564Digest;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "paddedKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "invertedKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "inputLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "I", "init", "LLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "update", "B", "LJavaLangIllegalStateException;", "[BII", "LLibOrgBouncycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "doFinal", "[BI", "padKey", "[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoMacsDSTU7564Mac = { "DSTU7564Mac", "lib.org.bouncycastle.crypto.macs", ptrTable, methods, fields, 7, 0x1, 10, 6, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoMacsDSTU7564Mac;
}

@end

void LibOrgBouncycastleCryptoMacsDSTU7564Mac_initWithInt_(LibOrgBouncycastleCryptoMacsDSTU7564Mac *self, jint macBitSize) {
  NSObject_init(self);
  self->engine_ = new_LibOrgBouncycastleCryptoDigestsDSTU7564Digest_initWithInt_(macBitSize);
  self->macSize_ = macBitSize / LibOrgBouncycastleCryptoMacsDSTU7564Mac_BITS_IN_BYTE;
  self->paddedKey_ = nil;
  self->invertedKey_ = nil;
}

LibOrgBouncycastleCryptoMacsDSTU7564Mac *new_LibOrgBouncycastleCryptoMacsDSTU7564Mac_initWithInt_(jint macBitSize) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoMacsDSTU7564Mac, initWithInt_, macBitSize)
}

LibOrgBouncycastleCryptoMacsDSTU7564Mac *create_LibOrgBouncycastleCryptoMacsDSTU7564Mac_initWithInt_(jint macBitSize) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoMacsDSTU7564Mac, initWithInt_, macBitSize)
}

void LibOrgBouncycastleCryptoMacsDSTU7564Mac_pad(LibOrgBouncycastleCryptoMacsDSTU7564Mac *self) {
  jint extra = [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength] - (jint) (self->inputLength_ % [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength]);
  if (extra < 13) {
    extra += [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength];
  }
  IOSByteArray *padded = [IOSByteArray newArrayWithLength:extra];
  *IOSByteArray_GetRef(padded, 0) = (jbyte) (jint) 0x80;
  LibOrgBouncycastleUtilPack_longToLittleEndianWithLong_withByteArray_withInt_(self->inputLength_ * LibOrgBouncycastleCryptoMacsDSTU7564Mac_BITS_IN_BYTE, padded, padded->size_ - 12);
  [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) updateWithByteArray:padded withInt:0 withInt:padded->size_];
}

IOSByteArray *LibOrgBouncycastleCryptoMacsDSTU7564Mac_padKeyWithByteArray_(LibOrgBouncycastleCryptoMacsDSTU7564Mac *self, IOSByteArray *inArg) {
  jint paddedLen = ((((IOSByteArray *) nil_chk(inArg))->size_ + [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength] - 1) / [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength]) * [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength];
  jint extra = [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength] - (jint) (inArg->size_ % [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength]);
  if (extra < 13) {
    paddedLen += [((LibOrgBouncycastleCryptoDigestsDSTU7564Digest *) nil_chk(self->engine_)) getByteLength];
  }
  IOSByteArray *padded = [IOSByteArray newArrayWithLength:paddedLen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, 0, padded, 0, inArg->size_);
  *IOSByteArray_GetRef(padded, inArg->size_) = (jbyte) (jint) 0x80;
  LibOrgBouncycastleUtilPack_intToLittleEndianWithInt_withByteArray_withInt_(inArg->size_ * LibOrgBouncycastleCryptoMacsDSTU7564Mac_BITS_IN_BYTE, padded, padded->size_ - 12);
  return padded;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoMacsDSTU7564Mac)

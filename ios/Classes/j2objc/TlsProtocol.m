//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/TlsProtocol.java
//

#include "AbstractTlsContext.h"
#include "AlertDescription.h"
#include "AlertLevel.h"
#include "Arrays.h"
#include "ByteQueue.h"
#include "ByteQueueInputStream.h"
#include "ByteQueueOutputStream.h"
#include "Certificate.h"
#include "ChangeCipherSpec.h"
#include "CipherSuite.h"
#include "ContentType.h"
#include "Digest.h"
#include "ExporterLabel.h"
#include "ExtensionType.h"
#include "HandshakeType.h"
#include "IOSPrimitiveArray.h"
#include "Integers.h"
#include "J2ObjC_source.h"
#include "MaxFragmentLength.h"
#include "PRFAlgorithm.h"
#include "ProtocolVersion.h"
#include "RandomGenerator.h"
#include "RecordStream.h"
#include "SecurityParameters.h"
#include "SessionParameters.h"
#include "SupplementalDataEntry.h"
#include "TlsContext.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsFatalAlertReceived.h"
#include "TlsHandshakeHash.h"
#include "TlsInputStream.h"
#include "TlsKeyExchange.h"
#include "TlsNoCloseNotifyException.h"
#include "TlsOutputStream.h"
#include "TlsPeer.h"
#include "TlsProtocol.h"
#include "TlsSession.h"
#include "TlsSessionImpl.h"
#include "TlsUtils.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/security/SecureRandom.h"
#include "java/util/Enumeration.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@interface LibOrgBouncycastleCryptoTlsTlsProtocol () {
 @public
  LibOrgBouncycastleCryptoTlsByteQueue *applicationDataQueue_;
  LibOrgBouncycastleCryptoTlsByteQueue *alertQueue_;
  LibOrgBouncycastleCryptoTlsByteQueue *handshakeQueue_;
  LibOrgBouncycastleCryptoTlsTlsInputStream *tlsInputStream_;
  LibOrgBouncycastleCryptoTlsTlsOutputStream *tlsOutputStream_;
  volatile_jboolean closed_;
  volatile_jboolean failedWithError_;
  volatile_jboolean appDataReady_;
  volatile_jboolean appDataSplitEnabled_;
  volatile_jint appDataSplitMode_;
  IOSByteArray *expected_verify_data_;
}

- (void)processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue:(LibOrgBouncycastleCryptoTlsByteQueue *)queue;

- (void)processApplicationDataQueue;

- (void)processAlertQueue;

- (void)processChangeCipherSpecWithByteArray:(IOSByteArray *)buf
                                     withInt:(jint)off
                                     withInt:(jint)len;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, applicationDataQueue_, LibOrgBouncycastleCryptoTlsByteQueue *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, alertQueue_, LibOrgBouncycastleCryptoTlsByteQueue *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, handshakeQueue_, LibOrgBouncycastleCryptoTlsByteQueue *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, tlsInputStream_, LibOrgBouncycastleCryptoTlsTlsInputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, tlsOutputStream_, LibOrgBouncycastleCryptoTlsTlsOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsTlsProtocol, expected_verify_data_, IOSByteArray *)

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsTlsProtocol_processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, LibOrgBouncycastleCryptoTlsByteQueue *queue);

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsTlsProtocol_processApplicationDataQueue(LibOrgBouncycastleCryptoTlsTlsProtocol *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsTlsProtocol_processAlertQueue(LibOrgBouncycastleCryptoTlsTlsProtocol *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsTlsProtocol_processChangeCipherSpecWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, IOSByteArray *buf, jint off, jint len);

@interface LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage () {
 @public
  LibOrgBouncycastleCryptoTlsTlsProtocol *this$0_;
}

@end

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoTlsTlsProtocol)

JavaLangInteger *LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_RenegotiationInfo;
JavaLangInteger *LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_SessionTicket;

@implementation LibOrgBouncycastleCryptoTlsTlsProtocol

+ (JavaLangInteger *)EXT_RenegotiationInfo {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_RenegotiationInfo;
}

+ (JavaLangInteger *)EXT_SessionTicket {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_SessionTicket;
}

+ (jshort)CS_START {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_START;
}

+ (jshort)CS_CLIENT_HELLO {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO;
}

+ (jshort)CS_SERVER_HELLO {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO;
}

+ (jshort)CS_SERVER_SUPPLEMENTAL_DATA {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA;
}

+ (jshort)CS_SERVER_CERTIFICATE {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE;
}

+ (jshort)CS_CERTIFICATE_STATUS {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS;
}

+ (jshort)CS_SERVER_KEY_EXCHANGE {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE;
}

+ (jshort)CS_CERTIFICATE_REQUEST {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST;
}

+ (jshort)CS_SERVER_HELLO_DONE {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE;
}

+ (jshort)CS_CLIENT_SUPPLEMENTAL_DATA {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA;
}

+ (jshort)CS_CLIENT_CERTIFICATE {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE;
}

+ (jshort)CS_CLIENT_KEY_EXCHANGE {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE;
}

+ (jshort)CS_CERTIFICATE_VERIFY {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY;
}

+ (jshort)CS_CLIENT_FINISHED {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
}

+ (jshort)CS_SERVER_SESSION_TICKET {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET;
}

+ (jshort)CS_SERVER_FINISHED {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
}

+ (jshort)CS_END {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END;
}

+ (jshort)ADS_MODE_1_Nsub1 {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1;
}

+ (jshort)ADS_MODE_0_N {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N;
}

+ (jshort)ADS_MODE_0_N_FIRSTONLY {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N_FIRSTONLY;
}

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)input
                   withJavaIoOutputStream:(JavaIoOutputStream *)output
             withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  return self;
}

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (id<LibOrgBouncycastleCryptoTlsTlsContext>)getContext {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (LibOrgBouncycastleCryptoTlsAbstractTlsContext *)getContextAdmin {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<LibOrgBouncycastleCryptoTlsTlsPeer>)getPeer {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)handleAlertMessageWithShort:(jshort)alertLevel
                          withShort:(jshort)alertDescription {
  [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) notifyAlertReceivedWithShort:alertLevel withShort:alertDescription];
  if (alertLevel == LibOrgBouncycastleCryptoTlsAlertLevel_warning) {
    [self handleAlertWarningMessageWithShort:alertDescription];
  }
  else {
    [self handleFailure];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlertReceived_initWithShort_(alertDescription);
  }
}

- (void)handleAlertWarningMessageWithShort:(jshort)alertDescription {
  if (alertDescription == LibOrgBouncycastleCryptoTlsAlertDescription_close_notify) {
    if (!JreLoadVolatileBoolean(&appDataReady_)) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
    }
    [self handleCloseWithBoolean:false];
  }
}

- (void)handleChangeCipherSpecMessage {
}

- (void)handleCloseWithBoolean:(jboolean)user_canceled {
  if (!JreLoadVolatileBoolean(&closed_)) {
    JreAssignVolatileBoolean(&self->closed_, true);
    if (user_canceled && !JreLoadVolatileBoolean(&appDataReady_)) {
      [self raiseAlertWarningWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_user_canceled withNSString:@"User canceled handshake"];
    }
    [self raiseAlertWarningWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_close_notify withNSString:@"Connection closed"];
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) safeClose];
    if (!JreLoadVolatileBoolean(&appDataReady_)) {
      [self cleanupHandshake];
    }
  }
}

- (void)handleExceptionWithShort:(jshort)alertDescription
                    withNSString:(NSString *)message
           withJavaLangThrowable:(JavaLangThrowable *)cause {
  if (!JreLoadVolatileBoolean(&closed_)) {
    [self raiseAlertFatalWithShort:alertDescription withNSString:message withJavaLangThrowable:cause];
    [self handleFailure];
  }
}

- (void)handleFailure {
  JreAssignVolatileBoolean(&self->closed_, true);
  JreAssignVolatileBoolean(&self->failedWithError_, true);
  [self invalidateSession];
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) safeClose];
  if (!JreLoadVolatileBoolean(&appDataReady_)) {
    [self cleanupHandshake];
  }
}

- (void)handleHandshakeMessageWithShort:(jshort)type
         withJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)applyMaxFragmentLengthExtension {
  if (((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->maxFragmentLength_ >= 0) {
    if (!LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(securityParameters_->maxFragmentLength_)) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
    }
    jint plainTextLimit = JreLShift32(1, (8 + ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->maxFragmentLength_));
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setPlaintextLimitWithInt:plainTextLimit];
  }
}

- (void)checkReceivedChangeCipherSpecWithBoolean:(jboolean)expected {
  if (expected != receivedChangeCipherSpec_) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
}

- (void)cleanupHandshake {
  if (self->expected_verify_data_ != nil) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->expected_verify_data_, (jbyte) 0);
    self->expected_verify_data_ = nil;
  }
  [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) clear];
  self->peerCertificate_ = nil;
  self->offeredCipherSuites_ = nil;
  self->offeredCompressionMethods_ = nil;
  self->clientExtensions_ = nil;
  self->serverExtensions_ = nil;
  self->resumedSession_ = false;
  self->receivedChangeCipherSpec_ = false;
  self->secure_renegotiation_ = false;
  self->allowCertificateStatus_ = false;
  self->expectSessionTicket_ = false;
}

- (void)blockForHandshake {
  if (blocking_) {
    while (self->connection_state_ != LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END) {
      if (JreLoadVolatileBoolean(&self->closed_)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
      }
      [self safeReadRecord];
    }
  }
}

- (void)completeHandshake {
  @try {
    self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END;
    [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->alertQueue_)) shrink];
    [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->handshakeQueue_)) shrink];
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) finaliseHandshake];
    JreAssignVolatileBoolean(&self->appDataSplitEnabled_, !LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv11WithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext]));
    if (!JreLoadVolatileBoolean(&appDataReady_)) {
      JreAssignVolatileBoolean(&self->appDataReady_, true);
      if (blocking_) {
        self->tlsInputStream_ = new_LibOrgBouncycastleCryptoTlsTlsInputStream_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_(self);
        self->tlsOutputStream_ = new_LibOrgBouncycastleCryptoTlsTlsOutputStream_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_(self);
      }
    }
    if (self->tlsSession_ != nil) {
      if (self->sessionParameters_ == nil) {
        self->sessionParameters_ = [((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([new_LibOrgBouncycastleCryptoTlsSessionParameters_Builder_init() setCipherSuiteWithInt:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getCipherSuite]])) setCompressionAlgorithmWithShort:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getCompressionAlgorithm]])) setExtendedMasterSecretWithBoolean:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) isExtendedMasterSecret]])) setMasterSecretWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getMasterSecret]])) setPeerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:self->peerCertificate_])) setPSKIdentityWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getPSKIdentity]])) setSRPIdentityWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getSRPIdentity]])) setServerExtensionsWithJavaUtilHashtable:self->serverExtensions_])) build];
        self->tlsSession_ = new_LibOrgBouncycastleCryptoTlsTlsSessionImpl_initWithByteArray_withLibOrgBouncycastleCryptoTlsSessionParameters_([((id<LibOrgBouncycastleCryptoTlsTlsSession>) nil_chk(self->tlsSession_)) getSessionID], self->sessionParameters_);
      }
      [((LibOrgBouncycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setResumableSessionWithLibOrgBouncycastleCryptoTlsTlsSession:self->tlsSession_];
    }
    [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) notifyHandshakeComplete];
  }
  @finally {
    [self cleanupHandshake];
  }
}

- (void)processRecordWithShort:(jshort)protocol
                 withByteArray:(IOSByteArray *)buf
                       withInt:(jint)off
                       withInt:(jint)len {
  switch (protocol) {
    case LibOrgBouncycastleCryptoTlsContentType_alert:
    {
      [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(alertQueue_)) addDataWithByteArray:buf withInt:off withInt:len];
      LibOrgBouncycastleCryptoTlsTlsProtocol_processAlertQueue(self);
      break;
    }
    case LibOrgBouncycastleCryptoTlsContentType_application_data:
    {
      if (!JreLoadVolatileBoolean(&appDataReady_)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(applicationDataQueue_)) addDataWithByteArray:buf withInt:off withInt:len];
      LibOrgBouncycastleCryptoTlsTlsProtocol_processApplicationDataQueue(self);
      break;
    }
    case LibOrgBouncycastleCryptoTlsContentType_change_cipher_spec:
    {
      LibOrgBouncycastleCryptoTlsTlsProtocol_processChangeCipherSpecWithByteArray_withInt_withInt_(self, buf, off, len);
      break;
    }
    case LibOrgBouncycastleCryptoTlsContentType_handshake:
    {
      if ([((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(handshakeQueue_)) available] > 0) {
        [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(handshakeQueue_)) addDataWithByteArray:buf withInt:off withInt:len];
        LibOrgBouncycastleCryptoTlsTlsProtocol_processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue_(self, handshakeQueue_);
      }
      else {
        LibOrgBouncycastleCryptoTlsByteQueue *tmpQueue = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithByteArray_withInt_withInt_(buf, off, len);
        LibOrgBouncycastleCryptoTlsTlsProtocol_processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue_(self, tmpQueue);
        jint remaining = [tmpQueue available];
        if (remaining > 0) {
          [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(handshakeQueue_)) addDataWithByteArray:buf withInt:off + len - remaining withInt:remaining];
        }
      }
      break;
    }
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
}

- (void)processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue:(LibOrgBouncycastleCryptoTlsByteQueue *)queue {
  LibOrgBouncycastleCryptoTlsTlsProtocol_processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue_(self, queue);
}

- (void)processApplicationDataQueue {
  LibOrgBouncycastleCryptoTlsTlsProtocol_processApplicationDataQueue(self);
}

- (void)processAlertQueue {
  LibOrgBouncycastleCryptoTlsTlsProtocol_processAlertQueue(self);
}

- (void)processChangeCipherSpecWithByteArray:(IOSByteArray *)buf
                                     withInt:(jint)off
                                     withInt:(jint)len {
  LibOrgBouncycastleCryptoTlsTlsProtocol_processChangeCipherSpecWithByteArray_withInt_withInt_(self, buf, off, len);
}

- (jint)applicationDataAvailable {
  return [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(applicationDataQueue_)) available];
}

- (jint)readApplicationDataWithByteArray:(IOSByteArray *)buf
                                 withInt:(jint)offset
                                 withInt:(jint)len {
  if (len < 1) {
    return 0;
  }
  while ([((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(applicationDataQueue_)) available] == 0) {
    if (JreLoadVolatileBoolean(&self->closed_)) {
      if (JreLoadVolatileBoolean(&self->failedWithError_)) {
        @throw new_JavaIoIOException_initWithNSString_(@"Cannot read application data on failed TLS connection");
      }
      if (!JreLoadVolatileBoolean(&appDataReady_)) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot read application data until initial handshake completed.");
      }
      return -1;
    }
    [self safeReadRecord];
  }
  len = JavaLangMath_minWithInt_withInt_(len, [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(applicationDataQueue_)) available]);
  [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(applicationDataQueue_)) removeDataWithByteArray:buf withInt:offset withInt:len withInt:0];
  return len;
}

- (void)safeCheckRecordHeaderWithByteArray:(IOSByteArray *)recordHeader {
  @try {
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) checkRecordHeaderWithByteArray:recordHeader];
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *e) {
    [self handleExceptionWithShort:[e getAlertDescription] withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaIoIOException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaLangRuntimeException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
}

- (void)safeReadRecord {
  @try {
    if ([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) readRecord]) {
      return;
    }
    if (!JreLoadVolatileBoolean(&appDataReady_)) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
    }
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlertReceived *e) {
    @throw e;
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *e) {
    [self handleExceptionWithShort:[e getAlertDescription] withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaIoIOException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaLangRuntimeException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to read record" withJavaLangThrowable:e];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
  [self handleFailure];
  @throw new_LibOrgBouncycastleCryptoTlsTlsNoCloseNotifyException_init();
}

- (void)safeWriteRecordWithShort:(jshort)type
                   withByteArray:(IOSByteArray *)buf
                         withInt:(jint)offset
                         withInt:(jint)len {
  @try {
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) writeRecordWithShort:type withByteArray:buf withInt:offset withInt:len];
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *e) {
    [self handleExceptionWithShort:[e getAlertDescription] withNSString:@"Failed to write record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaIoIOException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to write record" withJavaLangThrowable:e];
    @throw e;
  }
  @catch (JavaLangRuntimeException *e) {
    [self handleExceptionWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error withNSString:@"Failed to write record" withJavaLangThrowable:e];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
}

- (void)writeDataWithByteArray:(IOSByteArray *)buf
                       withInt:(jint)offset
                       withInt:(jint)len {
  if (JreLoadVolatileBoolean(&self->closed_)) {
    @throw new_JavaIoIOException_initWithNSString_(@"Cannot write application data on closed/failed TLS connection");
  }
  while (len > 0) {
    if (JreLoadVolatileBoolean(&self->appDataSplitEnabled_)) {
      switch (JreLoadVolatileInt(&appDataSplitMode_)) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N_FIRSTONLY:
        JreAssignVolatileBoolean(&self->appDataSplitEnabled_, false);
        case LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N:
        [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_application_data withByteArray:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES) withInt:0 withInt:0];
        break;
        case LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1:
        default:
        [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_application_data withByteArray:buf withInt:offset withInt:1];
        ++offset;
        --len;
        break;
      }
    }
    if (len > 0) {
      jint toWrite = JavaLangMath_minWithInt_withInt_(len, [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) getPlaintextLimit]);
      [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_application_data withByteArray:buf withInt:offset withInt:toWrite];
      offset += toWrite;
      len -= toWrite;
    }
  }
}

- (void)setAppDataSplitModeWithInt:(jint)appDataSplitMode {
  if (appDataSplitMode < LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1 || appDataSplitMode > LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N_FIRSTONLY) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Illegal appDataSplitMode mode: ", appDataSplitMode));
  }
  JreAssignVolatileInt(&self->appDataSplitMode_, appDataSplitMode);
}

- (void)writeHandshakeMessageWithByteArray:(IOSByteArray *)buf
                                   withInt:(jint)off
                                   withInt:(jint)len {
  if (len < 4) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  jshort type = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(buf, off);
  if (type != LibOrgBouncycastleCryptoTlsHandshakeType_hello_request) {
    [((JavaIoOutputStream *) nil_chk([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) getHandshakeHashUpdater])) writeWithByteArray:buf withInt:off withInt:len];
  }
  jint total = 0;
  do {
    jint toWrite = JavaLangMath_minWithInt_withInt_(len - total, [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) getPlaintextLimit]);
    [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_handshake withByteArray:buf withInt:off + total withInt:toWrite];
    total += toWrite;
  }
  while (total < len);
}

- (JavaIoOutputStream *)getOutputStream {
  if (!blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use OutputStream in non-blocking mode! Use offerOutput() instead.");
  }
  return self->tlsOutputStream_;
}

- (JavaIoInputStream *)getInputStream {
  if (!blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use InputStream in non-blocking mode! Use offerInput() instead.");
  }
  return self->tlsInputStream_;
}

- (void)closeInput {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use closeInput() in blocking mode!");
  }
  if (JreLoadVolatileBoolean(&closed_)) {
    return;
  }
  if ([((LibOrgBouncycastleCryptoTlsByteQueueInputStream *) nil_chk(inputBuffers_)) available] > 0) {
    @throw new_JavaIoEOFException_init();
  }
  if (!JreLoadVolatileBoolean(&appDataReady_)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  @throw new_LibOrgBouncycastleCryptoTlsTlsNoCloseNotifyException_init();
}

- (void)offerInputWithByteArray:(IOSByteArray *)input {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use offerInput() in blocking mode! Use getInputStream() instead.");
  }
  if (JreLoadVolatileBoolean(&closed_)) {
    @throw new_JavaIoIOException_initWithNSString_(@"Connection is closed, cannot accept any more input");
  }
  [((LibOrgBouncycastleCryptoTlsByteQueueInputStream *) nil_chk(inputBuffers_)) addBytesWithByteArray:input];
  while ([((LibOrgBouncycastleCryptoTlsByteQueueInputStream *) nil_chk(inputBuffers_)) available] >= LibOrgBouncycastleCryptoTlsRecordStream_TLS_HEADER_SIZE) {
    IOSByteArray *recordHeader = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoTlsRecordStream_TLS_HEADER_SIZE];
    [((LibOrgBouncycastleCryptoTlsByteQueueInputStream *) nil_chk(inputBuffers_)) peekWithByteArray:recordHeader];
    jint totalLength = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithByteArray_withInt_(recordHeader, LibOrgBouncycastleCryptoTlsRecordStream_TLS_HEADER_LENGTH_OFFSET) + LibOrgBouncycastleCryptoTlsRecordStream_TLS_HEADER_SIZE;
    if ([((LibOrgBouncycastleCryptoTlsByteQueueInputStream *) nil_chk(inputBuffers_)) available] < totalLength) {
      [self safeCheckRecordHeaderWithByteArray:recordHeader];
      break;
    }
    [self safeReadRecord];
    if (JreLoadVolatileBoolean(&closed_)) {
      if (connection_state_ != LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
      }
      break;
    }
  }
}

- (jint)getAvailableInputBytes {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use getAvailableInputBytes() in blocking mode! Use getInputStream().available() instead.");
  }
  return [self applicationDataAvailable];
}

- (jint)readInputWithByteArray:(IOSByteArray *)buffer
                       withInt:(jint)offset
                       withInt:(jint)length {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use readInput() in blocking mode! Use getInputStream() instead.");
  }
  @try {
    return [self readApplicationDataWithByteArray:buffer withInt:offset withInt:JavaLangMath_minWithInt_withInt_(length, [self applicationDataAvailable])];
  }
  @catch (JavaIoIOException *e) {
    @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
  }
}

- (void)offerOutputWithByteArray:(IOSByteArray *)buffer
                         withInt:(jint)offset
                         withInt:(jint)length {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use offerOutput() in blocking mode! Use getOutputStream() instead.");
  }
  if (!JreLoadVolatileBoolean(&appDataReady_)) {
    @throw new_JavaIoIOException_initWithNSString_(@"Application data cannot be sent until the handshake is complete!");
  }
  [self writeDataWithByteArray:buffer withInt:offset withInt:length];
}

- (jint)getAvailableOutputBytes {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use getAvailableOutputBytes() in blocking mode! Use getOutputStream() instead.");
  }
  return [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk([((LibOrgBouncycastleCryptoTlsByteQueueOutputStream *) nil_chk(outputBuffer_)) getBuffer])) available];
}

- (jint)readOutputWithByteArray:(IOSByteArray *)buffer
                        withInt:(jint)offset
                        withInt:(jint)length {
  if (blocking_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot use readOutput() in blocking mode! Use getOutputStream() instead.");
  }
  jint bytesToRead = JavaLangMath_minWithInt_withInt_([self getAvailableOutputBytes], length);
  [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk([((LibOrgBouncycastleCryptoTlsByteQueueOutputStream *) nil_chk(outputBuffer_)) getBuffer])) removeDataWithByteArray:buffer withInt:offset withInt:bytesToRead withInt:0];
  return bytesToRead;
}

- (void)invalidateSession {
  if (self->sessionParameters_ != nil) {
    [self->sessionParameters_ clear];
    self->sessionParameters_ = nil;
  }
  if (self->tlsSession_ != nil) {
    [self->tlsSession_ invalidate];
    self->tlsSession_ = nil;
  }
}

- (void)processFinishedMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  if (expected_verify_data_ == nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  IOSByteArray *verify_data = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(expected_verify_data_->size_, buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(expected_verify_data_, verify_data)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decrypt_error);
  }
}

- (void)raiseAlertFatalWithShort:(jshort)alertDescription
                    withNSString:(NSString *)message
           withJavaLangThrowable:(JavaLangThrowable *)cause {
  [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) notifyAlertRaisedWithShort:LibOrgBouncycastleCryptoTlsAlertLevel_fatal withShort:alertDescription withNSString:message withJavaLangThrowable:cause];
  IOSByteArray *alert = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) LibOrgBouncycastleCryptoTlsAlertLevel_fatal, (jbyte) alertDescription } count:2];
  @try {
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) writeRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_alert withByteArray:alert withInt:0 withInt:2];
  }
  @catch (JavaLangException *e) {
  }
}

- (void)raiseAlertWarningWithShort:(jshort)alertDescription
                      withNSString:(NSString *)message {
  [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) notifyAlertRaisedWithShort:LibOrgBouncycastleCryptoTlsAlertLevel_warning withShort:alertDescription withNSString:message withJavaLangThrowable:nil];
  IOSByteArray *alert = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) LibOrgBouncycastleCryptoTlsAlertLevel_warning, (jbyte) alertDescription } count:2];
  [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_alert withByteArray:alert withInt:0 withInt:2];
}

- (void)sendCertificateMessageWithLibOrgBouncycastleCryptoTlsCertificate:(LibOrgBouncycastleCryptoTlsCertificate *)certificate {
  if (certificate == nil) {
    certificate = JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN);
  }
  if ([((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(certificate)) isEmpty]) {
    id<LibOrgBouncycastleCryptoTlsTlsContext> context = [self getContext];
    if (![((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context)) isServer]) {
      LibOrgBouncycastleCryptoTlsProtocolVersion *serverVersion = [((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getServerVersion];
      if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(serverVersion)) isSSL]) {
        NSString *errorMessage = JreStrcat("$$", [serverVersion description], @" client didn't provide credentials");
        [self raiseAlertWarningWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_no_certificate withNSString:errorMessage];
        return;
      }
    }
  }
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_certificate);
  [certificate encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendChangeCipherSpecMessage {
  IOSByteArray *message = [IOSByteArray newArrayWithBytes:(jbyte[]){ 1 } count:1];
  [self safeWriteRecordWithShort:LibOrgBouncycastleCryptoTlsContentType_change_cipher_spec withByteArray:message withInt:0 withInt:message->size_];
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) sentWriteCipherSpec];
}

- (void)sendFinishedMessage {
  IOSByteArray *verify_data = [self createVerifyDataWithBoolean:[((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) isServer]];
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(self, LibOrgBouncycastleCryptoTlsHandshakeType_finished, ((IOSByteArray *) nil_chk(verify_data))->size_);
  [message writeWithByteArray:verify_data];
  [message writeToRecordStream];
}

- (void)sendSupplementalDataMessageWithJavaUtilVector:(JavaUtilVector *)supplementalData {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data);
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSupplementalDataWithJavaIoOutputStream_withJavaUtilVector_(message, supplementalData);
  [message writeToRecordStream];
}

- (IOSByteArray *)createVerifyDataWithBoolean:(jboolean)isServer {
  id<LibOrgBouncycastleCryptoTlsTlsContext> context = [self getContext];
  NSString *asciiLabel = isServer ? LibOrgBouncycastleCryptoTlsExporterLabel_server_finished : LibOrgBouncycastleCryptoTlsExporterLabel_client_finished;
  IOSByteArray *sslSender = isServer ? JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, SSL_SERVER) : JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, SSL_CLIENT);
  IOSByteArray *hash_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(context, [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) getHandshakeHash], sslSender);
  return LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(context, asciiLabel, hash_);
}

- (void)close {
  [self handleCloseWithBoolean:true];
}

- (void)flush {
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) flush];
}

- (jboolean)isClosed {
  return JreLoadVolatileBoolean(&closed_);
}

- (jshort)processMaxFragmentLengthExtensionWithJavaUtilHashtable:(JavaUtilHashtable *)clientExtensions
                                           withJavaUtilHashtable:(JavaUtilHashtable *)serverExtensions
                                                       withShort:(jshort)alertDescription {
  jshort maxFragmentLength = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getMaxFragmentLengthExtensionWithJavaUtilHashtable_(serverExtensions);
  if (maxFragmentLength >= 0) {
    if (!LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(maxFragmentLength) || (!self->resumedSession_ && maxFragmentLength != LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getMaxFragmentLengthExtensionWithJavaUtilHashtable_(clientExtensions))) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(alertDescription);
    }
  }
  return maxFragmentLength;
}

- (void)refuseRenegotiation {
  if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  [self raiseAlertWarningWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_no_renegotiation withNSString:@"Renegotiation not supported"];
}

+ (void)assertEmptyWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
}

+ (IOSByteArray *)createRandomBlockWithBoolean:(jboolean)useGMTUnixTime
withLibOrgBouncycastleCryptoPrngRandomGenerator:(id<LibOrgBouncycastleCryptoPrngRandomGenerator>)randomGenerator {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_(useGMTUnixTime, randomGenerator);
}

+ (IOSByteArray *)createRenegotiationInfoWithByteArray:(IOSByteArray *)renegotiated_connection {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(renegotiated_connection);
}

+ (void)establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
                         withLibOrgBouncycastleCryptoTlsTlsKeyExchange:(id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>)keyExchange {
  LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_(context, keyExchange);
}

+ (IOSByteArray *)getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
                             withLibOrgBouncycastleCryptoTlsTlsHandshakeHash:(id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>)handshakeHash
                                                               withByteArray:(IOSByteArray *)sslSender {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(context, handshakeHash, sslSender);
}

+ (JavaUtilHashtable *)readExtensionsWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)input {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(input);
}

+ (JavaUtilVector *)readSupplementalDataMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)input {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(input);
}

+ (void)writeExtensionsWithJavaIoOutputStream:(JavaIoOutputStream *)output
                        withJavaUtilHashtable:(JavaUtilHashtable *)extensions {
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(output, extensions);
}

+ (void)writeSelectedExtensionsWithJavaIoOutputStream:(JavaIoOutputStream *)output
                                withJavaUtilHashtable:(JavaUtilHashtable *)extensions
                                          withBoolean:(jboolean)selectEmpty {
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSelectedExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_withBoolean_(output, extensions, selectEmpty);
}

+ (void)writeSupplementalDataWithJavaIoOutputStream:(JavaIoOutputStream *)output
                                 withJavaUtilVector:(JavaUtilVector *)supplementalData {
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSupplementalDataWithJavaIoOutputStream_withJavaUtilVector_(output, supplementalData);
}

+ (jint)getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
                                                         withInt:(jint)ciphersuite {
  return LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(context, ciphersuite);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsContext;", 0x404, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsAbstractTlsContext;", 0x400, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsPeer;", 0x404, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 2, 3, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 6, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 7, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x404, 11, 12, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 14, 15, 4, -1, -1, -1 },
    { NULL, "V", 0x2, 16, 17, 4, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x2, 18, 19, 4, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 20, 19, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 21, 22, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 23, 15, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 24, 19, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 25, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 27, 19, 4, -1, -1, -1 },
    { NULL, "LJavaIoOutputStream;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaIoInputStream;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x1, 28, 22, 4, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 29, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 30, 19, 4, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 31, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 32, 33, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 34, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 35, 36, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 37, 38, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 39, 40, 4, -1, -1, -1 },
    { NULL, "[B", 0x4, 41, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "S", 0x4, 42, 43, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0xc, 44, 33, 4, -1, -1, -1 },
    { NULL, "[B", 0xc, 45, 46, -1, -1, -1, -1 },
    { NULL, "[B", 0xc, 47, 22, 4, -1, -1, -1 },
    { NULL, "V", 0xc, 48, 49, 4, -1, -1, -1 },
    { NULL, "[B", 0xc, 50, 51, -1, -1, -1, -1 },
    { NULL, "LJavaUtilHashtable;", 0xc, 52, 33, 4, -1, -1, -1 },
    { NULL, "LJavaUtilVector;", 0xc, 53, 33, 4, -1, -1, -1 },
    { NULL, "V", 0xc, 54, 55, 4, -1, -1, -1 },
    { NULL, "V", 0xc, 56, 57, 4, -1, -1, -1 },
    { NULL, "V", 0xc, 58, 59, 4, -1, -1, -1 },
    { NULL, "I", 0xc, 60, 61, 4, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoInputStream:withJavaIoOutputStream:withJavaSecuritySecureRandom:);
  methods[1].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[2].selector = @selector(getContext);
  methods[3].selector = @selector(getContextAdmin);
  methods[4].selector = @selector(getPeer);
  methods[5].selector = @selector(handleAlertMessageWithShort:withShort:);
  methods[6].selector = @selector(handleAlertWarningMessageWithShort:);
  methods[7].selector = @selector(handleChangeCipherSpecMessage);
  methods[8].selector = @selector(handleCloseWithBoolean:);
  methods[9].selector = @selector(handleExceptionWithShort:withNSString:withJavaLangThrowable:);
  methods[10].selector = @selector(handleFailure);
  methods[11].selector = @selector(handleHandshakeMessageWithShort:withJavaIoByteArrayInputStream:);
  methods[12].selector = @selector(applyMaxFragmentLengthExtension);
  methods[13].selector = @selector(checkReceivedChangeCipherSpecWithBoolean:);
  methods[14].selector = @selector(cleanupHandshake);
  methods[15].selector = @selector(blockForHandshake);
  methods[16].selector = @selector(completeHandshake);
  methods[17].selector = @selector(processRecordWithShort:withByteArray:withInt:withInt:);
  methods[18].selector = @selector(processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue:);
  methods[19].selector = @selector(processApplicationDataQueue);
  methods[20].selector = @selector(processAlertQueue);
  methods[21].selector = @selector(processChangeCipherSpecWithByteArray:withInt:withInt:);
  methods[22].selector = @selector(applicationDataAvailable);
  methods[23].selector = @selector(readApplicationDataWithByteArray:withInt:withInt:);
  methods[24].selector = @selector(safeCheckRecordHeaderWithByteArray:);
  methods[25].selector = @selector(safeReadRecord);
  methods[26].selector = @selector(safeWriteRecordWithShort:withByteArray:withInt:withInt:);
  methods[27].selector = @selector(writeDataWithByteArray:withInt:withInt:);
  methods[28].selector = @selector(setAppDataSplitModeWithInt:);
  methods[29].selector = @selector(writeHandshakeMessageWithByteArray:withInt:withInt:);
  methods[30].selector = @selector(getOutputStream);
  methods[31].selector = @selector(getInputStream);
  methods[32].selector = @selector(closeInput);
  methods[33].selector = @selector(offerInputWithByteArray:);
  methods[34].selector = @selector(getAvailableInputBytes);
  methods[35].selector = @selector(readInputWithByteArray:withInt:withInt:);
  methods[36].selector = @selector(offerOutputWithByteArray:withInt:withInt:);
  methods[37].selector = @selector(getAvailableOutputBytes);
  methods[38].selector = @selector(readOutputWithByteArray:withInt:withInt:);
  methods[39].selector = @selector(invalidateSession);
  methods[40].selector = @selector(processFinishedMessageWithJavaIoByteArrayInputStream:);
  methods[41].selector = @selector(raiseAlertFatalWithShort:withNSString:withJavaLangThrowable:);
  methods[42].selector = @selector(raiseAlertWarningWithShort:withNSString:);
  methods[43].selector = @selector(sendCertificateMessageWithLibOrgBouncycastleCryptoTlsCertificate:);
  methods[44].selector = @selector(sendChangeCipherSpecMessage);
  methods[45].selector = @selector(sendFinishedMessage);
  methods[46].selector = @selector(sendSupplementalDataMessageWithJavaUtilVector:);
  methods[47].selector = @selector(createVerifyDataWithBoolean:);
  methods[48].selector = @selector(close);
  methods[49].selector = @selector(flush);
  methods[50].selector = @selector(isClosed);
  methods[51].selector = @selector(processMaxFragmentLengthExtensionWithJavaUtilHashtable:withJavaUtilHashtable:withShort:);
  methods[52].selector = @selector(refuseRenegotiation);
  methods[53].selector = @selector(assertEmptyWithJavaIoByteArrayInputStream:);
  methods[54].selector = @selector(createRandomBlockWithBoolean:withLibOrgBouncycastleCryptoPrngRandomGenerator:);
  methods[55].selector = @selector(createRenegotiationInfoWithByteArray:);
  methods[56].selector = @selector(establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoTlsTlsKeyExchange:);
  methods[57].selector = @selector(getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoTlsTlsHandshakeHash:withByteArray:);
  methods[58].selector = @selector(readExtensionsWithJavaIoByteArrayInputStream:);
  methods[59].selector = @selector(readSupplementalDataMessageWithJavaIoByteArrayInputStream:);
  methods[60].selector = @selector(writeExtensionsWithJavaIoOutputStream:withJavaUtilHashtable:);
  methods[61].selector = @selector(writeSelectedExtensionsWithJavaIoOutputStream:withJavaUtilHashtable:withBoolean:);
  methods[62].selector = @selector(writeSupplementalDataWithJavaIoOutputStream:withJavaUtilVector:);
  methods[63].selector = @selector(getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "EXT_RenegotiationInfo", "LJavaLangInteger;", .constantValue.asLong = 0, 0x1c, -1, 62, -1, -1 },
    { "EXT_SessionTicket", "LJavaLangInteger;", .constantValue.asLong = 0, 0x1c, -1, 63, -1, -1 },
    { "CS_START", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_START, 0x1c, -1, -1, -1, -1 },
    { "CS_CLIENT_HELLO", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_HELLO", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_SUPPLEMENTAL_DATA", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_CERTIFICATE", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE, 0x1c, -1, -1, -1, -1 },
    { "CS_CERTIFICATE_STATUS", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_KEY_EXCHANGE", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE, 0x1c, -1, -1, -1, -1 },
    { "CS_CERTIFICATE_REQUEST", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_HELLO_DONE", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE, 0x1c, -1, -1, -1, -1 },
    { "CS_CLIENT_SUPPLEMENTAL_DATA", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA, 0x1c, -1, -1, -1, -1 },
    { "CS_CLIENT_CERTIFICATE", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE, 0x1c, -1, -1, -1, -1 },
    { "CS_CLIENT_KEY_EXCHANGE", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE, 0x1c, -1, -1, -1, -1 },
    { "CS_CERTIFICATE_VERIFY", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY, 0x1c, -1, -1, -1, -1 },
    { "CS_CLIENT_FINISHED", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_SESSION_TICKET", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET, 0x1c, -1, -1, -1, -1 },
    { "CS_SERVER_FINISHED", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED, 0x1c, -1, -1, -1, -1 },
    { "CS_END", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END, 0x1c, -1, -1, -1, -1 },
    { "ADS_MODE_1_Nsub1", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1, 0x1c, -1, -1, -1, -1 },
    { "ADS_MODE_0_N", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N, 0x1c, -1, -1, -1, -1 },
    { "ADS_MODE_0_N_FIRSTONLY", "S", .constantValue.asShort = LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_0_N_FIRSTONLY, 0x1c, -1, -1, -1, -1 },
    { "applicationDataQueue_", "LLibOrgBouncycastleCryptoTlsByteQueue;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "alertQueue_", "LLibOrgBouncycastleCryptoTlsByteQueue;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "handshakeQueue_", "LLibOrgBouncycastleCryptoTlsByteQueue;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "recordStream_", "LLibOrgBouncycastleCryptoTlsRecordStream;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "secureRandom_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "tlsInputStream_", "LLibOrgBouncycastleCryptoTlsTlsInputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "tlsOutputStream_", "LLibOrgBouncycastleCryptoTlsTlsOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "closed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "failedWithError_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "appDataReady_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "appDataSplitEnabled_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "appDataSplitMode_", "I", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "expected_verify_data_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "tlsSession_", "LLibOrgBouncycastleCryptoTlsTlsSession;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "sessionParameters_", "LLibOrgBouncycastleCryptoTlsSessionParameters;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "securityParameters_", "LLibOrgBouncycastleCryptoTlsSecurityParameters;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "peerCertificate_", "LLibOrgBouncycastleCryptoTlsCertificate;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "offeredCipherSuites_", "[I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "offeredCompressionMethods_", "[S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "clientExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "serverExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "connection_state_", "S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "resumedSession_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "receivedChangeCipherSpec_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "secure_renegotiation_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "allowCertificateStatus_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "expectSessionTicket_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "blocking_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "inputBuffers_", "LLibOrgBouncycastleCryptoTlsByteQueueInputStream;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "outputBuffer_", "LLibOrgBouncycastleCryptoTlsByteQueueOutputStream;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoInputStream;LJavaIoOutputStream;LJavaSecuritySecureRandom;", "LJavaSecuritySecureRandom;", "handleAlertMessage", "SS", "LJavaIoIOException;", "handleAlertWarningMessage", "S", "handleClose", "Z", "handleException", "SLNSString;LJavaLangThrowable;", "handleHandshakeMessage", "SLJavaIoByteArrayInputStream;", "checkReceivedChangeCipherSpec", "processRecord", "S[BII", "processHandshakeQueue", "LLibOrgBouncycastleCryptoTlsByteQueue;", "processChangeCipherSpec", "[BII", "readApplicationData", "safeCheckRecordHeader", "[B", "safeWriteRecord", "writeData", "setAppDataSplitMode", "I", "writeHandshakeMessage", "offerInput", "readInput", "offerOutput", "readOutput", "processFinishedMessage", "LJavaIoByteArrayInputStream;", "raiseAlertFatal", "raiseAlertWarning", "SLNSString;", "sendCertificateMessage", "LLibOrgBouncycastleCryptoTlsCertificate;", "sendSupplementalDataMessage", "LJavaUtilVector;", "createVerifyData", "processMaxFragmentLengthExtension", "LJavaUtilHashtable;LJavaUtilHashtable;S", "assertEmpty", "createRandomBlock", "ZLLibOrgBouncycastleCryptoPrngRandomGenerator;", "createRenegotiationInfo", "establishMasterSecret", "LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoTlsTlsKeyExchange;", "getCurrentPRFHash", "LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoTlsTlsHandshakeHash;[B", "readExtensions", "readSupplementalDataMessage", "writeExtensions", "LJavaIoOutputStream;LJavaUtilHashtable;", "writeSelectedExtensions", "LJavaIoOutputStream;LJavaUtilHashtable;Z", "writeSupplementalData", "LJavaIoOutputStream;LJavaUtilVector;", "getPRFAlgorithm", "LLibOrgBouncycastleCryptoTlsTlsContext;I", &LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_RenegotiationInfo, &LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_SessionTicket, "LLibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsProtocol = { "TlsProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x401, 64, 52, -1, 64, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsProtocol;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoTlsTlsProtocol class]) {
    LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_RenegotiationInfo = LibOrgBouncycastleUtilIntegers_valueOfWithInt_(LibOrgBouncycastleCryptoTlsExtensionType_renegotiation_info);
    LibOrgBouncycastleCryptoTlsTlsProtocol_EXT_SessionTicket = LibOrgBouncycastleUtilIntegers_valueOfWithInt_(LibOrgBouncycastleCryptoTlsExtensionType_session_ticket);
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoTlsTlsProtocol)
  }
}

@end

void LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  NSObject_init(self);
  self->applicationDataQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(0);
  self->alertQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(2);
  self->handshakeQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(0);
  self->tlsInputStream_ = nil;
  self->tlsOutputStream_ = nil;
  JreAssignVolatileBoolean(&self->closed_, false);
  JreAssignVolatileBoolean(&self->failedWithError_, false);
  JreAssignVolatileBoolean(&self->appDataReady_, false);
  JreAssignVolatileBoolean(&self->appDataSplitEnabled_, true);
  JreAssignVolatileInt(&self->appDataSplitMode_, LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1);
  self->expected_verify_data_ = nil;
  self->tlsSession_ = nil;
  self->sessionParameters_ = nil;
  self->securityParameters_ = nil;
  self->peerCertificate_ = nil;
  self->offeredCipherSuites_ = nil;
  self->offeredCompressionMethods_ = nil;
  self->clientExtensions_ = nil;
  self->serverExtensions_ = nil;
  self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_START;
  self->resumedSession_ = false;
  self->receivedChangeCipherSpec_ = false;
  self->secure_renegotiation_ = false;
  self->allowCertificateStatus_ = false;
  self->expectSessionTicket_ = false;
  self->blocking_ = true;
  self->recordStream_ = new_LibOrgBouncycastleCryptoTlsRecordStream_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withJavaIoInputStream_withJavaIoOutputStream_(self, input, output);
  self->secureRandom_ = secureRandom;
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  NSObject_init(self);
  self->applicationDataQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(0);
  self->alertQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(2);
  self->handshakeQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_initWithInt_(0);
  self->tlsInputStream_ = nil;
  self->tlsOutputStream_ = nil;
  JreAssignVolatileBoolean(&self->closed_, false);
  JreAssignVolatileBoolean(&self->failedWithError_, false);
  JreAssignVolatileBoolean(&self->appDataReady_, false);
  JreAssignVolatileBoolean(&self->appDataSplitEnabled_, true);
  JreAssignVolatileInt(&self->appDataSplitMode_, LibOrgBouncycastleCryptoTlsTlsProtocol_ADS_MODE_1_Nsub1);
  self->expected_verify_data_ = nil;
  self->tlsSession_ = nil;
  self->sessionParameters_ = nil;
  self->securityParameters_ = nil;
  self->peerCertificate_ = nil;
  self->offeredCipherSuites_ = nil;
  self->offeredCompressionMethods_ = nil;
  self->clientExtensions_ = nil;
  self->serverExtensions_ = nil;
  self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_START;
  self->resumedSession_ = false;
  self->receivedChangeCipherSpec_ = false;
  self->secure_renegotiation_ = false;
  self->allowCertificateStatus_ = false;
  self->expectSessionTicket_ = false;
  self->blocking_ = false;
  self->inputBuffers_ = new_LibOrgBouncycastleCryptoTlsByteQueueInputStream_init();
  self->outputBuffer_ = new_LibOrgBouncycastleCryptoTlsByteQueueOutputStream_init();
  self->recordStream_ = new_LibOrgBouncycastleCryptoTlsRecordStream_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withJavaIoInputStream_withJavaIoOutputStream_(self, self->inputBuffers_, self->outputBuffer_);
  self->secureRandom_ = secureRandom;
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_processHandshakeQueueWithLibOrgBouncycastleCryptoTlsByteQueue_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, LibOrgBouncycastleCryptoTlsByteQueue *queue) {
  while ([((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(queue)) available] >= 4) {
    IOSByteArray *beginning = [IOSByteArray newArrayWithLength:4];
    [queue readWithByteArray:beginning withInt:0 withInt:4 withInt:0];
    jshort type = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(beginning, 0);
    jint length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint24WithByteArray_withInt_(beginning, 1);
    jint totalLength = 4 + length;
    if ([queue available] < totalLength) {
      break;
    }
    if (LibOrgBouncycastleCryptoTlsHandshakeType_hello_request != type) {
      if (LibOrgBouncycastleCryptoTlsHandshakeType_finished == type) {
        [self checkReceivedChangeCipherSpecWithBoolean:true];
        id<LibOrgBouncycastleCryptoTlsTlsContext> ctx = [self getContext];
        if (self->expected_verify_data_ == nil && [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(ctx)) getSecurityParameters])) getMasterSecret] != nil) {
          self->expected_verify_data_ = [self createVerifyDataWithBoolean:![((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(ctx)) isServer]];
        }
      }
      else {
        [self checkReceivedChangeCipherSpecWithBoolean:self->connection_state_ == LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END];
      }
      [queue copyToWithJavaIoOutputStream:[((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHashUpdater] withInt:totalLength];
    }
    [queue removeDataWithInt:4];
    JavaIoByteArrayInputStream *buf = [queue readFromWithInt:length];
    [self handleHandshakeMessageWithShort:type withJavaIoByteArrayInputStream:buf];
  }
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_processApplicationDataQueue(LibOrgBouncycastleCryptoTlsTlsProtocol *self) {
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_processAlertQueue(LibOrgBouncycastleCryptoTlsTlsProtocol *self) {
  while ([((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->alertQueue_)) available] >= 2) {
    IOSByteArray *alert = [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->alertQueue_)) removeDataWithInt:2 withInt:0];
    jshort alertLevel = IOSByteArray_Get(nil_chk(alert), 0);
    jshort alertDescription = IOSByteArray_Get(alert, 1);
    [self handleAlertMessageWithShort:alertLevel withShort:alertDescription];
  }
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_processChangeCipherSpecWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoTlsTlsProtocol *self, IOSByteArray *buf, jint off, jint len) {
  for (jint i = 0; i < len; ++i) {
    jshort message = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(buf, off + i);
    if (message != LibOrgBouncycastleCryptoTlsChangeCipherSpec_change_cipher_spec) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
    }
    if (self->receivedChangeCipherSpec_ || [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->alertQueue_)) available] > 0 || [((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->handshakeQueue_)) available] > 0) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
    }
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) receivedReadCipherSpec];
    self->receivedChangeCipherSpec_ = true;
    [self handleChangeCipherSpecMessage];
  }
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(JavaIoByteArrayInputStream *buf) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  if ([((JavaIoByteArrayInputStream *) nil_chk(buf)) available] > 0) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
  }
}

IOSByteArray *LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_(jboolean useGMTUnixTime, id<LibOrgBouncycastleCryptoPrngRandomGenerator> randomGenerator) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  IOSByteArray *result = [IOSByteArray newArrayWithLength:32];
  [((id<LibOrgBouncycastleCryptoPrngRandomGenerator>) nil_chk(randomGenerator)) nextBytesWithByteArray:result];
  if (useGMTUnixTime) {
    LibOrgBouncycastleCryptoTlsTlsUtils_writeGMTUnixTimeWithByteArray_withInt_(result, 0);
  }
  return result;
}

IOSByteArray *LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(IOSByteArray *renegotiated_connection) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  return LibOrgBouncycastleCryptoTlsTlsUtils_encodeOpaque8WithByteArray_(renegotiated_connection);
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoTlsTlsKeyExchange> keyExchange) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  IOSByteArray *pre_master_secret = [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(keyExchange)) generatePremasterSecret];
  @try {
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context)) getSecurityParameters]))->masterSecret_ = LibOrgBouncycastleCryptoTlsTlsUtils_calculateMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withByteArray_(context, pre_master_secret);
  }
  @finally {
    if (pre_master_secret != nil) {
      LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(pre_master_secret, (jbyte) 0);
    }
  }
}

IOSByteArray *LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash> handshakeHash, IOSByteArray *sslSender) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  id<LibOrgBouncycastleCryptoDigest> d = [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk(handshakeHash)) forkPRFHash];
  if (sslSender != nil && LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_(context)) {
    [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(d)) updateWithByteArray:sslSender withInt:0 withInt:sslSender->size_];
  }
  IOSByteArray *bs = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(d)) getDigestSize]];
  [d doFinalWithByteArray:bs withInt:0];
  return bs;
}

JavaUtilHashtable *LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(JavaIoByteArrayInputStream *input) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  if ([((JavaIoByteArrayInputStream *) nil_chk(input)) available] < 1) {
    return nil;
  }
  IOSByteArray *extBytes = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque16WithJavaIoInputStream_(input);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(input);
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(extBytes);
  JavaUtilHashtable *extensions = new_JavaUtilHashtable_init();
  while ([buf available] > 0) {
    JavaLangInteger *extension_type = LibOrgBouncycastleUtilIntegers_valueOfWithInt_(LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf));
    IOSByteArray *extension_data = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque16WithJavaIoInputStream_(buf);
    if (nil != [extensions putWithId:extension_type withId:extension_data]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
  }
  return extensions;
}

JavaUtilVector *LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(JavaIoByteArrayInputStream *input) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  IOSByteArray *supp_data = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque24WithJavaIoInputStream_(input);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(input);
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(supp_data);
  JavaUtilVector *supplementalData = new_JavaUtilVector_init();
  while ([buf available] > 0) {
    jint supp_data_type = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
    IOSByteArray *data = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque16WithJavaIoInputStream_(buf);
    [supplementalData addElementWithId:new_LibOrgBouncycastleCryptoTlsSupplementalDataEntry_initWithInt_withByteArray_(supp_data_type, data)];
  }
  return supplementalData;
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(JavaIoOutputStream *output, JavaUtilHashtable *extensions) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSelectedExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_withBoolean_(buf, extensions, true);
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSelectedExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_withBoolean_(buf, extensions, false);
  IOSByteArray *extBytes = [buf toByteArray];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque16WithByteArray_withJavaIoOutputStream_(extBytes, output);
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_writeSelectedExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_withBoolean_(JavaIoOutputStream *output, JavaUtilHashtable *extensions, jboolean selectEmpty) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  id<JavaUtilEnumeration> keys = [((JavaUtilHashtable *) nil_chk(extensions)) keys];
  while ([((id<JavaUtilEnumeration>) nil_chk(keys)) hasMoreElements]) {
    JavaLangInteger *key = (JavaLangInteger *) cast_chk([keys nextElement], [JavaLangInteger class]);
    jint extension_type = [((JavaLangInteger *) nil_chk(key)) intValue];
    IOSByteArray *extension_data = (IOSByteArray *) cast_chk([extensions getWithId:key], [IOSByteArray class]);
    if (selectEmpty == (((IOSByteArray *) nil_chk(extension_data))->size_ == 0)) {
      LibOrgBouncycastleCryptoTlsTlsUtils_checkUint16WithInt_(extension_type);
      LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withJavaIoOutputStream_(extension_type, output);
      LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque16WithByteArray_withJavaIoOutputStream_(extension_data, output);
    }
  }
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_writeSupplementalDataWithJavaIoOutputStream_withJavaUtilVector_(JavaIoOutputStream *output, JavaUtilVector *supplementalData) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  for (jint i = 0; i < [((JavaUtilVector *) nil_chk(supplementalData)) size]; ++i) {
    LibOrgBouncycastleCryptoTlsSupplementalDataEntry *entry_ = (LibOrgBouncycastleCryptoTlsSupplementalDataEntry *) cast_chk([supplementalData elementAtWithInt:i], [LibOrgBouncycastleCryptoTlsSupplementalDataEntry class]);
    jint supp_data_type = [((LibOrgBouncycastleCryptoTlsSupplementalDataEntry *) nil_chk(entry_)) getDataType];
    LibOrgBouncycastleCryptoTlsTlsUtils_checkUint16WithInt_(supp_data_type);
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withJavaIoOutputStream_(supp_data_type, buf);
    LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque16WithByteArray_withJavaIoOutputStream_([entry_ getData], buf);
  }
  IOSByteArray *supp_data = [buf toByteArray];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque24WithByteArray_withJavaIoOutputStream_(supp_data, output);
}

jint LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, jint ciphersuite) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initialize();
  jboolean isTLSv12 = LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(context);
  switch (ciphersuite) {
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_AES_128_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_PSK_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_AES_256_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_PSK_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_128_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_128_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_RSA_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_256_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_256_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_RSA_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_128_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_ECDSA_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_256_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_ECDSA_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_PSK_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_PSK_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_RSA_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_RSA_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_DHE_WITH_AES_128_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_DHE_WITH_AES_256_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_128_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_128_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_PSK_WITH_AES_128_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_256_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_256_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_PSK_WITH_AES_256_OCB:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_DRAFT_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_128_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_128_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_256_CCM:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_256_CCM_8:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_NULL_SHA256:
    {
      if (isTLSv12) {
        return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_sha256;
      }
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_AES_256_GCM_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    {
      if (isTLSv12) {
        return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_sha384;
      }
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_DHE_PSK_WITH_NULL_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_ECDHE_PSK_WITH_NULL_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_PSK_WITH_NULL_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case LibOrgBouncycastleCryptoTlsCipherSuite_TLS_RSA_PSK_WITH_NULL_SHA384:
    {
      if (isTLSv12) {
        return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_sha384;
      }
      return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_legacy;
    }
    default:
    {
      if (isTLSv12) {
        return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_sha256;
      }
      return LibOrgBouncycastleCryptoTlsPRFAlgorithm_tls_prf_legacy;
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsProtocol)

@implementation LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsProtocol:(LibOrgBouncycastleCryptoTlsTlsProtocol *)outer$
                                                     withShort:(jshort)handshakeType {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, outer$, handshakeType);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsProtocol:(LibOrgBouncycastleCryptoTlsTlsProtocol *)outer$
                                                     withShort:(jshort)handshakeType
                                                       withInt:(jint)length {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(self, outer$, handshakeType, length);
  return self;
}

- (void)writeToRecordStream {
  jint length = count_ - 4;
  LibOrgBouncycastleCryptoTlsTlsUtils_checkUint24WithInt_(length);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint24WithInt_withByteArray_withInt_(length, buf_, 1);
  [this$0_ writeHandshakeMessageWithByteArray:buf_ withInt:0 withInt:count_];
  buf_ = nil;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, 1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, 1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsProtocol:withShort:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsProtocol:withShort:withInt:);
  methods[2].selector = @selector(writeToRecordStream);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibOrgBouncycastleCryptoTlsTlsProtocol;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "S", "LJavaIoIOException;", "SI", "LLibOrgBouncycastleCryptoTlsTlsProtocol;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage = { "HandshakeMessage", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x0, 3, 1, 3, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage;
}

@end

void LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *self, LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(self, outer$, handshakeType, 60);
}

LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage, initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_, outer$, handshakeType)
}

LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *create_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage, initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_, outer$, handshakeType)
}

void LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *self, LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType, jint length) {
  self->this$0_ = outer$;
  JavaIoByteArrayOutputStream_initWithInt_(self, length + 4);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withJavaIoOutputStream_(handshakeType, self);
  self->count_ += 3;
}

LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType, jint length) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage, initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_, outer$, handshakeType, length)
}

LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *create_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(LibOrgBouncycastleCryptoTlsTlsProtocol *outer$, jshort handshakeType, jint length) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage, initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_, outer$, handshakeType, length)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage)

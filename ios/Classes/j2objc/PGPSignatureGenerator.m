//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/openpgp/PGPSignatureGenerator.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "IssuerKeyID.h"
#include "J2ObjC_source.h"
#include "MPInteger.h"
#include "OnePassSignaturePacket.h"
#include "PGPContentSigner.h"
#include "PGPContentSignerBuilder.h"
#include "PGPException.h"
#include "PGPOnePassSignature.h"
#include "PGPPrivateKey.h"
#include "PGPPublicKey.h"
#include "PGPRuntimeOperationException.h"
#include "PGPSignature.h"
#include "PGPSignatureGenerator.h"
#include "PGPSignatureSubpacketVector.h"
#include "PGPUserAttributeSubpacketVector.h"
#include "PGPUtil.h"
#include "PublicKeyAlgorithmTags.h"
#include "PublicKeyPacket.h"
#include "SignatureCreationTime.h"
#include "SignaturePacket.h"
#include "SignatureSubpacket.h"
#include "SignatureSubpacketTags.h"
#include "Strings.h"
#include "UserAttributeSubpacket.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/util/Date.h"

@interface LibOrgBouncycastleOpenpgpPGPSignatureGenerator () {
 @public
  IOSObjectArray *unhashed_;
  IOSObjectArray *hashed_;
  JavaIoOutputStream *sigOut_;
  id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder> contentSignerBuilder_;
  id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner> contentSigner_;
  jint sigType_;
  jbyte lastb_;
  jint providedKeyAlgorithm_;
}

- (void)byteUpdateWithByte:(jbyte)b;

- (void)blockUpdateWithByteArray:(IOSByteArray *)block
                         withInt:(jint)off
                         withInt:(jint)len;

- (IOSByteArray *)getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey;

- (jboolean)packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray:(IOSObjectArray *)packets
                                                                   withInt:(jint)type;

- (IOSObjectArray *)insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray:(IOSObjectArray *)packets
                                        withLibOrgBouncycastleBcpgSignatureSubpacket:(LibOrgBouncycastleBcpgSignatureSubpacket *)subpacket;

- (void)updateWithIdDataWithInt:(jint)header
                  withByteArray:(IOSByteArray *)idBytes;

- (void)updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)key;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, unhashed_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, hashed_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, sigOut_, JavaIoOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, contentSignerBuilder_, id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, contentSigner_, id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>)

__attribute__((unused)) static void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, jbyte b);

__attribute__((unused)) static void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_blockUpdateWithByteArray_withInt_withInt_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSByteArray *block, jint off, jint len);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleOpenpgpPGPSignatureGenerator_getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, LibOrgBouncycastleOpenpgpPGPPublicKey *pubKey);

__attribute__((unused)) static jboolean LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSObjectArray *packets, jint type);

__attribute__((unused)) static IOSObjectArray *LibOrgBouncycastleOpenpgpPGPSignatureGenerator_insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacket_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSObjectArray *packets, LibOrgBouncycastleBcpgSignatureSubpacket *subpacket);

__attribute__((unused)) static void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithIdDataWithInt_withByteArray_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, jint header, IOSByteArray *idBytes);

__attribute__((unused)) static void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, LibOrgBouncycastleOpenpgpPGPPublicKey *key);

@implementation LibOrgBouncycastleOpenpgpPGPSignatureGenerator

- (instancetype)initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder:(id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder>)contentSignerBuilder {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(self, contentSignerBuilder);
  return self;
}

- (void)init__WithInt:(jint)signatureType
withLibOrgBouncycastleOpenpgpPGPPrivateKey:(LibOrgBouncycastleOpenpgpPGPPrivateKey *)key {
  contentSigner_ = [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder>) nil_chk(contentSignerBuilder_)) buildWithInt:signatureType withLibOrgBouncycastleOpenpgpPGPPrivateKey:key];
  sigOut_ = [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getOutputStream];
  sigType_ = [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getType];
  lastb_ = 0;
  if (providedKeyAlgorithm_ >= 0 && providedKeyAlgorithm_ != [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm]) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"key algorithm mismatch");
  }
}

- (void)updateWithByte:(jbyte)b {
  if (sigType_ == LibOrgBouncycastleOpenpgpPGPSignature_CANONICAL_TEXT_DOCUMENT) {
    if (b == 0x000d) {
      LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, (jbyte) 0x000d);
      LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, (jbyte) 0x000a);
    }
    else if (b == 0x000a) {
      if (lastb_ != 0x000d) {
        LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, (jbyte) 0x000d);
        LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, (jbyte) 0x000a);
      }
    }
    else {
      LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, b);
    }
    lastb_ = b;
  }
  else {
    LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, b);
  }
}

- (void)updateWithByteArray:(IOSByteArray *)b {
  [self updateWithByteArray:b withInt:0 withInt:((IOSByteArray *) nil_chk(b))->size_];
}

- (void)updateWithByteArray:(IOSByteArray *)b
                    withInt:(jint)off
                    withInt:(jint)len {
  if (sigType_ == LibOrgBouncycastleOpenpgpPGPSignature_CANONICAL_TEXT_DOCUMENT) {
    jint finish = off + len;
    for (jint i = off; i != finish; i++) {
      [self updateWithByte:IOSByteArray_Get(nil_chk(b), i)];
    }
  }
  else {
    LibOrgBouncycastleOpenpgpPGPSignatureGenerator_blockUpdateWithByteArray_withInt_withInt_(self, b, off, len);
  }
}

- (void)byteUpdateWithByte:(jbyte)b {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(self, b);
}

- (void)blockUpdateWithByteArray:(IOSByteArray *)block
                         withInt:(jint)off
                         withInt:(jint)len {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_blockUpdateWithByteArray_withInt_withInt_(self, block, off, len);
}

- (void)setHashedSubpacketsWithLibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector:(LibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector *)hashedPcks {
  if (hashedPcks == nil) {
    hashed_ = [IOSObjectArray newArrayWithLength:0 type:LibOrgBouncycastleBcpgSignatureSubpacket_class_()];
    return;
  }
  hashed_ = [hashedPcks toSubpacketArray];
}

- (void)setUnhashedSubpacketsWithLibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector:(LibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector *)unhashedPcks {
  if (unhashedPcks == nil) {
    unhashed_ = [IOSObjectArray newArrayWithLength:0 type:LibOrgBouncycastleBcpgSignatureSubpacket_class_()];
    return;
  }
  unhashed_ = [unhashedPcks toSubpacketArray];
}

- (LibOrgBouncycastleOpenpgpPGPOnePassSignature *)generateOnePassVersionWithBoolean:(jboolean)isNested {
  return new_LibOrgBouncycastleOpenpgpPGPOnePassSignature_initWithLibOrgBouncycastleBcpgOnePassSignaturePacket_(new_LibOrgBouncycastleBcpgOnePassSignaturePacket_initWithInt_withInt_withInt_withLong_withBoolean_(sigType_, [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getHashAlgorithm], [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm], [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyID], isNested));
}

- (LibOrgBouncycastleOpenpgpPGPSignature *)generate {
  IOSObjectArray *sigValues;
  jint version_ = 4;
  JavaIoByteArrayOutputStream *sOut = new_JavaIoByteArrayOutputStream_init();
  IOSObjectArray *hPkts;
  IOSObjectArray *unhPkts;
  if (!LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(self, hashed_, LibOrgBouncycastleBcpgSignatureSubpacketTags_CREATION_TIME)) {
    hPkts = LibOrgBouncycastleOpenpgpPGPSignatureGenerator_insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacket_(self, hashed_, new_LibOrgBouncycastleBcpgSigSignatureCreationTime_initWithBoolean_withJavaUtilDate_(false, new_JavaUtilDate_init()));
  }
  else {
    hPkts = hashed_;
  }
  if (!LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(self, hashed_, LibOrgBouncycastleBcpgSignatureSubpacketTags_ISSUER_KEY_ID) && !LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(self, unhashed_, LibOrgBouncycastleBcpgSignatureSubpacketTags_ISSUER_KEY_ID)) {
    unhPkts = LibOrgBouncycastleOpenpgpPGPSignatureGenerator_insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacket_(self, unhashed_, new_LibOrgBouncycastleBcpgSigIssuerKeyID_initWithBoolean_withLong_(false, [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyID]));
  }
  else {
    unhPkts = unhashed_;
  }
  @try {
    [sOut writeWithInt:(jbyte) version_];
    [sOut writeWithInt:(jbyte) sigType_];
    [sOut writeWithInt:(jbyte) [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm]];
    [sOut writeWithInt:(jbyte) [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getHashAlgorithm]];
    JavaIoByteArrayOutputStream *hOut = new_JavaIoByteArrayOutputStream_init();
    for (jint i = 0; i != ((IOSObjectArray *) nil_chk(hPkts))->size_; i++) {
      [((LibOrgBouncycastleBcpgSignatureSubpacket *) nil_chk(IOSObjectArray_Get(hPkts, i))) encodeWithJavaIoOutputStream:hOut];
    }
    IOSByteArray *data = [hOut toByteArray];
    [sOut writeWithInt:(jbyte) (JreRShift32(((IOSByteArray *) nil_chk(data))->size_, 8))];
    [sOut writeWithInt:(jbyte) data->size_];
    [sOut writeWithByteArray:data];
  }
  @catch (JavaIoIOException *e) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_withJavaLangException_(@"exception encoding hashed data.", e);
  }
  IOSByteArray *hData = [sOut toByteArray];
  [sOut writeWithInt:(jbyte) version_];
  [sOut writeWithInt:(jbyte) (jint) 0xff];
  [sOut writeWithInt:(jbyte) (JreRShift32(((IOSByteArray *) nil_chk(hData))->size_, 24))];
  [sOut writeWithInt:(jbyte) (JreRShift32(hData->size_, 16))];
  [sOut writeWithInt:(jbyte) (JreRShift32(hData->size_, 8))];
  [sOut writeWithInt:(jbyte) (hData->size_)];
  IOSByteArray *trailer = [sOut toByteArray];
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_blockUpdateWithByteArray_withInt_withInt_(self, trailer, 0, ((IOSByteArray *) nil_chk(trailer))->size_);
  if ([((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm] == LibOrgBouncycastleBcpgPublicKeyAlgorithmTags_RSA_SIGN || [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm] == LibOrgBouncycastleBcpgPublicKeyAlgorithmTags_RSA_GENERAL) {
    sigValues = [IOSObjectArray newArrayWithLength:1 type:LibOrgBouncycastleBcpgMPInteger_class_()];
    (void) IOSObjectArray_SetAndConsume(sigValues, 0, new_LibOrgBouncycastleBcpgMPInteger_initWithJavaMathBigInteger_(new_JavaMathBigInteger_initWithInt_withByteArray_(1, [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getSignature])));
  }
  else {
    sigValues = LibOrgBouncycastleOpenpgpPGPUtil_dsaSigToMpiWithByteArray_([((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getSignature]);
  }
  IOSByteArray *digest = [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getDigest];
  IOSByteArray *fingerPrint = [IOSByteArray newArrayWithLength:2];
  *IOSByteArray_GetRef(fingerPrint, 0) = IOSByteArray_Get(nil_chk(digest), 0);
  *IOSByteArray_GetRef(fingerPrint, 1) = IOSByteArray_Get(digest, 1);
  return new_LibOrgBouncycastleOpenpgpPGPSignature_initWithLibOrgBouncycastleBcpgSignaturePacket_(new_LibOrgBouncycastleBcpgSignaturePacket_initWithInt_withLong_withInt_withInt_withLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacketArray_withByteArray_withLibOrgBouncycastleBcpgMPIntegerArray_(sigType_, [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyID], [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getKeyAlgorithm], [((id<LibOrgBouncycastleOpenpgpOperatorPGPContentSigner>) nil_chk(contentSigner_)) getHashAlgorithm], hPkts, unhPkts, fingerPrint, sigValues));
}

- (LibOrgBouncycastleOpenpgpPGPSignature *)generateCertificationWithNSString:(NSString *)id_
                                   withLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, pubKey);
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithIdDataWithInt_withByteArray_(self, (jint) 0xb4, LibOrgBouncycastleUtilStrings_toUTF8ByteArrayWithNSString_(id_));
  return [self generate];
}

- (LibOrgBouncycastleOpenpgpPGPSignature *)generateCertificationWithLibOrgBouncycastleOpenpgpPGPUserAttributeSubpacketVector:(LibOrgBouncycastleOpenpgpPGPUserAttributeSubpacketVector *)userAttributes
                                                                                   withLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, pubKey);
  @try {
    JavaIoByteArrayOutputStream *bOut = new_JavaIoByteArrayOutputStream_init();
    IOSObjectArray *packets = [((LibOrgBouncycastleOpenpgpPGPUserAttributeSubpacketVector *) nil_chk(userAttributes)) toSubpacketArray];
    for (jint i = 0; i != ((IOSObjectArray *) nil_chk(packets))->size_; i++) {
      [((LibOrgBouncycastleBcpgUserAttributeSubpacket *) nil_chk(IOSObjectArray_Get(packets, i))) encodeWithJavaIoOutputStream:bOut];
    }
    LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithIdDataWithInt_withByteArray_(self, (jint) 0xd1, [bOut toByteArray]);
  }
  @catch (JavaIoIOException *e) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_withJavaLangException_(@"cannot encode subpacket array", e);
  }
  return [self generate];
}

- (LibOrgBouncycastleOpenpgpPGPSignature *)generateCertificationWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)masterKey
                                                                withLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, masterKey);
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, pubKey);
  return [self generate];
}

- (LibOrgBouncycastleOpenpgpPGPSignature *)generateCertificationWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey {
  if ((sigType_ == LibOrgBouncycastleOpenpgpPGPSignature_SUBKEY_REVOCATION || sigType_ == LibOrgBouncycastleOpenpgpPGPSignature_SUBKEY_BINDING) && ![((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(pubKey)) isMasterKey]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"certifications involving subkey requires public key of revoking key as well.");
  }
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, pubKey);
  return [self generate];
}

- (IOSByteArray *)getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)pubKey {
  return LibOrgBouncycastleOpenpgpPGPSignatureGenerator_getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, pubKey);
}

- (jboolean)packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray:(IOSObjectArray *)packets
                                                                   withInt:(jint)type {
  return LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(self, packets, type);
}

- (IOSObjectArray *)insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray:(IOSObjectArray *)packets
                                        withLibOrgBouncycastleBcpgSignatureSubpacket:(LibOrgBouncycastleBcpgSignatureSubpacket *)subpacket {
  return LibOrgBouncycastleOpenpgpPGPSignatureGenerator_insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacket_(self, packets, subpacket);
}

- (void)updateWithIdDataWithInt:(jint)header
                  withByteArray:(IOSByteArray *)idBytes {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithIdDataWithInt_withByteArray_(self, header, idBytes);
}

- (void)updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:(LibOrgBouncycastleOpenpgpPGPPublicKey *)key {
  LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, key);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 9, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 11, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPOnePassSignature;", 0x1, 13, 14, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPSignature;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPSignature;", 0x1, 15, 16, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPSignature;", 0x1, 15, 17, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPSignature;", 0x1, 15, 18, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPSignature;", 0x1, 15, 19, 3, -1, -1, -1 },
    { NULL, "[B", 0x2, 20, 19, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "[LLibOrgBouncycastleBcpgSignatureSubpacket;", 0x2, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 19, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder:);
  methods[1].selector = @selector(init__WithInt:withLibOrgBouncycastleOpenpgpPGPPrivateKey:);
  methods[2].selector = @selector(updateWithByte:);
  methods[3].selector = @selector(updateWithByteArray:);
  methods[4].selector = @selector(updateWithByteArray:withInt:withInt:);
  methods[5].selector = @selector(byteUpdateWithByte:);
  methods[6].selector = @selector(blockUpdateWithByteArray:withInt:withInt:);
  methods[7].selector = @selector(setHashedSubpacketsWithLibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector:);
  methods[8].selector = @selector(setUnhashedSubpacketsWithLibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector:);
  methods[9].selector = @selector(generateOnePassVersionWithBoolean:);
  methods[10].selector = @selector(generate);
  methods[11].selector = @selector(generateCertificationWithNSString:withLibOrgBouncycastleOpenpgpPGPPublicKey:);
  methods[12].selector = @selector(generateCertificationWithLibOrgBouncycastleOpenpgpPGPUserAttributeSubpacketVector:withLibOrgBouncycastleOpenpgpPGPPublicKey:);
  methods[13].selector = @selector(generateCertificationWithLibOrgBouncycastleOpenpgpPGPPublicKey:withLibOrgBouncycastleOpenpgpPGPPublicKey:);
  methods[14].selector = @selector(generateCertificationWithLibOrgBouncycastleOpenpgpPGPPublicKey:);
  methods[15].selector = @selector(getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:);
  methods[16].selector = @selector(packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray:withInt:);
  methods[17].selector = @selector(insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray:withLibOrgBouncycastleBcpgSignatureSubpacket:);
  methods[18].selector = @selector(updateWithIdDataWithInt:withByteArray:);
  methods[19].selector = @selector(updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "unhashed_", "[LLibOrgBouncycastleBcpgSignatureSubpacket;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "hashed_", "[LLibOrgBouncycastleBcpgSignatureSubpacket;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "sigOut_", "LJavaIoOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "contentSignerBuilder_", "LLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "contentSigner_", "LLibOrgBouncycastleOpenpgpOperatorPGPContentSigner;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "sigType_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lastb_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "providedKeyAlgorithm_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder;", "init", "ILLibOrgBouncycastleOpenpgpPGPPrivateKey;", "LLibOrgBouncycastleOpenpgpPGPException;", "update", "B", "[B", "[BII", "byteUpdate", "blockUpdate", "setHashedSubpackets", "LLibOrgBouncycastleOpenpgpPGPSignatureSubpacketVector;", "setUnhashedSubpackets", "generateOnePassVersion", "Z", "generateCertification", "LNSString;LLibOrgBouncycastleOpenpgpPGPPublicKey;", "LLibOrgBouncycastleOpenpgpPGPUserAttributeSubpacketVector;LLibOrgBouncycastleOpenpgpPGPPublicKey;", "LLibOrgBouncycastleOpenpgpPGPPublicKey;LLibOrgBouncycastleOpenpgpPGPPublicKey;", "LLibOrgBouncycastleOpenpgpPGPPublicKey;", "getEncodedPublicKey", "packetPresent", "[LLibOrgBouncycastleBcpgSignatureSubpacket;I", "insertSubpacket", "[LLibOrgBouncycastleBcpgSignatureSubpacket;LLibOrgBouncycastleBcpgSignatureSubpacket;", "updateWithIdData", "I[B", "updateWithPublicKey" };
  static const J2ObjcClassInfo _LibOrgBouncycastleOpenpgpPGPSignatureGenerator = { "PGPSignatureGenerator", "lib.org.bouncycastle.openpgp", ptrTable, methods, fields, 7, 0x1, 20, 8, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleOpenpgpPGPSignatureGenerator;
}

@end

void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder> contentSignerBuilder) {
  NSObject_init(self);
  self->unhashed_ = [IOSObjectArray newArrayWithLength:0 type:LibOrgBouncycastleBcpgSignatureSubpacket_class_()];
  self->hashed_ = [IOSObjectArray newArrayWithLength:0 type:LibOrgBouncycastleBcpgSignatureSubpacket_class_()];
  self->providedKeyAlgorithm_ = -1;
  self->contentSignerBuilder_ = contentSignerBuilder;
}

LibOrgBouncycastleOpenpgpPGPSignatureGenerator *new_LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder> contentSignerBuilder) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_, contentSignerBuilder)
}

LibOrgBouncycastleOpenpgpPGPSignatureGenerator *create_LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(id<LibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder> contentSignerBuilder) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleOpenpgpPGPSignatureGenerator, initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_, contentSignerBuilder)
}

void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_byteUpdateWithByte_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, jbyte b) {
  @try {
    [((JavaIoOutputStream *) nil_chk(self->sigOut_)) writeWithInt:b];
  }
  @catch (JavaIoIOException *e) {
    @throw new_LibOrgBouncycastleOpenpgpPGPRuntimeOperationException_initWithNSString_withJavaLangThrowable_([e getMessage], e);
  }
}

void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_blockUpdateWithByteArray_withInt_withInt_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSByteArray *block, jint off, jint len) {
  @try {
    [((JavaIoOutputStream *) nil_chk(self->sigOut_)) writeWithByteArray:block withInt:off withInt:len];
  }
  @catch (JavaIoIOException *e) {
    @throw new_LibOrgBouncycastleOpenpgpPGPRuntimeOperationException_initWithNSString_withJavaLangThrowable_([e getMessage], e);
  }
}

IOSByteArray *LibOrgBouncycastleOpenpgpPGPSignatureGenerator_getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, LibOrgBouncycastleOpenpgpPGPPublicKey *pubKey) {
  IOSByteArray *keyBytes;
  @try {
    keyBytes = [((LibOrgBouncycastleBcpgPublicKeyPacket *) nil_chk(((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(pubKey))->publicPk_)) getEncodedContents];
  }
  @catch (JavaIoIOException *e) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_withJavaLangException_(@"exception preparing key.", e);
  }
  return keyBytes;
}

jboolean LibOrgBouncycastleOpenpgpPGPSignatureGenerator_packetPresentWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withInt_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSObjectArray *packets, jint type) {
  for (jint i = 0; i != ((IOSObjectArray *) nil_chk(packets))->size_; i++) {
    if ([((LibOrgBouncycastleBcpgSignatureSubpacket *) nil_chk(IOSObjectArray_Get(packets, i))) getType] == type) {
      return true;
    }
  }
  return false;
}

IOSObjectArray *LibOrgBouncycastleOpenpgpPGPSignatureGenerator_insertSubpacketWithLibOrgBouncycastleBcpgSignatureSubpacketArray_withLibOrgBouncycastleBcpgSignatureSubpacket_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, IOSObjectArray *packets, LibOrgBouncycastleBcpgSignatureSubpacket *subpacket) {
  IOSObjectArray *tmp = [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(packets))->size_ + 1 type:LibOrgBouncycastleBcpgSignatureSubpacket_class_()];
  (void) IOSObjectArray_Set(tmp, 0, subpacket);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(packets, 0, tmp, 1, packets->size_);
  return tmp;
}

void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithIdDataWithInt_withByteArray_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, jint header, IOSByteArray *idBytes) {
  [self updateWithByte:(jbyte) header];
  [self updateWithByte:(jbyte) (JreRShift32(((IOSByteArray *) nil_chk(idBytes))->size_, 24))];
  [self updateWithByte:(jbyte) (JreRShift32(idBytes->size_, 16))];
  [self updateWithByte:(jbyte) (JreRShift32(idBytes->size_, 8))];
  [self updateWithByte:(jbyte) (idBytes->size_)];
  [self updateWithByteArray:idBytes];
}

void LibOrgBouncycastleOpenpgpPGPSignatureGenerator_updateWithPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(LibOrgBouncycastleOpenpgpPGPSignatureGenerator *self, LibOrgBouncycastleOpenpgpPGPPublicKey *key) {
  IOSByteArray *keyBytes = LibOrgBouncycastleOpenpgpPGPSignatureGenerator_getEncodedPublicKeyWithLibOrgBouncycastleOpenpgpPGPPublicKey_(self, key);
  [self updateWithByte:(jbyte) (jint) 0x99];
  [self updateWithByte:(jbyte) (JreRShift32(((IOSByteArray *) nil_chk(keyBytes))->size_, 8))];
  [self updateWithByte:(jbyte) (keyBytes->size_)];
  [self updateWithByteArray:keyBytes];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleOpenpgpPGPSignatureGenerator)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/generators/OpenBSDBCrypt.java
//

#include "Arrays.h"
#include "BCrypt.h"
#include "DataLengthException.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "OpenBSDBCrypt.h"
#include "Strings.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/System.h"
#include "java/util/HashSet.h"
#include "java/util/Set.h"

@interface LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt ()

+ (NSString *)createBcryptStringWithNSString:(NSString *)version_
                               withByteArray:(IOSByteArray *)password
                               withByteArray:(IOSByteArray *)salt
                                     withInt:(jint)cost;

+ (NSString *)encodeDataWithByteArray:(IOSByteArray *)data;

+ (IOSByteArray *)decodeSaltStringWithNSString:(NSString *)saltString;

@end

inline IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_get_encodingTable(void);
static IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, encodingTable, IOSByteArray *)

inline IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_get_decodingTable(void);
static IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, decodingTable, IOSByteArray *)

inline NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_get_defaultVersion(void);
static NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_defaultVersion = @"2y";
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, defaultVersion, NSString *)

inline id<JavaUtilSet> LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_get_allowedVersions(void);
static id<JavaUtilSet> LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, allowedVersions, id<JavaUtilSet>)

__attribute__((unused)) static NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_createBcryptStringWithNSString_withByteArray_withByteArray_withInt_(NSString *version_, IOSByteArray *password, IOSByteArray *salt, jint cost);

__attribute__((unused)) static NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodeDataWithByteArray_(IOSByteArray *data);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodeSaltStringWithNSString_(NSString *saltString);

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt)

@implementation LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (NSString *)createBcryptStringWithNSString:(NSString *)version_
                               withByteArray:(IOSByteArray *)password
                               withByteArray:(IOSByteArray *)salt
                                     withInt:(jint)cost {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_createBcryptStringWithNSString_withByteArray_withByteArray_withInt_(version_, password, salt, cost);
}

+ (NSString *)generateWithCharArray:(IOSCharArray *)password
                      withByteArray:(IOSByteArray *)salt
                            withInt:(jint)cost {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithCharArray_withByteArray_withInt_(password, salt, cost);
}

+ (NSString *)generateWithNSString:(NSString *)version_
                     withCharArray:(IOSCharArray *)password
                     withByteArray:(IOSByteArray *)salt
                           withInt:(jint)cost {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithNSString_withCharArray_withByteArray_withInt_(version_, password, salt, cost);
}

+ (jboolean)checkPasswordWithNSString:(NSString *)bcryptString
                        withCharArray:(IOSCharArray *)password {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_checkPasswordWithNSString_withCharArray_(bcryptString, password);
}

+ (NSString *)encodeDataWithByteArray:(IOSByteArray *)data {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodeDataWithByteArray_(data);
}

+ (IOSByteArray *)decodeSaltStringWithNSString:(NSString *)saltString {
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodeSaltStringWithNSString_(saltString);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 2, 3, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 2, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 5, 6, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 7, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 9, 10, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(createBcryptStringWithNSString:withByteArray:withByteArray:withInt:);
  methods[2].selector = @selector(generateWithCharArray:withByteArray:withInt:);
  methods[3].selector = @selector(generateWithNSString:withCharArray:withByteArray:withInt:);
  methods[4].selector = @selector(checkPasswordWithNSString:withCharArray:);
  methods[5].selector = @selector(encodeDataWithByteArray:);
  methods[6].selector = @selector(decodeSaltStringWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encodingTable", "[B", .constantValue.asLong = 0, 0x1a, -1, 11, -1, -1 },
    { "decodingTable", "[B", .constantValue.asLong = 0, 0x1a, -1, 12, -1, -1 },
    { "defaultVersion", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "allowedVersions", "LJavaUtilSet;", .constantValue.asLong = 0, 0x1a, -1, 14, 15, -1 },
  };
  static const void *ptrTable[] = { "createBcryptString", "LNSString;[B[BI", "generate", "[C[BI", "LNSString;[C[BI", "checkPassword", "LNSString;[C", "encodeData", "[B", "decodeSaltString", "LNSString;", &LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable, &LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, &LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_defaultVersion, &LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions, "Ljava/util/Set<Ljava/lang/String;>;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt = { "OpenBSDBCrypt", "lib.org.bouncycastle.crypto.generators", ptrTable, methods, fields, 7, 0x1, 7, 4, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt class]) {
    LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) '.', (jbyte) '/', (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G', (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N', (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U', (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g', (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n', (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u', (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z', (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9' } count:64];
    LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable = [IOSByteArray newArrayWithLength:128];
    LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions = new_JavaUtilHashSet_init();
    {
      [LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions addWithId:@"2a"];
      [LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions addWithId:@"2y"];
      [LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions addWithId:@"2b"];
      for (jint i = 0; i < LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable->size_; i++) {
        *IOSByteArray_GetRef(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, i) = (jbyte) (jint) 0xff;
      }
      for (jint i = 0; i < LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable->size_; i++) {
        *IOSByteArray_GetRef(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable, i)) = (jbyte) i;
      }
    }
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt)
  }
}

@end

void LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_init(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt *self) {
  NSObject_init(self);
}

LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt *new_LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, init)
}

LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt *create_LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt, init)
}

NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_createBcryptStringWithNSString_withByteArray_withByteArray_withInt_(NSString *version_, IOSByteArray *password, IOSByteArray *salt, jint cost) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  if (![((id<JavaUtilSet>) nil_chk(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions)) containsWithId:version_]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$", @"Version ", version_, @" is not accepted by this implementation."));
  }
  JavaLangStringBuffer *sb = new_JavaLangStringBuffer_initWithInt_(60);
  (void) [sb appendWithChar:'$'];
  (void) [sb appendWithNSString:version_];
  (void) [sb appendWithChar:'$'];
  (void) [sb appendWithNSString:cost < 10 ? (JreStrcat("CI", '0', cost)) : JavaLangInteger_toStringWithInt_(cost)];
  (void) [sb appendWithChar:'$'];
  (void) [sb appendWithNSString:LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodeDataWithByteArray_(salt)];
  IOSByteArray *key = LibOrgBouncycastleCryptoGeneratorsBCrypt_generateWithByteArray_withByteArray_withInt_(password, salt, cost);
  (void) [sb appendWithNSString:LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodeDataWithByteArray_(key)];
  return [sb description];
}

NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithCharArray_withByteArray_withInt_(IOSCharArray *password, IOSByteArray *salt, jint cost) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  return LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithNSString_withCharArray_withByteArray_withInt_(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_defaultVersion, password, salt, cost);
}

NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithNSString_withCharArray_withByteArray_withInt_(NSString *version_, IOSCharArray *password, IOSByteArray *salt, jint cost) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  if (![((id<JavaUtilSet>) nil_chk(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions)) containsWithId:version_]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$", @"Version ", version_, @" is not accepted by this implementation."));
  }
  if (password == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Password required.");
  }
  if (salt == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Salt required.");
  }
  else if (salt->size_ != 16) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(JreStrcat("$I", @"16 byte salt required: ", salt->size_));
  }
  if (cost < 4 || cost > 31) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid cost factor.");
  }
  IOSByteArray *psw = LibOrgBouncycastleUtilStrings_toUTF8ByteArrayWithCharArray_(password);
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(psw))->size_ >= 72 ? 72 : psw->size_ + 1];
  if (tmp->size_ > psw->size_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(psw, 0, tmp, 0, psw->size_);
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(psw, 0, tmp, 0, tmp->size_);
  }
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(psw, (jbyte) 0);
  NSString *rv = LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_createBcryptStringWithNSString_withByteArray_withByteArray_withInt_(version_, tmp, salt, cost);
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(tmp, (jbyte) 0);
  return rv;
}

jboolean LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_checkPasswordWithNSString_withCharArray_(NSString *bcryptString, IOSCharArray *password) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  if ([((NSString *) nil_chk(bcryptString)) java_length] != 60) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(JreStrcat("$I$", @"Bcrypt String length: ", [bcryptString java_length], @", 60 required."));
  }
  if ([bcryptString charAtWithInt:0] != '$' || [bcryptString charAtWithInt:3] != '$' || [bcryptString charAtWithInt:6] != '$') {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid Bcrypt String format.");
  }
  NSString *version_ = [bcryptString java_substring:1 endIndex:3];
  if (![((id<JavaUtilSet>) nil_chk(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_allowedVersions)) containsWithId:version_]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$", @"Bcrypt version '", version_, @"' is not supported by this implementation"));
  }
  jint cost = 0;
  NSString *costStr = [bcryptString java_substring:4 endIndex:6];
  @try {
    cost = JavaLangInteger_parseIntWithNSString_(costStr);
  }
  @catch (JavaLangNumberFormatException *nfe) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"Invalid cost factor: ", costStr));
  }
  if (cost < 4 || cost > 31) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$", @"Invalid cost factor: ", cost, @", 4 < cost < 31 expected."));
  }
  if (password == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Missing password.");
  }
  IOSByteArray *salt = LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodeSaltStringWithNSString_([bcryptString java_substring:[bcryptString java_lastIndexOf:'$'] + 1 endIndex:[bcryptString java_length] - 31]);
  NSString *newBcryptString = LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_generateWithNSString_withCharArray_withByteArray_withInt_(version_, password, salt, cost);
  return [bcryptString isEqual:newBcryptString];
}

NSString *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodeDataWithByteArray_(IOSByteArray *data) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  if (((IOSByteArray *) nil_chk(data))->size_ != 24 && data->size_ != 16) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(JreStrcat("$I$", @"Invalid length: ", data->size_, @", 24 for key or 16 for salt expected"));
  }
  jboolean salt = false;
  if (data->size_ == 16) {
    salt = true;
    IOSByteArray *tmp = [IOSByteArray newArrayWithLength:18];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, tmp, 0, data->size_);
    data = tmp;
  }
  else {
    *IOSByteArray_GetRef(data, data->size_ - 1) = (jbyte) 0;
  }
  JavaIoByteArrayOutputStream *out = new_JavaIoByteArrayOutputStream_init();
  jint len = data->size_;
  jint a1;
  jint a2;
  jint a3;
  jint i;
  for (i = 0; i < len; i += 3) {
    a1 = IOSByteArray_Get(data, i) & (jint) 0xff;
    a2 = IOSByteArray_Get(data, i + 1) & (jint) 0xff;
    a3 = IOSByteArray_Get(data, i + 2) & (jint) 0xff;
    [out writeWithInt:IOSByteArray_Get(nil_chk(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable), (JreURShift32(a1, 2)) & (jint) 0x3f)];
    [out writeWithInt:IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable, ((JreLShift32(a1, 4)) | (JreURShift32(a2, 4))) & (jint) 0x3f)];
    [out writeWithInt:IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable, ((JreLShift32(a2, 2)) | (JreURShift32(a3, 6))) & (jint) 0x3f)];
    [out writeWithInt:IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_encodingTable, a3 & (jint) 0x3f)];
  }
  NSString *result = LibOrgBouncycastleUtilStrings_fromByteArrayWithByteArray_([out toByteArray]);
  if (salt == true) {
    return [((NSString *) nil_chk(result)) java_substring:0 endIndex:22];
  }
  else {
    return [((NSString *) nil_chk(result)) java_substring:0 endIndex:[result java_length] - 1];
  }
}

IOSByteArray *LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodeSaltStringWithNSString_(NSString *saltString) {
  LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_initialize();
  IOSCharArray *saltChars = [((NSString *) nil_chk(saltString)) java_toCharArray];
  JavaIoByteArrayOutputStream *out = new_JavaIoByteArrayOutputStream_initWithInt_(16);
  jbyte b1;
  jbyte b2;
  jbyte b3;
  jbyte b4;
  if (((IOSCharArray *) nil_chk(saltChars))->size_ != 22) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(JreStrcat("$I$", @"Invalid base64 salt length: ", saltChars->size_, @" , 22 required."));
  }
  for (jint i = 0; i < saltChars->size_; i++) {
    jint value = IOSCharArray_Get(saltChars, i);
    if (value > 122 || value < 46 || (value > 57 && value < 65)) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Salt string contains invalid character: ", value));
    }
  }
  IOSCharArray *tmp = [IOSCharArray newArrayWithLength:22 + 2];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(saltChars, 0, tmp, 0, saltChars->size_);
  saltChars = tmp;
  jint len = saltChars->size_;
  for (jint i = 0; i < len; i += 4) {
    b1 = IOSByteArray_Get(nil_chk(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable), IOSCharArray_Get(saltChars, i));
    b2 = IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, IOSCharArray_Get(saltChars, i + 1));
    b3 = IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, IOSCharArray_Get(saltChars, i + 2));
    b4 = IOSByteArray_Get(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt_decodingTable, IOSCharArray_Get(saltChars, i + 3));
    [out writeWithInt:(JreLShift32(b1, 2)) | (JreRShift32(b2, 4))];
    [out writeWithInt:(JreLShift32(b2, 4)) | (JreRShift32(b3, 2))];
    [out writeWithInt:(JreLShift32(b3, 6)) | b4];
  }
  IOSByteArray *saltBytes = [out toByteArray];
  IOSByteArray *tmpSalt = [IOSByteArray newArrayWithLength:16];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(saltBytes, 0, tmpSalt, 0, tmpSalt->size_);
  saltBytes = tmpSalt;
  return saltBytes;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoGeneratorsOpenBSDBCrypt)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/engines/IDEAEngine.java
//

#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IDEAEngine.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoEnginesIDEAEngine () {
 @public
  IOSIntArray *workingKey_;
}

- (jint)bytesToWordWithByteArray:(IOSByteArray *)inArg
                         withInt:(jint)inOff;

- (void)wordToBytesWithInt:(jint)word
             withByteArray:(IOSByteArray *)outArg
                   withInt:(jint)outOff;

- (jint)mulWithInt:(jint)x
           withInt:(jint)y;

- (void)ideaFuncWithIntArray:(IOSIntArray *)workingKey
               withByteArray:(IOSByteArray *)inArg
                     withInt:(jint)inOff
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff;

- (IOSIntArray *)expandKeyWithByteArray:(IOSByteArray *)uKey;

- (jint)mulInvWithInt:(jint)x;

- (IOSIntArray *)invertKeyWithIntArray:(IOSIntArray *)inKey;

- (IOSIntArray *)generateWorkingKeyWithBoolean:(jboolean)forEncryption
                                 withByteArray:(IOSByteArray *)userKey;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesIDEAEngine, workingKey_, IOSIntArray *)

inline jint LibOrgBouncycastleCryptoEnginesIDEAEngine_get_MASK(void);
#define LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK 65535
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoEnginesIDEAEngine, MASK, jint)

inline jint LibOrgBouncycastleCryptoEnginesIDEAEngine_get_BASE(void);
#define LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE 65537
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoEnginesIDEAEngine, BASE, jint)

__attribute__((unused)) static jint LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSByteArray *inArg, jint inOff);

__attribute__((unused)) static void LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint word, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint x, jint y);

__attribute__((unused)) static void LibOrgBouncycastleCryptoEnginesIDEAEngine_ideaFuncWithIntArray_withByteArray_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSIntArray *workingKey, IOSByteArray *inArg, jint inOff, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_expandKeyWithByteArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSByteArray *uKey);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint x);

__attribute__((unused)) static IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_invertKeyWithIntArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSIntArray *inKey);

__attribute__((unused)) static IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_generateWorkingKeyWithBoolean_withByteArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jboolean forEncryption, IOSByteArray *userKey);

@implementation LibOrgBouncycastleCryptoEnginesIDEAEngine

+ (jint)BLOCK_SIZE {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoEnginesIDEAEngine_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsKeyParameter class]]) {
    workingKey_ = LibOrgBouncycastleCryptoEnginesIDEAEngine_generateWorkingKeyWithBoolean_withByteArray_(self, forEncryption, [((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(((LibOrgBouncycastleCryptoParamsKeyParameter *) params))) getKey]);
    return;
  }
  @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"invalid parameter passed to IDEA init - ", [[((id<LibOrgBouncycastleCryptoCipherParameters>) nil_chk(params)) java_getClass] getName]));
}

- (NSString *)getAlgorithmName {
  return @"IDEA";
}

- (jint)getBlockSize {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE;
}

- (jint)processBlockWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (workingKey_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"IDEA engine not initialised");
  }
  if ((inOff + LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE) > ((IOSByteArray *) nil_chk(inArg))->size_) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  if ((outOff + LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE) > ((IOSByteArray *) nil_chk(outArg))->size_) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"output buffer too short");
  }
  LibOrgBouncycastleCryptoEnginesIDEAEngine_ideaFuncWithIntArray_withByteArray_withInt_withByteArray_withInt_(self, workingKey_, inArg, inOff, outArg, outOff);
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE;
}

- (void)reset {
}

- (jint)bytesToWordWithByteArray:(IOSByteArray *)inArg
                         withInt:(jint)inOff {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, inArg, inOff);
}

- (void)wordToBytesWithInt:(jint)word
             withByteArray:(IOSByteArray *)outArg
                   withInt:(jint)outOff {
  LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(self, word, outArg, outOff);
}

- (jint)mulWithInt:(jint)x
           withInt:(jint)y {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x, y);
}

- (void)ideaFuncWithIntArray:(IOSIntArray *)workingKey
               withByteArray:(IOSByteArray *)inArg
                     withInt:(jint)inOff
               withByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  LibOrgBouncycastleCryptoEnginesIDEAEngine_ideaFuncWithIntArray_withByteArray_withInt_withByteArray_withInt_(self, workingKey, inArg, inOff, outArg, outOff);
}

- (IOSIntArray *)expandKeyWithByteArray:(IOSByteArray *)uKey {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_expandKeyWithByteArray_(self, uKey);
}

- (jint)mulInvWithInt:(jint)x {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, x);
}

- (jint)addInvWithInt:(jint)x {
  return (0 - x) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
}

- (IOSIntArray *)invertKeyWithIntArray:(IOSIntArray *)inKey {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_invertKeyWithIntArray_(self, inKey);
}

- (IOSIntArray *)generateWorkingKeyWithBoolean:(jboolean)forEncryption
                                 withByteArray:(IOSByteArray *)userKey {
  return LibOrgBouncycastleCryptoEnginesIDEAEngine_generateWorkingKeyWithBoolean_withByteArray_(self, forEncryption, userKey);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 10, 11, -1, -1, -1, -1 },
    { NULL, "[I", 0x2, 12, 13, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 14, 15, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 16, 15, -1, -1, -1, -1 },
    { NULL, "[I", 0x2, 17, 18, -1, -1, -1, -1 },
    { NULL, "[I", 0x2, 19, 20, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[2].selector = @selector(getAlgorithmName);
  methods[3].selector = @selector(getBlockSize);
  methods[4].selector = @selector(processBlockWithByteArray:withInt:withByteArray:withInt:);
  methods[5].selector = @selector(reset);
  methods[6].selector = @selector(bytesToWordWithByteArray:withInt:);
  methods[7].selector = @selector(wordToBytesWithInt:withByteArray:withInt:);
  methods[8].selector = @selector(mulWithInt:withInt:);
  methods[9].selector = @selector(ideaFuncWithIntArray:withByteArray:withInt:withByteArray:withInt:);
  methods[10].selector = @selector(expandKeyWithByteArray:);
  methods[11].selector = @selector(mulInvWithInt:);
  methods[12].selector = @selector(addInvWithInt:);
  methods[13].selector = @selector(invertKeyWithIntArray:);
  methods[14].selector = @selector(generateWorkingKeyWithBoolean:withByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BLOCK_SIZE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEnginesIDEAEngine_BLOCK_SIZE, 0x1c, -1, -1, -1, -1 },
    { "workingKey_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "MASK", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK, 0x1a, -1, -1, -1, -1 },
    { "BASE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "processBlock", "[BI[BI", "bytesToWord", "[BI", "wordToBytes", "I[BI", "mul", "II", "ideaFunc", "[I[BI[BI", "expandKey", "[B", "mulInv", "I", "addInv", "invertKey", "[I", "generateWorkingKey", "Z[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEnginesIDEAEngine = { "IDEAEngine", "lib.org.bouncycastle.crypto.engines", ptrTable, methods, fields, 7, 0x1, 15, 4, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEnginesIDEAEngine;
}

@end

void LibOrgBouncycastleCryptoEnginesIDEAEngine_init(LibOrgBouncycastleCryptoEnginesIDEAEngine *self) {
  NSObject_init(self);
  self->workingKey_ = nil;
}

LibOrgBouncycastleCryptoEnginesIDEAEngine *new_LibOrgBouncycastleCryptoEnginesIDEAEngine_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEnginesIDEAEngine, init)
}

LibOrgBouncycastleCryptoEnginesIDEAEngine *create_LibOrgBouncycastleCryptoEnginesIDEAEngine_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEnginesIDEAEngine, init)
}

jint LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSByteArray *inArg, jint inOff) {
  return ((JreLShift32(IOSByteArray_Get(nil_chk(inArg), inOff), 8)) & (jint) 0xff00) + (IOSByteArray_Get(inArg, inOff + 1) & (jint) 0xff);
}

void LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint word, IOSByteArray *outArg, jint outOff) {
  *IOSByteArray_GetRef(nil_chk(outArg), outOff) = (jbyte) (JreURShift32(word, 8));
  *IOSByteArray_GetRef(outArg, outOff + 1) = (jbyte) word;
}

jint LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint x, jint y) {
  if (x == 0) {
    x = (LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE - y);
  }
  else if (y == 0) {
    x = (LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE - x);
  }
  else {
    jint p = x * y;
    y = p & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    x = JreURShift32(p, 16);
    x = y - x + ((y < x) ? 1 : 0);
  }
  return x & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
}

void LibOrgBouncycastleCryptoEnginesIDEAEngine_ideaFuncWithIntArray_withByteArray_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSIntArray *workingKey, IOSByteArray *inArg, jint inOff, IOSByteArray *outArg, jint outOff) {
  jint x0;
  jint x1;
  jint x2;
  jint x3;
  jint t0;
  jint t1;
  jint keyOff = 0;
  x0 = LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, inArg, inOff);
  x1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, inArg, inOff + 2);
  x2 = LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, inArg, inOff + 4);
  x3 = LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, inArg, inOff + 6);
  for (jint round = 0; round < 8; round++) {
    x0 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x0, IOSIntArray_Get(nil_chk(workingKey), keyOff++));
    x1 += IOSIntArray_Get(workingKey, keyOff++);
    x1 &= LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    x2 += IOSIntArray_Get(workingKey, keyOff++);
    x2 &= LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    x3 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x3, IOSIntArray_Get(workingKey, keyOff++));
    t0 = x1;
    t1 = x2;
    x2 ^= x0;
    x1 ^= x3;
    x2 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x2, IOSIntArray_Get(workingKey, keyOff++));
    x1 += x2;
    x1 &= LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    x1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x1, IOSIntArray_Get(workingKey, keyOff++));
    x2 += x1;
    x2 &= LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    x0 ^= x1;
    x3 ^= x2;
    x1 ^= t1;
    x2 ^= t0;
  }
  LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(self, LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x0, IOSIntArray_Get(nil_chk(workingKey), keyOff++)), outArg, outOff);
  LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(self, x2 + IOSIntArray_Get(workingKey, keyOff++), outArg, outOff + 2);
  LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(self, x1 + IOSIntArray_Get(workingKey, keyOff++), outArg, outOff + 4);
  LibOrgBouncycastleCryptoEnginesIDEAEngine_wordToBytesWithInt_withByteArray_withInt_(self, LibOrgBouncycastleCryptoEnginesIDEAEngine_mulWithInt_withInt_(self, x3, IOSIntArray_Get(workingKey, keyOff)), outArg, outOff + 6);
}

IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_expandKeyWithByteArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSByteArray *uKey) {
  IOSIntArray *key = [IOSIntArray newArrayWithLength:52];
  if (((IOSByteArray *) nil_chk(uKey))->size_ < 16) {
    IOSByteArray *tmp = [IOSByteArray newArrayWithLength:16];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(uKey, 0, tmp, tmp->size_ - uKey->size_, uKey->size_);
    uKey = tmp;
  }
  for (jint i = 0; i < 8; i++) {
    *IOSIntArray_GetRef(key, i) = LibOrgBouncycastleCryptoEnginesIDEAEngine_bytesToWordWithByteArray_withInt_(self, uKey, i * 2);
  }
  for (jint i = 8; i < 52; i++) {
    if ((i & 7) < 6) {
      *IOSIntArray_GetRef(key, i) = ((JreLShift32((IOSIntArray_Get(key, i - 7) & 127), 9)) | (JreRShift32(IOSIntArray_Get(key, i - 6), 7))) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    }
    else if ((i & 7) == 6) {
      *IOSIntArray_GetRef(key, i) = ((JreLShift32((IOSIntArray_Get(key, i - 7) & 127), 9)) | (JreRShift32(IOSIntArray_Get(key, i - 14), 7))) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    }
    else {
      *IOSIntArray_GetRef(key, i) = ((JreLShift32((IOSIntArray_Get(key, i - 15) & 127), 9)) | (JreRShift32(IOSIntArray_Get(key, i - 14), 7))) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    }
  }
  return key;
}

jint LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jint x) {
  jint t0;
  jint t1;
  jint q;
  jint y;
  if (x < 2) {
    return x;
  }
  t0 = 1;
  t1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE / x;
  y = LibOrgBouncycastleCryptoEnginesIDEAEngine_BASE % x;
  while (y != 1) {
    q = x / y;
    x = x % y;
    t0 = (t0 + (t1 * q)) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
    if (x == 1) {
      return t0;
    }
    q = y / x;
    y = y % x;
    t1 = (t1 + (t0 * q)) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
  }
  return (1 - t1) & LibOrgBouncycastleCryptoEnginesIDEAEngine_MASK;
}

IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_invertKeyWithIntArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, IOSIntArray *inKey) {
  jint t1;
  jint t2;
  jint t3;
  jint t4;
  jint p = 52;
  IOSIntArray *key = [IOSIntArray newArrayWithLength:52];
  jint inOff = 0;
  t1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(nil_chk(inKey), inOff++));
  t2 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
  t3 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
  t4 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(inKey, inOff++));
  *IOSIntArray_GetRef(key, --p) = t4;
  *IOSIntArray_GetRef(key, --p) = t3;
  *IOSIntArray_GetRef(key, --p) = t2;
  *IOSIntArray_GetRef(key, --p) = t1;
  for (jint round = 1; round < 8; round++) {
    t1 = IOSIntArray_Get(inKey, inOff++);
    t2 = IOSIntArray_Get(inKey, inOff++);
    *IOSIntArray_GetRef(key, --p) = t2;
    *IOSIntArray_GetRef(key, --p) = t1;
    t1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(inKey, inOff++));
    t2 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
    t3 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
    t4 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(inKey, inOff++));
    *IOSIntArray_GetRef(key, --p) = t4;
    *IOSIntArray_GetRef(key, --p) = t2;
    *IOSIntArray_GetRef(key, --p) = t3;
    *IOSIntArray_GetRef(key, --p) = t1;
  }
  t1 = IOSIntArray_Get(inKey, inOff++);
  t2 = IOSIntArray_Get(inKey, inOff++);
  *IOSIntArray_GetRef(key, --p) = t2;
  *IOSIntArray_GetRef(key, --p) = t1;
  t1 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(inKey, inOff++));
  t2 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
  t3 = [self addInvWithInt:IOSIntArray_Get(inKey, inOff++)];
  t4 = LibOrgBouncycastleCryptoEnginesIDEAEngine_mulInvWithInt_(self, IOSIntArray_Get(inKey, inOff));
  *IOSIntArray_GetRef(key, --p) = t4;
  *IOSIntArray_GetRef(key, --p) = t3;
  *IOSIntArray_GetRef(key, --p) = t2;
  *IOSIntArray_GetRef(key, --p) = t1;
  return key;
}

IOSIntArray *LibOrgBouncycastleCryptoEnginesIDEAEngine_generateWorkingKeyWithBoolean_withByteArray_(LibOrgBouncycastleCryptoEnginesIDEAEngine *self, jboolean forEncryption, IOSByteArray *userKey) {
  if (forEncryption) {
    return LibOrgBouncycastleCryptoEnginesIDEAEngine_expandKeyWithByteArray_(self, userKey);
  }
  else {
    return LibOrgBouncycastleCryptoEnginesIDEAEngine_invertKeyWithIntArray_(self, LibOrgBouncycastleCryptoEnginesIDEAEngine_expandKeyWithByteArray_(self, userKey));
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoEnginesIDEAEngine)

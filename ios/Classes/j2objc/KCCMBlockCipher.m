//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/modes/KCCMBlockCipher.java
//

#include "AEADParameters.h"
#include "Arrays.h"
#include "BlockCipher.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "KCCMBlockCipher.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "ParametersWithIV.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/System.h"

@class LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;

@interface LibOrgBouncycastleCryptoModesKCCMBlockCipher () {
 @public
  id<LibOrgBouncycastleCryptoBlockCipher> engine_;
  jint macSize_;
  jboolean forEncryption_;
  IOSByteArray *initialAssociatedText_;
  IOSByteArray *mac_;
  IOSByteArray *macBlock_;
  IOSByteArray *nonce_;
  IOSByteArray *G1_;
  IOSByteArray *buffer_;
  IOSByteArray *s_;
  IOSByteArray *counter_;
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *associatedText_;
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *data_;
  jint Nb__;
}

- (void)setNbWithInt:(jint)Nb;

- (void)processAADWithByteArray:(IOSByteArray *)assocText
                        withInt:(jint)assocOff
                        withInt:(jint)assocLen
                        withInt:(jint)dataLen;

- (void)ProcessBlockWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outOff;

- (void)CalculateMacWithByteArray:(IOSByteArray *)authText
                          withInt:(jint)authOff
                          withInt:(jint)len;

- (void)intToBytesWithInt:(jint)num
            withByteArray:(IOSByteArray *)outBytes
                  withInt:(jint)outOff;

- (jbyte)getFlagWithBoolean:(jboolean)authTextPresents
                    withInt:(jint)macSize;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, engine_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, mac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, G1_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, s_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, counter_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, associatedText_, LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKCCMBlockCipher, data_, LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *)

inline jint LibOrgBouncycastleCryptoModesKCCMBlockCipher_get_BYTES_IN_INT(void);
#define LibOrgBouncycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT 4
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesKCCMBlockCipher, BYTES_IN_INT, jint)

inline jint LibOrgBouncycastleCryptoModesKCCMBlockCipher_get_BITS_IN_BYTE(void);
#define LibOrgBouncycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE 8
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesKCCMBlockCipher, BITS_IN_BYTE, jint)

inline jint LibOrgBouncycastleCryptoModesKCCMBlockCipher_get_MAX_MAC_BIT_LENGTH(void);
#define LibOrgBouncycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH 512
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesKCCMBlockCipher, MAX_MAC_BIT_LENGTH, jint)

inline jint LibOrgBouncycastleCryptoModesKCCMBlockCipher_get_MIN_MAC_BIT_LENGTH(void);
#define LibOrgBouncycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH 64
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesKCCMBlockCipher, MIN_MAC_BIT_LENGTH, jint)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_setNbWithInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jint Nb);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *assocText, jint assocOff, jint assocLen, jint dataLen);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, IOSByteArray *output, jint outOff);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jint num, IOSByteArray *outBytes, jint outOff);

__attribute__((unused)) static jbyte LibOrgBouncycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jboolean authTextPresents, jint macSize);

@interface LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream : JavaIoByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher:(LibOrgBouncycastleCryptoModesKCCMBlockCipher *)outer$;

- (IOSByteArray *)getBuffer;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$);

__attribute__((unused)) static LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$);

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)

@implementation LibOrgBouncycastleCryptoModesKCCMBlockCipher

- (void)setNbWithInt:(jint)Nb {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_setNbWithInt_(self, Nb);
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, engine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine
                                                    withInt:(jint)nB {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, engine, nB);
  return self;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  id<LibOrgBouncycastleCryptoCipherParameters> cipherParameters;
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]]) {
    LibOrgBouncycastleCryptoParamsAEADParameters *parameters = (LibOrgBouncycastleCryptoParamsAEADParameters *) params;
    if ([((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(parameters)) getMacSize] > LibOrgBouncycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH || [parameters getMacSize] < LibOrgBouncycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH || [parameters getMacSize] % 8 != 0) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid mac size specified");
    }
    nonce_ = [parameters getNonce];
    macSize_ = [parameters getMacSize] / LibOrgBouncycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE;
    initialAssociatedText_ = [parameters getAssociatedText];
    cipherParameters = [parameters getKey];
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    nonce_ = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) params))) getIV];
    macSize_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    initialAssociatedText_ = nil;
    cipherParameters = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) params))) getParameters];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid parameters specified");
  }
  self->mac_ = [IOSByteArray newArrayWithLength:macSize_];
  self->forEncryption_ = forEncryption;
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:cipherParameters];
  *IOSByteArray_GetRef(nil_chk(counter_), 0) = (jint) 0x01;
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getAlgorithmName], @"/KCCM");
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return engine_;
}

- (void)processAADByteWithByte:(jbyte)inArg {
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithInt:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithByteArray:inArg withInt:inOff withInt:len];
}

- (void)processAADWithByteArray:(IOSByteArray *)assocText
                        withInt:(jint)assocOff
                        withInt:(jint)assocLen
                        withInt:(jint)dataLen {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, assocText, assocOff, assocLen, dataLen);
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithInt:inArg];
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)inLen
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + inLen)) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithByteArray:inArg withInt:inOff withInt:inLen];
  return 0;
}

- (jint)processPacketWithByteArray:(IOSByteArray *)inArg
                           withInt:(jint)inOff
                           withInt:(jint)len
                     withByteArray:(IOSByteArray *)outArg
                           withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ - inOff < len) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  if (((IOSByteArray *) nil_chk(outArg))->size_ - outOff < len) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"output buffer too short");
  }
  if ([((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size] > 0) {
    if (forEncryption_) {
      LibOrgBouncycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) getBuffer], 0, [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size], [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size]);
    }
    else {
      LibOrgBouncycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) getBuffer], 0, [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size], [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] - macSize_);
    }
  }
  if (forEncryption_) {
    if ((len % [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize]) != 0) {
      @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"partial blocks not supported");
    }
    LibOrgBouncycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, inArg, inOff, len);
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:nonce_ withInt:0 withByteArray:s_ withInt:0];
    jint totalLength = len;
    while (totalLength > 0) {
      LibOrgBouncycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, inArg, inOff, len, outArg, outOff);
      totalLength -= [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      inOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      outOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    }
    for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
    for (jint byteIndex = 0; byteIndex < macSize_; byteIndex++) {
      *IOSByteArray_GetRef(outArg, outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(buffer_), byteIndex) ^ IOSByteArray_Get(nil_chk(macBlock_), byteIndex));
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac_, 0, macSize_);
    [self reset];
    return len + macSize_;
  }
  else {
    if ((len - macSize_) % [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize] != 0) {
      @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"partial blocks not supported");
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:nonce_ withInt:0 withByteArray:s_ withInt:0];
    jint blocks = len / [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    for (jint blockNum = 0; blockNum < blocks; blockNum++) {
      LibOrgBouncycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, inArg, inOff, len, outArg, outOff);
      inOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      outOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    }
    if (len > inOff) {
      for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
        *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
      }
      [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
      for (jint byteIndex = 0; byteIndex < macSize_; byteIndex++) {
        *IOSByteArray_GetRef(outArg, outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(buffer_), byteIndex) ^ IOSByteArray_Get(inArg, inOff + byteIndex));
      }
      outOff += macSize_;
    }
    for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(outArg, outOff - macSize_, buffer_, 0, macSize_);
    LibOrgBouncycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, outArg, 0, outOff - macSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac_, 0, macSize_);
    IOSByteArray *calculatedMac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer_, 0, calculatedMac, 0, macSize_);
    if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(mac_, calculatedMac)) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check failed");
    }
    [self reset];
    return len - macSize_;
  }
}

- (void)ProcessBlockWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, input, inOff, len, output, outOff);
}

- (void)CalculateMacWithByteArray:(IOSByteArray *)authText
                          withInt:(jint)authOff
                          withInt:(jint)len {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, authText, authOff, len);
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  jint len = [self processPacketWithByteArray:[((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:[((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] withByteArray:outArg withInt:outOff];
  [self reset];
  return len;
}

- (IOSByteArray *)getMac {
  return LibOrgBouncycastleUtilArrays_cloneWithByteArray_(mac_);
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return len;
}

- (jint)getOutputSizeWithInt:(jint)len {
  return len + macSize_;
}

- (void)reset {
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(G1_, (jbyte) 0);
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(buffer_, (jbyte) 0);
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(counter_, (jbyte) 0);
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(macBlock_, (jbyte) 0);
  *IOSByteArray_GetRef(nil_chk(counter_), 0) = (jint) 0x01;
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) reset];
  [((LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) reset];
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (void)intToBytesWithInt:(jint)num
            withByteArray:(IOSByteArray *)outBytes
                  withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, num, outBytes, outOff);
}

- (jbyte)getFlagWithBoolean:(jboolean)authTextPresents
                    withInt:(jint)macSize {
  return LibOrgBouncycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(self, authTextPresents, macSize);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x2, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 17, 19, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 22, 23, 19, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 24, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 25, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "B", 0x2, 28, 29, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(setNbWithInt:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[2].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withInt:);
  methods[3].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[4].selector = @selector(getAlgorithmName);
  methods[5].selector = @selector(getUnderlyingCipher);
  methods[6].selector = @selector(processAADByteWithByte:);
  methods[7].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[8].selector = @selector(processAADWithByteArray:withInt:withInt:withInt:);
  methods[9].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[10].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[11].selector = @selector(processPacketWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[12].selector = @selector(ProcessBlockWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(CalculateMacWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(doFinalWithByteArray:withInt:);
  methods[15].selector = @selector(getMac);
  methods[16].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[17].selector = @selector(getOutputSizeWithInt:);
  methods[18].selector = @selector(reset);
  methods[19].selector = @selector(intToBytesWithInt:withByteArray:withInt:);
  methods[20].selector = @selector(getFlagWithBoolean:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BYTES_IN_INT", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT, 0x1a, -1, -1, -1, -1 },
    { "BITS_IN_BYTE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE, 0x1a, -1, -1, -1, -1 },
    { "MAX_MAC_BIT_LENGTH", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "MIN_MAC_BIT_LENGTH", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mac_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "G1_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "counter_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "associatedText_", "LLibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "data_", "LLibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "Nb__", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setNb", "I", "LLibOrgBouncycastleCryptoBlockCipher;", "LLibOrgBouncycastleCryptoBlockCipher;I", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "processAADByte", "B", "processAADBytes", "[BII", "processAAD", "[BIII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "processBytes", "[BII[BI", "processPacket", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;", "ProcessBlock", "CalculateMac", "doFinal", "[BI", "getUpdateOutputSize", "getOutputSize", "intToBytes", "I[BI", "getFlag", "ZI", "LLibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesKCCMBlockCipher = { "KCCMBlockCipher", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 21, 18, -1, 30, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesKCCMBlockCipher;
}

@end

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_setNbWithInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jint Nb) {
  if (Nb == 4 || Nb == 6 || Nb == 8) {
    self->Nb__ = Nb;
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Nb = 4 is recommended by DSTU7624 but can be changed to only 6 or 8 in this implementation");
  }
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, engine, 4);
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher *new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, engine)
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher *create_LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, engine)
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine, jint nB) {
  NSObject_init(self);
  self->associatedText_ = new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(self);
  self->data_ = new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(self);
  self->Nb__ = 4;
  self->engine_ = engine;
  self->macSize_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine)) getBlockSize];
  self->nonce_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->initialAssociatedText_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->mac_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->macBlock_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->G1_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->buffer_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->s_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->counter_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_setNbWithInt_(self, nB);
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher *new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint nB) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, engine, nB)
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher *create_LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint nB) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, engine, nB)
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *assocText, jint assocOff, jint assocLen, jint dataLen) {
  if (assocLen - assocOff < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"authText buffer too short");
  }
  if (assocLen % [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize] != 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"padding not supported");
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->nonce_, 0, self->G1_, 0, ((IOSByteArray *) nil_chk(self->nonce_))->size_ - self->Nb__ - 1);
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, dataLen, self->buffer_, 0);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->buffer_, 0, self->G1_, ((IOSByteArray *) nil_chk(self->nonce_))->size_ - self->Nb__ - 1, LibOrgBouncycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT);
  *IOSByteArray_GetRef(self->G1_, ((IOSByteArray *) nil_chk(self->G1_))->size_ - 1) = LibOrgBouncycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(self, true, self->macSize_);
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->G1_ withInt:0 withByteArray:self->macBlock_ withInt:0];
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, assocLen, self->buffer_, 0);
  if (assocLen <= [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize] - self->Nb__) {
    for (jint byteIndex = 0; byteIndex < assocLen; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->buffer_), byteIndex + self->Nb__) ^= IOSByteArray_Get(nil_chk(assocText), assocOff + byteIndex);
    }
    for (jint byteIndex = 0; byteIndex < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(self->buffer_), byteIndex);
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    return;
  }
  for (jint byteIndex = 0; byteIndex < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(self->buffer_), byteIndex);
  }
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
  jint authLen = assocLen;
  while (authLen != 0) {
    for (jint byteIndex = 0; byteIndex < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(assocText), byteIndex + assocOff);
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    assocOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
    authLen -= [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
  }
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, IOSByteArray *output, jint outOff) {
  for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(self->counter_))->size_; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(self->s_), byteIndex) += IOSByteArray_Get(self->counter_, byteIndex);
  }
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->s_ withInt:0 withByteArray:self->buffer_ withInt:0];
  for (jint byteIndex = 0; byteIndex < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(output), outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(self->buffer_), byteIndex) ^ IOSByteArray_Get(nil_chk(input), inOff + byteIndex));
  }
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len) {
  jint totalLen = len;
  while (totalLen > 0) {
    for (jint byteIndex = 0; byteIndex < [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(authText), authOff + byteIndex);
    }
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    totalLen -= [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
    authOff += [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
  }
}

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jint num, IOSByteArray *outBytes, jint outOff) {
  *IOSByteArray_GetRef(nil_chk(outBytes), outOff + 3) = (jbyte) (JreRShift32(num, 24));
  *IOSByteArray_GetRef(outBytes, outOff + 2) = (jbyte) (JreRShift32(num, 16));
  *IOSByteArray_GetRef(outBytes, outOff + 1) = (jbyte) (JreRShift32(num, 8));
  *IOSByteArray_GetRef(outBytes, outOff) = (jbyte) num;
}

jbyte LibOrgBouncycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *self, jboolean authTextPresents, jint macSize) {
  JavaLangStringBuffer *flagByte = new_JavaLangStringBuffer_init();
  if (authTextPresents) {
    (void) [flagByte appendWithNSString:@"1"];
  }
  else {
    (void) [flagByte appendWithNSString:@"0"];
  }
  switch (macSize) {
    case 8:
    (void) [flagByte appendWithNSString:@"010"];
    break;
    case 16:
    (void) [flagByte appendWithNSString:@"011"];
    break;
    case 32:
    (void) [flagByte appendWithNSString:@"100"];
    break;
    case 48:
    (void) [flagByte appendWithNSString:@"101"];
    break;
    case 64:
    (void) [flagByte appendWithNSString:@"110"];
    break;
  }
  NSString *binaryNb = JavaLangInteger_toBinaryStringWithInt_(self->Nb__ - 1);
  while ([((NSString *) nil_chk(binaryNb)) java_length] < 4) {
    binaryNb = [((JavaLangStringBuffer *) nil_chk([new_JavaLangStringBuffer_initWithNSString_(binaryNb) insertWithInt:0 withNSString:@"0"])) description];
  }
  (void) [flagByte appendWithNSString:binaryNb];
  return (jbyte) JavaLangInteger_parseIntWithNSString_withInt_([flagByte description], 2);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesKCCMBlockCipher)

@implementation LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher:(LibOrgBouncycastleCryptoModesKCCMBlockCipher *)outer$ {
  LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(self, outer$);
  return self;
}

- (IOSByteArray *)getBuffer {
  return self->buf_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher:);
  methods[1].selector = @selector(getBuffer);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoModesKCCMBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream = { "ExposedByteArrayOutputStream", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, NULL, 7, 0x2, 2, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;
}

@end

void LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$) {
  JavaIoByteArrayOutputStream_init(self);
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_, outer$)
}

LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_(LibOrgBouncycastleCryptoModesKCCMBlockCipher *outer$) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesKCCMBlockCipher_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)

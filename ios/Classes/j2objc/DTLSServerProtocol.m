//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/DTLSServerProtocol.java
//

#include "AlertDescription.h"
#include "Arrays.h"
#include "AsymmetricKeyParameter.h"
#include "Certificate.h"
#include "CertificateRequest.h"
#include "CertificateStatus.h"
#include "CipherSuite.h"
#include "ConnectionEnd.h"
#include "ContentType.h"
#include "DTLSProtocol.h"
#include "DTLSRecordLayer.h"
#include "DTLSReliableHandshake.h"
#include "DTLSServerProtocol.h"
#include "DTLSTransport.h"
#include "DatagramTransport.h"
#include "DigitallySigned.h"
#include "ExporterLabel.h"
#include "HandshakeType.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "NewSessionTicket.h"
#include "ProtocolVersion.h"
#include "PublicKeyFactory.h"
#include "RandomGenerator.h"
#include "SecurityParameters.h"
#include "SessionParameters.h"
#include "SignatureAndHashAlgorithm.h"
#include "SubjectPublicKeyInfo.h"
#include "TlsCipher.h"
#include "TlsCredentials.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsHandshakeHash.h"
#include "TlsKeyExchange.h"
#include "TlsProtocol.h"
#include "TlsServer.h"
#include "TlsServerContextImpl.h"
#include "TlsSession.h"
#include "TlsSigner.h"
#include "TlsUtils.h"
#include "X509Certificate.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/security/SecureRandom.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@implementation LibOrgBouncycastleCryptoTlsDTLSServerProtocol

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsDTLSServerProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (jboolean)getVerifyRequests {
  return verifyRequests_;
}

- (void)setVerifyRequestsWithBoolean:(jboolean)verifyRequests {
  self->verifyRequests_ = verifyRequests;
}

- (LibOrgBouncycastleCryptoTlsDTLSTransport *)acceptWithLibOrgBouncycastleCryptoTlsTlsServer:(id<LibOrgBouncycastleCryptoTlsTlsServer>)server
                                            withLibOrgBouncycastleCryptoTlsDatagramTransport:(id<LibOrgBouncycastleCryptoTlsDatagramTransport>)transport {
  if (server == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'server' cannot be null");
  }
  if (transport == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'transport' cannot be null");
  }
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = new_LibOrgBouncycastleCryptoTlsSecurityParameters_init();
  securityParameters->entity_ = LibOrgBouncycastleCryptoTlsConnectionEnd_server;
  LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *state = new_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState_init();
  state->server_ = server;
  state->serverContext_ = new_LibOrgBouncycastleCryptoTlsTlsServerContextImpl_initWithJavaSecuritySecureRandom_withLibOrgBouncycastleCryptoTlsSecurityParameters_(secureRandom_, securityParameters);
  securityParameters->serverRandom_ = LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_([server shouldUseGMTUnixTime], [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) getNonceRandomGenerator]);
  [server init__WithLibOrgBouncycastleCryptoTlsTlsServerContext:state->serverContext_];
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer *recordLayer = new_LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(transport, state->serverContext_, server, LibOrgBouncycastleCryptoTlsContentType_handshake);
  @try {
    return [self serverHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer];
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *fatalAlert) {
    [self abortServerHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:[fatalAlert getAlertDescription]];
    @throw fatalAlert;
  }
  @catch (JavaIoIOException *e) {
    [self abortServerHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error];
    @throw e;
  }
  @catch (JavaLangRuntimeException *e) {
    [self abortServerHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
  @finally {
    [securityParameters clear];
  }
}

- (void)abortServerHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                    withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)recordLayer
                                                                                         withShort:(jshort)alertDescription {
  [((LibOrgBouncycastleCryptoTlsDTLSRecordLayer *) nil_chk(recordLayer)) failWithShort:alertDescription];
  [self invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state];
}

- (LibOrgBouncycastleCryptoTlsDTLSTransport *)serverHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                     withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)recordLayer {
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->serverContext_)) getSecurityParameters];
  LibOrgBouncycastleCryptoTlsDTLSReliableHandshake *handshake = new_LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsDTLSRecordLayer_(state->serverContext_, recordLayer);
  LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *clientMessage = [handshake receiveMessage];
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(clientMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_client_hello) {
    [self processClientHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withByteArray:[clientMessage getBody]];
  }
  else {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  {
    IOSByteArray *serverHelloBody = [self generateServerHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state];
    LibOrgBouncycastleCryptoTlsDTLSProtocol_applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_withShort_(recordLayer, ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters))->maxFragmentLength_);
    LibOrgBouncycastleCryptoTlsProtocolVersion *recordLayerVersion = [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) getServerVersion];
    [((LibOrgBouncycastleCryptoTlsDTLSRecordLayer *) nil_chk(recordLayer)) setReadVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:recordLayerVersion];
    [recordLayer setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:recordLayerVersion];
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_server_hello withByteArray:serverHelloBody];
  }
  [handshake notifyHelloComplete];
  JavaUtilVector *serverSupplementalData = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getServerSupplementalData];
  if (serverSupplementalData != nil) {
    IOSByteArray *supplementalDataBody = LibOrgBouncycastleCryptoTlsDTLSProtocol_generateSupplementalDataWithJavaUtilVector_(serverSupplementalData);
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data withByteArray:supplementalDataBody];
  }
  state->keyExchange_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getKeyExchange];
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:state->serverContext_];
  state->serverCredentials_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getCredentials];
  LibOrgBouncycastleCryptoTlsCertificate *serverCertificate = nil;
  if (state->serverCredentials_ == nil) {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipServerCredentials];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) processServerCredentialsWithLibOrgBouncycastleCryptoTlsTlsCredentials:state->serverCredentials_];
    serverCertificate = [((id<LibOrgBouncycastleCryptoTlsTlsCredentials>) nil_chk(state->serverCredentials_)) getCertificate];
    IOSByteArray *certificateBody = LibOrgBouncycastleCryptoTlsDTLSProtocol_generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate_(serverCertificate);
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate withByteArray:certificateBody];
  }
  if (serverCertificate == nil || [serverCertificate isEmpty]) {
    state->allowCertificateStatus_ = false;
  }
  if (state->allowCertificateStatus_) {
    LibOrgBouncycastleCryptoTlsCertificateStatus *certificateStatus = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getCertificateStatus];
    if (certificateStatus != nil) {
      IOSByteArray *certificateStatusBody = [self generateCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsCertificateStatus:certificateStatus];
      [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate_status withByteArray:certificateStatusBody];
    }
  }
  IOSByteArray *serverKeyExchange = [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) generateServerKeyExchange];
  if (serverKeyExchange != nil) {
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_server_key_exchange withByteArray:serverKeyExchange];
  }
  if (state->serverCredentials_ != nil) {
    state->certificateRequest_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getCertificateRequest];
    if (state->certificateRequest_ != nil) {
      if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(state->serverContext_) != ([((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(state->certificateRequest_)) getSupportedSignatureAlgorithms] != nil)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
      }
      [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) validateCertificateRequestWithLibOrgBouncycastleCryptoTlsCertificateRequest:state->certificateRequest_];
      IOSByteArray *certificateRequestBody = [self generateCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsCertificateRequest:state->certificateRequest_];
      [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate_request withByteArray:certificateRequestBody];
      LibOrgBouncycastleCryptoTlsTlsUtils_trackHashAlgorithmsWithLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withJavaUtilVector_([handshake getHandshakeHash], [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(state->certificateRequest_)) getSupportedSignatureAlgorithms]);
    }
  }
  [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_server_hello_done withByteArray:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES)];
  [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk([handshake getHandshakeHash])) sealHashAlgorithms];
  clientMessage = [handshake receiveMessage];
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(clientMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data) {
    [self processClientSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withByteArray:[clientMessage getBody]];
    clientMessage = [handshake receiveMessage];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) processClientSupplementalDataWithJavaUtilVector:nil];
  }
  if (state->certificateRequest_ == nil) {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipClientCredentials];
  }
  else {
    if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(clientMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_certificate) {
      [self processClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withByteArray:[clientMessage getBody]];
      clientMessage = [handshake receiveMessage];
    }
    else {
      if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(state->serverContext_)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      [self notifyClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsCertificate:JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN)];
    }
  }
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(clientMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_client_key_exchange) {
    [self processClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withByteArray:[clientMessage getBody]];
  }
  else {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash> prepareFinishHash = [handshake prepareToFinish];
  securityParameters->sessionHash_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->serverContext_, prepareFinishHash, nil);
  LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_(state->serverContext_, state->keyExchange_);
  [recordLayer initPendingEpochWithLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getCipher]];
  if ([self expectCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state]) {
    IOSByteArray *certificateVerifyBody = [handshake receiveMessageBodyWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate_verify];
    [self processCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withByteArray:certificateVerifyBody withLibOrgBouncycastleCryptoTlsTlsHandshakeHash:prepareFinishHash];
  }
  IOSByteArray *expectedClientVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->serverContext_, LibOrgBouncycastleCryptoTlsExporterLabel_client_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->serverContext_, [handshake getHandshakeHash], nil));
  [self processFinishedWithByteArray:[handshake receiveMessageBodyWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished] withByteArray:expectedClientVerifyData];
  if (state->expectSessionTicket_) {
    LibOrgBouncycastleCryptoTlsNewSessionTicket *newSessionTicket = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getNewSessionTicket];
    IOSByteArray *newSessionTicketBody = [self generateNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsNewSessionTicket:newSessionTicket];
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_session_ticket withByteArray:newSessionTicketBody];
  }
  IOSByteArray *serverVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->serverContext_, LibOrgBouncycastleCryptoTlsExporterLabel_server_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->serverContext_, [handshake getHandshakeHash], nil));
  [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished withByteArray:serverVerifyData];
  [handshake finish];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyHandshakeComplete];
  return new_LibOrgBouncycastleCryptoTlsDTLSTransport_initWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_(recordLayer);
}

- (IOSByteArray *)generateCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                 withLibOrgBouncycastleCryptoTlsCertificateRequest:(LibOrgBouncycastleCryptoTlsCertificateRequest *)certificateRequest {
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(certificateRequest)) encodeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

- (IOSByteArray *)generateCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                 withLibOrgBouncycastleCryptoTlsCertificateStatus:(LibOrgBouncycastleCryptoTlsCertificateStatus *)certificateStatus {
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((LibOrgBouncycastleCryptoTlsCertificateStatus *) nil_chk(certificateStatus)) encodeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

- (IOSByteArray *)generateNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                 withLibOrgBouncycastleCryptoTlsNewSessionTicket:(LibOrgBouncycastleCryptoTlsNewSessionTicket *)newSessionTicket {
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((LibOrgBouncycastleCryptoTlsNewSessionTicket *) nil_chk(newSessionTicket)) encodeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

- (IOSByteArray *)generateServerHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state {
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->serverContext_)) getSecurityParameters];
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  {
    LibOrgBouncycastleCryptoTlsProtocolVersion *server_version = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getServerVersion];
    if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(server_version)) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:[((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) getClientVersion]]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
    }
    [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) setServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withJavaIoOutputStream_([((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) getServerVersion], buf);
  }
  [buf writeWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters)) getServerRandom]];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES), buf);
  jint selectedCipherSuite = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getSelectedCipherSuite];
  if (!LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, selectedCipherSuite) || selectedCipherSuite == LibOrgBouncycastleCryptoTlsCipherSuite_TLS_NULL_WITH_NULL_NULL || LibOrgBouncycastleCryptoTlsCipherSuite_isSCSVWithInt_(selectedCipherSuite) || !LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withLibOrgBouncycastleCryptoTlsProtocolVersion_(selectedCipherSuite, [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(state->serverContext_)) getServerVersion])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  LibOrgBouncycastleCryptoTlsDTLSProtocol_validateSelectedCipherSuiteWithInt_withShort_(selectedCipherSuite, LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  securityParameters->cipherSuite_ = selectedCipherSuite;
  jshort selectedCompressionMethod = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getSelectedCompressionMethod];
  if (!LibOrgBouncycastleUtilArrays_containsWithShortArray_withShort_(state->offeredCompressionMethods_, selectedCompressionMethod)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  securityParameters->compressionAlgorithm_ = selectedCompressionMethod;
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withJavaIoOutputStream_(selectedCipherSuite, buf);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withJavaIoOutputStream_(selectedCompressionMethod, buf);
  state->serverExtensions_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_ensureExtensionsInitialisedWithJavaUtilHashtable_([((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) getServerExtensions]);
  if (state->secure_renegotiation_) {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(state->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    jboolean noRenegExt = nil == renegExtData;
    if (noRenegExt) {
      (void) [((JavaUtilHashtable *) nil_chk(state->serverExtensions_)) putWithId:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo) withId:LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES))];
    }
  }
  if ([securityParameters isExtendedMasterSecret]) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addExtendedMasterSecretExtensionWithJavaUtilHashtable_(state->serverExtensions_);
  }
  if (![((JavaUtilHashtable *) nil_chk(state->serverExtensions_)) isEmpty]) {
    securityParameters->encryptThenMAC_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(state->serverExtensions_);
    securityParameters->maxFragmentLength_ = LibOrgBouncycastleCryptoTlsDTLSProtocol_evaluateMaxFragmentLengthExtensionWithBoolean_withJavaUtilHashtable_withJavaUtilHashtable_withShort_(state->resumedSession_, state->clientExtensions_, state->serverExtensions_, LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
    securityParameters->truncatedHMac_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(state->serverExtensions_);
    state->allowCertificateStatus_ = (!state->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(state->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsExtensionsUtils, EXT_status_request), LibOrgBouncycastleCryptoTlsAlertDescription_internal_error));
    state->expectSessionTicket_ = (!state->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(state->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_SessionTicket), LibOrgBouncycastleCryptoTlsAlertDescription_internal_error));
    LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(buf, state->serverExtensions_);
  }
  securityParameters->prfAlgorithm_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(state->serverContext_, [securityParameters getCipherSuite]);
  securityParameters->verifyDataLength_ = 12;
  return [buf toByteArray];
}

- (void)invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state {
  if (((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->sessionParameters_ != nil) {
    [state->sessionParameters_ clear];
    state->sessionParameters_ = nil;
  }
  if (state->tlsSession_ != nil) {
    [state->tlsSession_ invalidate];
    state->tlsSession_ = nil;
  }
}

- (void)notifyClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                           withLibOrgBouncycastleCryptoTlsCertificate:(LibOrgBouncycastleCryptoTlsCertificate *)clientCertificate {
  if (((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->certificateRequest_ == nil) {
    @throw new_JavaLangIllegalStateException_init();
  }
  if (state->clientCertificate_ != nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  state->clientCertificate_ = clientCertificate;
  if ([((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(clientCertificate)) isEmpty]) {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipClientCredentials];
  }
  else {
    state->clientCertificateType_ = LibOrgBouncycastleCryptoTlsTlsUtils_getClientCertificateTypeWithLibOrgBouncycastleCryptoTlsCertificate_withLibOrgBouncycastleCryptoTlsCertificate_(clientCertificate, [((id<LibOrgBouncycastleCryptoTlsTlsCredentials>) nil_chk(state->serverCredentials_)) getCertificate]);
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) processClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
}

- (void)processClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                         withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsCertificate *clientCertificate = LibOrgBouncycastleCryptoTlsCertificate_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [self notifyClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:state withLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
}

- (void)processCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                         withByteArray:(IOSByteArray *)body
                                                       withLibOrgBouncycastleCryptoTlsTlsHandshakeHash:(id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>)prepareFinishHash {
  if (((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->certificateRequest_ == nil) {
    @throw new_JavaLangIllegalStateException_init();
  }
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsTlsServerContextImpl *context = state->serverContext_;
  LibOrgBouncycastleCryptoTlsDigitallySigned *clientCertificateVerify = LibOrgBouncycastleCryptoTlsDigitallySigned_parseWithLibOrgBouncycastleCryptoTlsTlsContext_withJavaIoInputStream_(context, buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  @try {
    LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *signatureAlgorithm = [((LibOrgBouncycastleCryptoTlsDigitallySigned *) nil_chk(clientCertificateVerify)) getAlgorithm];
    IOSByteArray *hash_;
    if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_(context)) {
      LibOrgBouncycastleCryptoTlsTlsUtils_verifySupportedSignatureAlgorithmWithJavaUtilVector_withLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm_([((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(state->certificateRequest_)) getSupportedSignatureAlgorithms], signatureAlgorithm);
      hash_ = [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk(prepareFinishHash)) getFinalHashWithShort:[((LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *) nil_chk(signatureAlgorithm)) getHash]];
    }
    else {
      hash_ = [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk([((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(context)) getSecurityParameters])) getSessionHash];
    }
    LibOrgBouncycastleAsn1X509X509Certificate *x509Cert = [((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(state->clientCertificate_)) getCertificateAtWithInt:0];
    LibOrgBouncycastleAsn1X509SubjectPublicKeyInfo *keyInfo = [((LibOrgBouncycastleAsn1X509X509Certificate *) nil_chk(x509Cert)) getSubjectPublicKeyInfo];
    LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *publicKey = LibOrgBouncycastleCryptoUtilPublicKeyFactory_createKeyWithLibOrgBouncycastleAsn1X509SubjectPublicKeyInfo_(keyInfo);
    id<LibOrgBouncycastleCryptoTlsTlsSigner> tlsSigner = LibOrgBouncycastleCryptoTlsTlsUtils_createTlsSignerWithShort_(state->clientCertificateType_);
    [((id<LibOrgBouncycastleCryptoTlsTlsSigner>) nil_chk(tlsSigner)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:context];
    if (![tlsSigner verifyRawSignatureWithLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm:signatureAlgorithm withByteArray:[clientCertificateVerify getSignature] withLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:publicKey withByteArray:hash_]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decrypt_error);
    }
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *e) {
    @throw e;
  }
  @catch (JavaLangException *e) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_decrypt_error, e);
  }
}

- (void)processClientHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                   withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
  if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(client_version)) isDTLS]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  IOSByteArray *client_random = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(32, buf);
  IOSByteArray *sessionID = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  if (((IOSByteArray *) nil_chk(sessionID))->size_ > 32) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  IOSByteArray *cookie = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  jint cipher_suites_length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
  if (cipher_suites_length < 2 || (cipher_suites_length & 1) != 0) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
  }
  ((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->offeredCipherSuites_ = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16ArrayWithInt_withJavaIoInputStream_(cipher_suites_length / 2, buf);
  jint compression_methods_length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithJavaIoInputStream_(buf);
  if (compression_methods_length < 1) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  state->offeredCompressionMethods_ = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8ArrayWithInt_withJavaIoInputStream_(compression_methods_length, buf);
  state->clientExtensions_ = LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsServerContextImpl *context = state->serverContext_;
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(context)) getSecurityParameters];
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters))->extendedMasterSecret_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasExtendedMasterSecretExtensionWithJavaUtilHashtable_(state->clientExtensions_);
  if (![securityParameters isExtendedMasterSecret] && [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) requiresExtendedMasterSecret]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  [context setClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyFallbackWithBoolean:LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV)];
  securityParameters->clientRandom_ = client_random;
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyOfferedCipherSuitesWithIntArray:state->offeredCipherSuites_];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifyOfferedCompressionMethodsWithShortArray:state->offeredCompressionMethods_];
  {
    if (LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) {
      state->secure_renegotiation_ = true;
    }
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(state->clientExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    if (renegExtData != nil) {
      state->secure_renegotiation_ = true;
      if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(renegExtData, LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES)))) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
      }
    }
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) notifySecureRenegotiationWithBoolean:state->secure_renegotiation_];
  if (state->clientExtensions_ != nil) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getPaddingExtensionWithJavaUtilHashtable_(state->clientExtensions_);
    [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(state->server_)) processClientExtensionsWithJavaUtilHashtable:state->clientExtensions_];
  }
}

- (void)processClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                         withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->keyExchange_)) processClientKeyExchangeWithJavaIoInputStream:buf];
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
}

- (void)processClientSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state
                                                                                              withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  JavaUtilVector *clientSupplementalData = LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->server_)) processClientSupplementalDataWithJavaUtilVector:clientSupplementalData];
}

- (jboolean)expectCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *)state {
  return ((LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *) nil_chk(state))->clientCertificateType_ >= 0 && LibOrgBouncycastleCryptoTlsTlsUtils_hasSigningCapabilityWithShort_(state->clientCertificateType_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsDTLSTransport;", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsDTLSTransport;", 0x4, 8, 9, 5, -1, -1, -1 },
    { NULL, "[B", 0x4, 10, 11, 5, -1, -1, -1 },
    { NULL, "[B", 0x4, 12, 13, 5, -1, -1, -1 },
    { NULL, "[B", 0x4, 14, 15, 5, -1, -1, -1 },
    { NULL, "[B", 0x4, 16, 17, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 19, 20, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 21, 22, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 23, 24, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 25, 22, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 26, 22, 5, -1, -1, -1 },
    { NULL, "V", 0x4, 27, 22, 5, -1, -1, -1 },
    { NULL, "Z", 0x4, 28, 17, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[1].selector = @selector(getVerifyRequests);
  methods[2].selector = @selector(setVerifyRequestsWithBoolean:);
  methods[3].selector = @selector(acceptWithLibOrgBouncycastleCryptoTlsTlsServer:withLibOrgBouncycastleCryptoTlsDatagramTransport:);
  methods[4].selector = @selector(abortServerHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:withShort:);
  methods[5].selector = @selector(serverHandshakeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:);
  methods[6].selector = @selector(generateCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsCertificateRequest:);
  methods[7].selector = @selector(generateCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsCertificateStatus:);
  methods[8].selector = @selector(generateNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsNewSessionTicket:);
  methods[9].selector = @selector(generateServerHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:);
  methods[10].selector = @selector(invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:);
  methods[11].selector = @selector(notifyClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withLibOrgBouncycastleCryptoTlsCertificate:);
  methods[12].selector = @selector(processClientCertificateWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withByteArray:);
  methods[13].selector = @selector(processCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withByteArray:withLibOrgBouncycastleCryptoTlsTlsHandshakeHash:);
  methods[14].selector = @selector(processClientHelloWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withByteArray:);
  methods[15].selector = @selector(processClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withByteArray:);
  methods[16].selector = @selector(processClientSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:withByteArray:);
  methods[17].selector = @selector(expectCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "verifyRequests_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaSecuritySecureRandom;", "setVerifyRequests", "Z", "accept", "LLibOrgBouncycastleCryptoTlsTlsServer;LLibOrgBouncycastleCryptoTlsDatagramTransport;", "LJavaIoIOException;", "abortServerHandshake", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsDTLSRecordLayer;S", "serverHandshake", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsDTLSRecordLayer;", "generateCertificateRequest", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsCertificateRequest;", "generateCertificateStatus", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsCertificateStatus;", "generateNewSessionTicket", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsNewSessionTicket;", "generateServerHello", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;", "invalidateSession", "notifyClientCertificate", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;LLibOrgBouncycastleCryptoTlsCertificate;", "processClientCertificate", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;[B", "processCertificateVerify", "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;[BLLibOrgBouncycastleCryptoTlsTlsHandshakeHash;", "processClientHello", "processClientKeyExchange", "processClientSupplementalData", "expectCertificateVerifyMessage" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSServerProtocol = { "DTLSServerProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 18, 1, -1, 17, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSServerProtocol;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSServerProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsDTLSServerProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  self->verifyRequests_ = true;
}

LibOrgBouncycastleCryptoTlsDTLSServerProtocol *new_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsDTLSServerProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

LibOrgBouncycastleCryptoTlsDTLSServerProtocol *create_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsDTLSServerProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSServerProtocol)

@implementation LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "server_", "LLibOrgBouncycastleCryptoTlsTlsServer;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "serverContext_", "LLibOrgBouncycastleCryptoTlsTlsServerContextImpl;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tlsSession_", "LLibOrgBouncycastleCryptoTlsTlsSession;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sessionParameters_", "LLibOrgBouncycastleCryptoTlsSessionParameters;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sessionParametersBuilder_", "LLibOrgBouncycastleCryptoTlsSessionParameters_Builder;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "offeredCipherSuites_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "offeredCompressionMethods_", "[S", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "serverExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "resumedSession_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "secure_renegotiation_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "allowCertificateStatus_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "expectSessionTicket_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "keyExchange_", "LLibOrgBouncycastleCryptoTlsTlsKeyExchange;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "serverCredentials_", "LLibOrgBouncycastleCryptoTlsTlsCredentials;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "certificateRequest_", "LLibOrgBouncycastleCryptoTlsCertificateRequest;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientCertificateType_", "S", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientCertificate_", "LLibOrgBouncycastleCryptoTlsCertificate;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsDTLSServerProtocol;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState = { "ServerHandshakeState", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0xc, 1, 18, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState_init(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *self) {
  NSObject_init(self);
  self->server_ = nil;
  self->serverContext_ = nil;
  self->tlsSession_ = nil;
  self->sessionParameters_ = nil;
  self->sessionParametersBuilder_ = nil;
  self->offeredCipherSuites_ = nil;
  self->offeredCompressionMethods_ = nil;
  self->clientExtensions_ = nil;
  self->serverExtensions_ = nil;
  self->resumedSession_ = false;
  self->secure_renegotiation_ = false;
  self->allowCertificateStatus_ = false;
  self->expectSessionTicket_ = false;
  self->keyExchange_ = nil;
  self->serverCredentials_ = nil;
  self->certificateRequest_ = nil;
  self->clientCertificateType_ = -1;
  self->clientCertificate_ = nil;
}

LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *new_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState, init)
}

LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState *create_LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSServerProtocol_ServerHandshakeState)

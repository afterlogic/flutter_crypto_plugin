//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/AbstractTlsServer.java
//

#include "AbstractTlsPeer.h"
#include "AbstractTlsServer.h"
#include "AlertDescription.h"
#include "Arrays.h"
#include "Certificate.h"
#include "CertificateRequest.h"
#include "CertificateStatus.h"
#include "CompressionMethod.h"
#include "DefaultTlsCipherFactory.h"
#include "ECPointFormat.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "MaxFragmentLength.h"
#include "NamedCurve.h"
#include "NewSessionTicket.h"
#include "ProtocolVersion.h"
#include "TlsCipher.h"
#include "TlsCipherFactory.h"
#include "TlsCompression.h"
#include "TlsECCUtils.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsNullCompression.h"
#include "TlsServerContext.h"
#include "TlsUtils.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

#pragma clang diagnostic ignored "-Wprotocol"

@implementation LibOrgBouncycastleCryptoTlsAbstractTlsServer

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoTlsAbstractTlsServer_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsCipherFactory:(id<LibOrgBouncycastleCryptoTlsTlsCipherFactory>)cipherFactory {
  LibOrgBouncycastleCryptoTlsAbstractTlsServer_initWithLibOrgBouncycastleCryptoTlsTlsCipherFactory_(self, cipherFactory);
  return self;
}

- (jboolean)allowEncryptThenMAC {
  return true;
}

- (jboolean)allowTruncatedHMac {
  return false;
}

- (JavaUtilHashtable *)checkServerExtensions {
  return self->serverExtensions_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_ensureExtensionsInitialisedWithJavaUtilHashtable_(self->serverExtensions_);
}

- (IOSIntArray *)getCipherSuites {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSShortArray *)getCompressionMethods {
  return [IOSShortArray newArrayWithShorts:(jshort[]){ LibOrgBouncycastleCryptoTlsCompressionMethod__null } count:1];
}

- (LibOrgBouncycastleCryptoTlsProtocolVersion *)getMaximumVersion {
  return JreLoadStatic(LibOrgBouncycastleCryptoTlsProtocolVersion, TLSv11);
}

- (LibOrgBouncycastleCryptoTlsProtocolVersion *)getMinimumVersion {
  return JreLoadStatic(LibOrgBouncycastleCryptoTlsProtocolVersion, TLSv10);
}

- (jboolean)supportsClientECCCapabilitiesWithIntArray:(IOSIntArray *)namedCurves
                                       withShortArray:(IOSShortArray *)ecPointFormats {
  if (namedCurves == nil) {
    return LibOrgBouncycastleCryptoTlsTlsECCUtils_hasAnySupportedNamedCurves();
  }
  for (jint i = 0; i < namedCurves->size_; ++i) {
    jint namedCurve = IOSIntArray_Get(namedCurves, i);
    if (LibOrgBouncycastleCryptoTlsNamedCurve_isValidWithInt_(namedCurve) && (!LibOrgBouncycastleCryptoTlsNamedCurve_refersToASpecificNamedCurveWithInt_(namedCurve) || LibOrgBouncycastleCryptoTlsTlsECCUtils_isSupportedNamedCurveWithInt_(namedCurve))) {
      return true;
    }
  }
  return false;
}

- (void)init__WithLibOrgBouncycastleCryptoTlsTlsServerContext:(id<LibOrgBouncycastleCryptoTlsTlsServerContext>)context {
  self->context_ = context;
}

- (void)notifyClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:(LibOrgBouncycastleCryptoTlsProtocolVersion *)clientVersion {
  self->clientVersion_ = clientVersion;
}

- (void)notifyFallbackWithBoolean:(jboolean)isFallback {
  if (isFallback && [((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk([self getMaximumVersion])) isLaterVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:clientVersion_]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_inappropriate_fallback);
  }
}

- (void)notifyOfferedCipherSuitesWithIntArray:(IOSIntArray *)offeredCipherSuites {
  self->offeredCipherSuites_ = offeredCipherSuites;
  self->eccCipherSuitesOffered_ = LibOrgBouncycastleCryptoTlsTlsECCUtils_containsECCCipherSuitesWithIntArray_(self->offeredCipherSuites_);
}

- (void)notifyOfferedCompressionMethodsWithShortArray:(IOSShortArray *)offeredCompressionMethods {
  self->offeredCompressionMethods_ = offeredCompressionMethods;
}

- (void)processClientExtensionsWithJavaUtilHashtable:(JavaUtilHashtable *)clientExtensions {
  self->clientExtensions_ = clientExtensions;
  if (clientExtensions != nil) {
    self->encryptThenMACOffered_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(clientExtensions);
    self->maxFragmentLengthOffered_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getMaxFragmentLengthExtensionWithJavaUtilHashtable_(clientExtensions);
    if (maxFragmentLengthOffered_ >= 0 && !LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(maxFragmentLengthOffered_)) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    self->truncatedHMacOffered_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(clientExtensions);
    self->supportedSignatureAlgorithms_ = LibOrgBouncycastleCryptoTlsTlsUtils_getSignatureAlgorithmsExtensionWithJavaUtilHashtable_(clientExtensions);
    if (self->supportedSignatureAlgorithms_ != nil) {
      if (!LibOrgBouncycastleCryptoTlsTlsUtils_isSignatureAlgorithmsExtensionAllowedWithLibOrgBouncycastleCryptoTlsProtocolVersion_(clientVersion_)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
      }
    }
    self->namedCurves_ = LibOrgBouncycastleCryptoTlsTlsECCUtils_getSupportedEllipticCurvesExtensionWithJavaUtilHashtable_(clientExtensions);
    self->clientECPointFormats_ = LibOrgBouncycastleCryptoTlsTlsECCUtils_getSupportedPointFormatsExtensionWithJavaUtilHashtable_(clientExtensions);
  }
}

- (LibOrgBouncycastleCryptoTlsProtocolVersion *)getServerVersion {
  if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk([self getMinimumVersion])) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:clientVersion_]) {
    LibOrgBouncycastleCryptoTlsProtocolVersion *maximumVersion = [self getMaximumVersion];
    if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(clientVersion_)) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:maximumVersion]) {
      return serverVersion_ = clientVersion_;
    }
    if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(clientVersion_)) isLaterVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:maximumVersion]) {
      return serverVersion_ = maximumVersion;
    }
  }
  @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_protocol_version);
}

- (jint)getSelectedCipherSuite {
  JavaUtilVector *sigAlgs = LibOrgBouncycastleCryptoTlsTlsUtils_getUsableSignatureAlgorithmsWithJavaUtilVector_(supportedSignatureAlgorithms_);
  jboolean eccCipherSuitesEnabled = [self supportsClientECCCapabilitiesWithIntArray:self->namedCurves_ withShortArray:self->clientECPointFormats_];
  IOSIntArray *cipherSuites = [self getCipherSuites];
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(cipherSuites))->size_; ++i) {
    jint cipherSuite = IOSIntArray_Get(cipherSuites, i);
    if (LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(self->offeredCipherSuites_, cipherSuite) && (eccCipherSuitesEnabled || !LibOrgBouncycastleCryptoTlsTlsECCUtils_isECCCipherSuiteWithInt_(cipherSuite)) && LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withLibOrgBouncycastleCryptoTlsProtocolVersion_(cipherSuite, serverVersion_) && LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForSignatureAlgorithmsWithInt_withJavaUtilVector_(cipherSuite, sigAlgs)) {
      return self->selectedCipherSuite_ = cipherSuite;
    }
  }
  @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
}

- (jshort)getSelectedCompressionMethod {
  IOSShortArray *compressionMethods = [self getCompressionMethods];
  for (jint i = 0; i < ((IOSShortArray *) nil_chk(compressionMethods))->size_; ++i) {
    if (LibOrgBouncycastleUtilArrays_containsWithShortArray_withShort_(offeredCompressionMethods_, IOSShortArray_Get(compressionMethods, i))) {
      return self->selectedCompressionMethod_ = IOSShortArray_Get(compressionMethods, i);
    }
  }
  @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
}

- (JavaUtilHashtable *)getServerExtensions {
  if (self->encryptThenMACOffered_ && [self allowEncryptThenMAC]) {
    if (LibOrgBouncycastleCryptoTlsTlsUtils_isBlockCipherSuiteWithInt_(self->selectedCipherSuite_)) {
      LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addEncryptThenMACExtensionWithJavaUtilHashtable_([self checkServerExtensions]);
    }
  }
  if (self->maxFragmentLengthOffered_ >= 0 && LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(maxFragmentLengthOffered_)) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addMaxFragmentLengthExtensionWithJavaUtilHashtable_withShort_([self checkServerExtensions], self->maxFragmentLengthOffered_);
  }
  if (self->truncatedHMacOffered_ && [self allowTruncatedHMac]) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addTruncatedHMacExtensionWithJavaUtilHashtable_([self checkServerExtensions]);
  }
  if (self->clientECPointFormats_ != nil && LibOrgBouncycastleCryptoTlsTlsECCUtils_isECCCipherSuiteWithInt_(self->selectedCipherSuite_)) {
    self->serverECPointFormats_ = [IOSShortArray newArrayWithShorts:(jshort[]){ LibOrgBouncycastleCryptoTlsECPointFormat_uncompressed, LibOrgBouncycastleCryptoTlsECPointFormat_ansiX962_compressed_prime, LibOrgBouncycastleCryptoTlsECPointFormat_ansiX962_compressed_char2 } count:3];
    LibOrgBouncycastleCryptoTlsTlsECCUtils_addSupportedPointFormatsExtensionWithJavaUtilHashtable_withShortArray_([self checkServerExtensions], serverECPointFormats_);
  }
  return serverExtensions_;
}

- (JavaUtilVector *)getServerSupplementalData {
  return nil;
}

- (LibOrgBouncycastleCryptoTlsCertificateStatus *)getCertificateStatus {
  return nil;
}

- (LibOrgBouncycastleCryptoTlsCertificateRequest *)getCertificateRequest {
  return nil;
}

- (void)processClientSupplementalDataWithJavaUtilVector:(JavaUtilVector *)clientSupplementalData {
  if (clientSupplementalData != nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
}

- (void)notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:(LibOrgBouncycastleCryptoTlsCertificate *)clientCertificate {
  @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
}

- (id<LibOrgBouncycastleCryptoTlsTlsCompression>)getCompression {
  switch (selectedCompressionMethod_) {
    case LibOrgBouncycastleCryptoTlsCompressionMethod__null:
    return new_LibOrgBouncycastleCryptoTlsTlsNullCompression_init();
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
}

- (id<LibOrgBouncycastleCryptoTlsTlsCipher>)getCipher {
  jint encryptionAlgorithm = LibOrgBouncycastleCryptoTlsTlsUtils_getEncryptionAlgorithmWithInt_(selectedCipherSuite_);
  jint macAlgorithm = LibOrgBouncycastleCryptoTlsTlsUtils_getMACAlgorithmWithInt_(selectedCipherSuite_);
  return [((id<LibOrgBouncycastleCryptoTlsTlsCipherFactory>) nil_chk(cipherFactory_)) createCipherWithLibOrgBouncycastleCryptoTlsTlsContext:context_ withInt:encryptionAlgorithm withInt:macAlgorithm];
}

- (LibOrgBouncycastleCryptoTlsNewSessionTicket *)getNewSessionTicket {
  return new_LibOrgBouncycastleCryptoTlsNewSessionTicket_initWithLong_withByteArray_(0LL, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES));
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilHashtable;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "[I", 0x404, -1, -1, -1, -1, -1, -1 },
    { NULL, "[S", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsProtocolVersion;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsProtocolVersion;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 6, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 13, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 14, 15, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsProtocolVersion;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "S", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LJavaUtilHashtable;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LJavaUtilVector;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsCertificateStatus;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsCertificateRequest;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 16, 17, 7, -1, -1, -1 },
    { NULL, "V", 0x1, 18, 19, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsCompression;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsCipher;", 0x1, -1, -1, 7, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsNewSessionTicket;", 0x1, -1, -1, 7, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsCipherFactory:);
  methods[2].selector = @selector(allowEncryptThenMAC);
  methods[3].selector = @selector(allowTruncatedHMac);
  methods[4].selector = @selector(checkServerExtensions);
  methods[5].selector = @selector(getCipherSuites);
  methods[6].selector = @selector(getCompressionMethods);
  methods[7].selector = @selector(getMaximumVersion);
  methods[8].selector = @selector(getMinimumVersion);
  methods[9].selector = @selector(supportsClientECCCapabilitiesWithIntArray:withShortArray:);
  methods[10].selector = @selector(init__WithLibOrgBouncycastleCryptoTlsTlsServerContext:);
  methods[11].selector = @selector(notifyClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:);
  methods[12].selector = @selector(notifyFallbackWithBoolean:);
  methods[13].selector = @selector(notifyOfferedCipherSuitesWithIntArray:);
  methods[14].selector = @selector(notifyOfferedCompressionMethodsWithShortArray:);
  methods[15].selector = @selector(processClientExtensionsWithJavaUtilHashtable:);
  methods[16].selector = @selector(getServerVersion);
  methods[17].selector = @selector(getSelectedCipherSuite);
  methods[18].selector = @selector(getSelectedCompressionMethod);
  methods[19].selector = @selector(getServerExtensions);
  methods[20].selector = @selector(getServerSupplementalData);
  methods[21].selector = @selector(getCertificateStatus);
  methods[22].selector = @selector(getCertificateRequest);
  methods[23].selector = @selector(processClientSupplementalDataWithJavaUtilVector:);
  methods[24].selector = @selector(notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:);
  methods[25].selector = @selector(getCompression);
  methods[26].selector = @selector(getCipher);
  methods[27].selector = @selector(getNewSessionTicket);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cipherFactory_", "LLibOrgBouncycastleCryptoTlsTlsCipherFactory;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "context_", "LLibOrgBouncycastleCryptoTlsTlsServerContext;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "clientVersion_", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "offeredCipherSuites_", "[I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "offeredCompressionMethods_", "[S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "clientExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "encryptThenMACOffered_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "maxFragmentLengthOffered_", "S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "truncatedHMacOffered_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "supportedSignatureAlgorithms_", "LJavaUtilVector;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "eccCipherSuitesOffered_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "namedCurves_", "[I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "clientECPointFormats_", "[S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "serverECPointFormats_", "[S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "serverVersion_", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "selectedCipherSuite_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "selectedCompressionMethod_", "S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "serverExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsTlsCipherFactory;", "supportsClientECCCapabilities", "[I[S", "init", "LLibOrgBouncycastleCryptoTlsTlsServerContext;", "notifyClientVersion", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", "LJavaIoIOException;", "notifyFallback", "Z", "notifyOfferedCipherSuites", "[I", "notifyOfferedCompressionMethods", "[S", "processClientExtensions", "LJavaUtilHashtable;", "processClientSupplementalData", "LJavaUtilVector;", "notifyClientCertificate", "LLibOrgBouncycastleCryptoTlsCertificate;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsAbstractTlsServer = { "AbstractTlsServer", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x401, 28, 18, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsAbstractTlsServer;
}

@end

void LibOrgBouncycastleCryptoTlsAbstractTlsServer_init(LibOrgBouncycastleCryptoTlsAbstractTlsServer *self) {
  LibOrgBouncycastleCryptoTlsAbstractTlsServer_initWithLibOrgBouncycastleCryptoTlsTlsCipherFactory_(self, new_LibOrgBouncycastleCryptoTlsDefaultTlsCipherFactory_init());
}

void LibOrgBouncycastleCryptoTlsAbstractTlsServer_initWithLibOrgBouncycastleCryptoTlsTlsCipherFactory_(LibOrgBouncycastleCryptoTlsAbstractTlsServer *self, id<LibOrgBouncycastleCryptoTlsTlsCipherFactory> cipherFactory) {
  LibOrgBouncycastleCryptoTlsAbstractTlsPeer_init(self);
  self->cipherFactory_ = cipherFactory;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsAbstractTlsServer)

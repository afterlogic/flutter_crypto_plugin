//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/encryption_signing/EncryptionStream.java
//

#include "ArmoredOutputStream.h"
#include "BCPGOutputStream.h"
#include "BcPGPContentSignerBuilder.h"
#include "BcPGPDataEncryptorBuilder.h"
#include "BcPublicKeyKeyEncryptionMethodGenerator.h"
#include "CompressionAlgorithm.h"
#include "EncryptionStream.h"
#include "HashAlgorithmUtil.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "OpenPgpMetadata.h"
#include "PGPCompressedDataGenerator.h"
#include "PGPEncryptedDataGenerator.h"
#include "PGPException.h"
#include "PGPLiteralData.h"
#include "PGPLiteralDataGenerator.h"
#include "PGPOnePassSignature.h"
#include "PGPPrivateKey.h"
#include "PGPPublicKey.h"
#include "PGPSignature.h"
#include "PGPSignatureGenerator.h"
#include "PublicKeyPacket.h"
#include "SymmetricKeyAlgorithm.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/Long.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/Date.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"

@interface LibComAfterlogicPgpEncryption_signingEncryptionStream () {
 @public
  LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata *result_;
  id<JavaUtilList> signatureGenerators_;
  jboolean closed_;
  LibOrgBouncycastleBcpgArmoredOutputStream *armorOutputStream_;
  JavaIoOutputStream *publicKeyEncryptedStream_;
  LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator *compressedDataGenerator_;
  LibOrgBouncycastleBcpgBCPGOutputStream *basicCompressionStream_;
  LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator *literalDataGenerator_;
  JavaIoOutputStream *literalDataStream_;
}

@end

J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, result_, LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, signatureGenerators_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, armorOutputStream_, LibOrgBouncycastleBcpgArmoredOutputStream *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, publicKeyEncryptedStream_, JavaIoOutputStream *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, compressedDataGenerator_, LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, basicCompressionStream_, LibOrgBouncycastleBcpgBCPGOutputStream *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, literalDataGenerator_, LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionStream, literalDataStream_, JavaIoOutputStream *)

inline JavaUtilLoggingLogger *LibComAfterlogicPgpEncryption_signingEncryptionStream_get_LOGGER(void);
static JavaUtilLoggingLogger *LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibComAfterlogicPgpEncryption_signingEncryptionStream, LOGGER, JavaUtilLoggingLogger *)

inline JavaUtilLoggingLevel *LibComAfterlogicPgpEncryption_signingEncryptionStream_get_LEVEL(void);
static JavaUtilLoggingLevel *LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibComAfterlogicPgpEncryption_signingEncryptionStream, LEVEL, JavaUtilLoggingLevel *)

inline jint LibComAfterlogicPgpEncryption_signingEncryptionStream_get_BUFFER_SIZE(void);
#define LibComAfterlogicPgpEncryption_signingEncryptionStream_BUFFER_SIZE 256
J2OBJC_STATIC_FIELD_CONSTANT(LibComAfterlogicPgpEncryption_signingEncryptionStream, BUFFER_SIZE, jint)

J2OBJC_INITIALIZED_DEFN(LibComAfterlogicPgpEncryption_signingEncryptionStream)

@implementation LibComAfterlogicPgpEncryption_signingEncryptionStream

- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)targetOutputStream
                           withJavaUtilSet:(id<JavaUtilSet>)encryptionKeys
                           withJavaUtilSet:(id<JavaUtilSet>)signingKeys
withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *)symmetricKeyAlgorithm
withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *)hashAlgorithmUtil
withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:(LibComAfterlogicPgpAlgorithmCompressionAlgorithm *)compressionAlgorithm
                               withBoolean:(jboolean)asciiArmor {
  LibComAfterlogicPgpEncryption_signingEncryptionStream_initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_(self, targetOutputStream, encryptionKeys, signingKeys, symmetricKeyAlgorithm, hashAlgorithmUtil, compressionAlgorithm, asciiArmor);
  return self;
}

- (void)writeWithInt:(jint)data {
  [((JavaIoOutputStream *) nil_chk(literalDataStream_)) writeWithInt:data];
  for (LibOrgBouncycastleOpenpgpPGPSignatureGenerator * __strong signatureGenerator in nil_chk(signatureGenerators_)) {
    jbyte asByte = (jbyte) (data & (jint) 0xff);
    [((LibOrgBouncycastleOpenpgpPGPSignatureGenerator *) nil_chk(signatureGenerator)) updateWithByte:asByte];
  }
}

- (void)writeWithByteArray:(IOSByteArray *)buffer {
  [self writeWithByteArray:buffer withInt:0 withInt:((IOSByteArray *) nil_chk(buffer))->size_];
}

- (void)writeWithByteArray:(IOSByteArray *)buffer
                   withInt:(jint)off
                   withInt:(jint)len {
  [((JavaIoOutputStream *) nil_chk(literalDataStream_)) writeWithByteArray:buffer withInt:0 withInt:len];
  for (LibOrgBouncycastleOpenpgpPGPSignatureGenerator * __strong signatureGenerator in nil_chk(signatureGenerators_)) {
    [((LibOrgBouncycastleOpenpgpPGPSignatureGenerator *) nil_chk(signatureGenerator)) updateWithByteArray:buffer withInt:0 withInt:len];
  }
}

- (void)flush {
  [((JavaIoOutputStream *) nil_chk(literalDataStream_)) flush];
}

- (void)close {
  if (!closed_) {
    [((JavaIoOutputStream *) nil_chk(literalDataStream_)) flush];
    [((JavaIoOutputStream *) nil_chk(literalDataStream_)) close];
    [((LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator *) nil_chk(literalDataGenerator_)) close];
    for (LibOrgBouncycastleOpenpgpPGPSignatureGenerator * __strong signatureGenerator in nil_chk(signatureGenerators_)) {
      @try {
        [((LibOrgBouncycastleOpenpgpPGPSignature *) nil_chk([((LibOrgBouncycastleOpenpgpPGPSignatureGenerator *) nil_chk(signatureGenerator)) generate])) encodeWithJavaIoOutputStream:basicCompressionStream_];
      }
      @catch (LibOrgBouncycastleOpenpgpPGPException *e) {
        @throw new_JavaIoIOException_initWithJavaLangThrowable_(e);
      }
    }
    [((LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator *) nil_chk(compressedDataGenerator_)) close];
    if (publicKeyEncryptedStream_ != nil) {
      [publicKeyEncryptedStream_ flush];
      [((JavaIoOutputStream *) nil_chk(publicKeyEncryptedStream_)) close];
    }
    if (armorOutputStream_ != nil) {
      [armorOutputStream_ flush];
      [((LibOrgBouncycastleBcpgArmoredOutputStream *) nil_chk(armorOutputStream_)) close];
    }
    closed_ = true;
  }
}

- (LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata *)getResult {
  return result_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, 1, 2, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 6, 5, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 7, 5, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 5, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 5, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpDecryption_verificationOpenPgpMetadata;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoOutputStream:withJavaUtilSet:withJavaUtilSet:withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:withBoolean:);
  methods[1].selector = @selector(writeWithInt:);
  methods[2].selector = @selector(writeWithByteArray:);
  methods[3].selector = @selector(writeWithByteArray:withInt:withInt:);
  methods[4].selector = @selector(flush);
  methods[5].selector = @selector(close);
  methods[6].selector = @selector(getResult);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "LOGGER", "LJavaUtilLoggingLogger;", .constantValue.asLong = 0, 0x1a, -1, 8, -1, -1 },
    { "LEVEL", "LJavaUtilLoggingLevel;", .constantValue.asLong = 0, 0x1a, -1, 9, -1, -1 },
    { "BUFFER_SIZE", "I", .constantValue.asInt = LibComAfterlogicPgpEncryption_signingEncryptionStream_BUFFER_SIZE, 0x1a, -1, -1, -1, -1 },
    { "result_", "LLibComAfterlogicPgpDecryption_verificationOpenPgpMetadata;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "signatureGenerators_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 10, -1 },
    { "closed_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "armorOutputStream_", "LLibOrgBouncycastleBcpgArmoredOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "publicKeyEncryptedStream_", "LJavaIoOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "compressedDataGenerator_", "LLibOrgBouncycastleOpenpgpPGPCompressedDataGenerator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "basicCompressionStream_", "LLibOrgBouncycastleBcpgBCPGOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "literalDataGenerator_", "LLibOrgBouncycastleOpenpgpPGPLiteralDataGenerator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "literalDataStream_", "LJavaIoOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoOutputStream;LJavaUtilSet;LJavaUtilSet;LLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm;LLibComAfterlogicPgpAlgorithmHashAlgorithmUtil;LLibComAfterlogicPgpAlgorithmCompressionAlgorithm;Z", "LJavaIoIOException;LLibOrgBouncycastleOpenpgpPGPException;", "(Ljava/io/OutputStream;Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPublicKey;>;Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPrivateKey;>;Llib/com/afterlogic/pgp/algorithm/SymmetricKeyAlgorithm;Llib/com/afterlogic/pgp/algorithm/HashAlgorithmUtil;Llib/com/afterlogic/pgp/algorithm/CompressionAlgorithm;Z)V", "write", "I", "LJavaIoIOException;", "[B", "[BII", &LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER, &LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL, "Ljava/util/List<Llib/org/bouncycastle/openpgp/PGPSignatureGenerator;>;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionStream = { "EncryptionStream", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x11, 7, 12, -1, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionStream;
}

+ (void)initialize {
  if (self == [LibComAfterlogicPgpEncryption_signingEncryptionStream class]) {
    LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER = JavaUtilLoggingLogger_getLoggerWithNSString_([LibComAfterlogicPgpEncryption_signingEncryptionStream_class_() getName]);
    LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL = JreLoadStatic(JavaUtilLoggingLevel, FINE);
    J2OBJC_SET_INITIALIZED(LibComAfterlogicPgpEncryption_signingEncryptionStream)
  }
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionStream_initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_(LibComAfterlogicPgpEncryption_signingEncryptionStream *self, JavaIoOutputStream *targetOutputStream, id<JavaUtilSet> encryptionKeys, id<JavaUtilSet> signingKeys, LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *symmetricKeyAlgorithm, LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *hashAlgorithmUtil, LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm, jboolean asciiArmor) {
  JavaIoOutputStream_init(self);
  self->signatureGenerators_ = new_JavaUtilArrayList_init();
  self->closed_ = false;
  self->armorOutputStream_ = nil;
  self->publicKeyEncryptedStream_ = nil;
  JavaIoOutputStream *outerMostStream;
  if (asciiArmor) {
    [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:@"Wrap encryption inputStream in ASCII armor"];
    self->armorOutputStream_ = new_LibOrgBouncycastleBcpgArmoredOutputStream_initWithJavaIoOutputStream_(targetOutputStream);
    outerMostStream = self->armorOutputStream_;
  }
  else {
    [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:@"Encryption inputStream will be binary"];
    outerMostStream = targetOutputStream;
  }
  if (![((id<JavaUtilSet>) nil_chk(encryptionKeys)) isEmpty]) {
    [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:JreStrcat("$@", @"At least one encryption key is available -> encrypt using ", symmetricKeyAlgorithm)];
    LibOrgBouncycastleOpenpgpOperatorBcBcPGPDataEncryptorBuilder *dataEncryptorBuilder = new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPDataEncryptorBuilder_initWithInt_([((LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *) nil_chk(symmetricKeyAlgorithm)) getAlgorithmId]);
    [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:@"Integrity protection enabled"];
    (void) [dataEncryptorBuilder setWithIntegrityPacketWithBoolean:true];
    LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator *encryptedDataGenerator = new_LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPDataEncryptorBuilder_(dataEncryptorBuilder);
    for (LibOrgBouncycastleOpenpgpPGPPublicKey * __strong key in encryptionKeys) {
      [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:JreStrcat("$$", @"Encrypt for key ", JavaLangLong_toHexStringWithLong_([((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(key)) getKeyID]))];
      [encryptedDataGenerator addMethodWithLibOrgBouncycastleOpenpgpOperatorPGPKeyEncryptionMethodGenerator:new_LibOrgBouncycastleOpenpgpOperatorBcBcPublicKeyKeyEncryptionMethodGenerator_initWithLibOrgBouncycastleOpenpgpPGPPublicKey_(key)];
    }
    self->publicKeyEncryptedStream_ = [encryptedDataGenerator openWithJavaIoOutputStream:outerMostStream withByteArray:[IOSByteArray newArrayWithLength:LibComAfterlogicPgpEncryption_signingEncryptionStream_BUFFER_SIZE]];
    outerMostStream = self->publicKeyEncryptedStream_;
  }
  if (![((id<JavaUtilSet>) nil_chk(signingKeys)) isEmpty]) {
    [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:JreStrcat("$@$", @"At least one signing key is available -> addSignature ", hashAlgorithmUtil, @" hash of message")];
    for (LibOrgBouncycastleOpenpgpPGPPrivateKey * __strong privateKey in signingKeys) {
      [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:JreStrcat("$$", @"Sign using key ", JavaLangLong_toHexStringWithLong_([((LibOrgBouncycastleOpenpgpPGPPrivateKey *) nil_chk(privateKey)) getKeyID]))];
      LibOrgBouncycastleOpenpgpOperatorBcBcPGPContentSignerBuilder *contentSignerBuilder = new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPContentSignerBuilder_initWithInt_withInt_([((LibOrgBouncycastleBcpgPublicKeyPacket *) nil_chk([privateKey getPublicKeyPacket])) getAlgorithm], [((LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *) nil_chk(hashAlgorithmUtil)) getAlgorithmId]);
      LibOrgBouncycastleOpenpgpPGPSignatureGenerator *signatureGenerator = new_LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(contentSignerBuilder);
      [signatureGenerator init__WithInt:LibOrgBouncycastleOpenpgpPGPSignature_CANONICAL_TEXT_DOCUMENT withLibOrgBouncycastleOpenpgpPGPPrivateKey:privateKey];
      [((id<JavaUtilList>) nil_chk(self->signatureGenerators_)) addWithId:signatureGenerator];
    }
  }
  [LibComAfterlogicPgpEncryption_signingEncryptionStream_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpEncryption_signingEncryptionStream_LEVEL withNSString:JreStrcat("$@", @"Compress using ", compressionAlgorithm)];
  self->compressedDataGenerator_ = new_LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator_initWithInt_([((LibComAfterlogicPgpAlgorithmCompressionAlgorithm *) nil_chk(compressionAlgorithm)) getAlgorithmId]);
  self->basicCompressionStream_ = new_LibOrgBouncycastleBcpgBCPGOutputStream_initWithJavaIoOutputStream_([self->compressedDataGenerator_ openWithJavaIoOutputStream:outerMostStream]);
  for (LibOrgBouncycastleOpenpgpPGPSignatureGenerator * __strong signatureGenerator in nil_chk(self->signatureGenerators_)) {
    [((LibOrgBouncycastleOpenpgpPGPOnePassSignature *) nil_chk([((LibOrgBouncycastleOpenpgpPGPSignatureGenerator *) nil_chk(signatureGenerator)) generateOnePassVersionWithBoolean:false])) encodeWithJavaIoOutputStream:self->basicCompressionStream_];
  }
  self->literalDataGenerator_ = new_LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator_init();
  self->literalDataStream_ = [self->literalDataGenerator_ openWithJavaIoOutputStream:self->basicCompressionStream_ withChar:LibOrgBouncycastleOpenpgpPGPLiteralData_BINARY withNSString:LibOrgBouncycastleOpenpgpPGPLiteralData_CONSOLE withJavaUtilDate:new_JavaUtilDate_init() withByteArray:[IOSByteArray newArrayWithLength:LibComAfterlogicPgpEncryption_signingEncryptionStream_BUFFER_SIZE]];
  id<JavaUtilSet> recipientKeyIds = new_JavaUtilHashSet_init();
  for (LibOrgBouncycastleOpenpgpPGPPublicKey * __strong recipient in encryptionKeys) {
    [recipientKeyIds addWithId:JavaLangLong_valueOfWithLong_([((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(recipient)) getKeyID])];
  }
  id<JavaUtilSet> signingKeyIds = new_JavaUtilHashSet_init();
  for (LibOrgBouncycastleOpenpgpPGPPrivateKey * __strong signer in signingKeys) {
    [signingKeyIds addWithId:JavaLangLong_valueOfWithLong_([((LibOrgBouncycastleOpenpgpPGPPrivateKey *) nil_chk(signer)) getKeyID])];
  }
  self->result_ = new_LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_initWithJavaUtilSet_withLibComAfterlogicPgpKeyOpenPgpV4Fingerprint_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_withJavaUtilSet_withJavaUtilSet_(recipientKeyIds, nil, symmetricKeyAlgorithm, compressionAlgorithm, true, signingKeyIds, JavaUtilCollections_emptySet());
}

LibComAfterlogicPgpEncryption_signingEncryptionStream *new_LibComAfterlogicPgpEncryption_signingEncryptionStream_initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_(JavaIoOutputStream *targetOutputStream, id<JavaUtilSet> encryptionKeys, id<JavaUtilSet> signingKeys, LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *symmetricKeyAlgorithm, LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *hashAlgorithmUtil, LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm, jboolean asciiArmor) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionStream, initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_, targetOutputStream, encryptionKeys, signingKeys, symmetricKeyAlgorithm, hashAlgorithmUtil, compressionAlgorithm, asciiArmor)
}

LibComAfterlogicPgpEncryption_signingEncryptionStream *create_LibComAfterlogicPgpEncryption_signingEncryptionStream_initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_(JavaIoOutputStream *targetOutputStream, id<JavaUtilSet> encryptionKeys, id<JavaUtilSet> signingKeys, LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *symmetricKeyAlgorithm, LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *hashAlgorithmUtil, LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm, jboolean asciiArmor) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionStream, initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_, targetOutputStream, encryptionKeys, signingKeys, symmetricKeyAlgorithm, hashAlgorithmUtil, compressionAlgorithm, asciiArmor)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionStream)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/DTLSProtocol.java
//

#include "AlertDescription.h"
#include "Arrays.h"
#include "Certificate.h"
#include "DTLSProtocol.h"
#include "DTLSRecordLayer.h"
#include "EncryptionAlgorithm.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "MaxFragmentLength.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsProtocol.h"
#include "TlsUtils.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/security/SecureRandom.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@implementation LibOrgBouncycastleCryptoTlsDTLSProtocol

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (void)processFinishedWithByteArray:(IOSByteArray *)body
                       withByteArray:(IOSByteArray *)expected_verify_data {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  IOSByteArray *verify_data = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(((IOSByteArray *) nil_chk(expected_verify_data))->size_, buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(expected_verify_data, verify_data)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
}

+ (void)applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)recordLayer
                                                                            withShort:(jshort)maxFragmentLength {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_withShort_(recordLayer, maxFragmentLength);
}

+ (jshort)evaluateMaxFragmentLengthExtensionWithBoolean:(jboolean)resumedSession
                                  withJavaUtilHashtable:(JavaUtilHashtable *)clientExtensions
                                  withJavaUtilHashtable:(JavaUtilHashtable *)serverExtensions
                                              withShort:(jshort)alertDescription {
  return LibOrgBouncycastleCryptoTlsDTLSProtocol_evaluateMaxFragmentLengthExtensionWithBoolean_withJavaUtilHashtable_withJavaUtilHashtable_withShort_(resumedSession, clientExtensions, serverExtensions, alertDescription);
}

+ (IOSByteArray *)generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate:(LibOrgBouncycastleCryptoTlsCertificate *)certificate {
  return LibOrgBouncycastleCryptoTlsDTLSProtocol_generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate_(certificate);
}

+ (IOSByteArray *)generateSupplementalDataWithJavaUtilVector:(JavaUtilVector *)supplementalData {
  return LibOrgBouncycastleCryptoTlsDTLSProtocol_generateSupplementalDataWithJavaUtilVector_(supplementalData);
}

+ (void)validateSelectedCipherSuiteWithInt:(jint)selectedCipherSuite
                                 withShort:(jshort)alertDescription {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_validateSelectedCipherSuiteWithInt_withShort_(selectedCipherSuite, alertDescription);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0xc, 4, 5, 3, -1, -1, -1 },
    { NULL, "S", 0xc, 6, 7, 3, -1, -1, -1 },
    { NULL, "[B", 0xc, 8, 9, 3, -1, -1, -1 },
    { NULL, "[B", 0xc, 10, 11, 3, -1, -1, -1 },
    { NULL, "V", 0xc, 12, 13, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[1].selector = @selector(processFinishedWithByteArray:withByteArray:);
  methods[2].selector = @selector(applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer:withShort:);
  methods[3].selector = @selector(evaluateMaxFragmentLengthExtensionWithBoolean:withJavaUtilHashtable:withJavaUtilHashtable:withShort:);
  methods[4].selector = @selector(generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate:);
  methods[5].selector = @selector(generateSupplementalDataWithJavaUtilVector:);
  methods[6].selector = @selector(validateSelectedCipherSuiteWithInt:withShort:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "secureRandom_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaSecuritySecureRandom;", "processFinished", "[B[B", "LJavaIoIOException;", "applyMaxFragmentLengthExtension", "LLibOrgBouncycastleCryptoTlsDTLSRecordLayer;S", "evaluateMaxFragmentLengthExtension", "ZLJavaUtilHashtable;LJavaUtilHashtable;S", "generateCertificate", "LLibOrgBouncycastleCryptoTlsCertificate;", "generateSupplementalData", "LJavaUtilVector;", "validateSelectedCipherSuite", "IS" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSProtocol = { "DTLSProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x401, 7, 1, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSProtocol;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsDTLSProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  NSObject_init(self);
  if (secureRandom == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'secureRandom' cannot be null");
  }
  self->secureRandom_ = secureRandom;
}

void LibOrgBouncycastleCryptoTlsDTLSProtocol_applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_withShort_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *recordLayer, jshort maxFragmentLength) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initialize();
  if (maxFragmentLength >= 0) {
    if (!LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(maxFragmentLength)) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
    }
    jint plainTextLimit = JreLShift32(1, (8 + maxFragmentLength));
    [((LibOrgBouncycastleCryptoTlsDTLSRecordLayer *) nil_chk(recordLayer)) setPlaintextLimitWithInt:plainTextLimit];
  }
}

jshort LibOrgBouncycastleCryptoTlsDTLSProtocol_evaluateMaxFragmentLengthExtensionWithBoolean_withJavaUtilHashtable_withJavaUtilHashtable_withShort_(jboolean resumedSession, JavaUtilHashtable *clientExtensions, JavaUtilHashtable *serverExtensions, jshort alertDescription) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initialize();
  jshort maxFragmentLength = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getMaxFragmentLengthExtensionWithJavaUtilHashtable_(serverExtensions);
  if (maxFragmentLength >= 0) {
    if (!LibOrgBouncycastleCryptoTlsMaxFragmentLength_isValidWithShort_(maxFragmentLength) || (!resumedSession && maxFragmentLength != LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getMaxFragmentLengthExtensionWithJavaUtilHashtable_(clientExtensions))) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(alertDescription);
    }
  }
  return maxFragmentLength;
}

IOSByteArray *LibOrgBouncycastleCryptoTlsDTLSProtocol_generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate_(LibOrgBouncycastleCryptoTlsCertificate *certificate) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initialize();
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(certificate)) encodeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

IOSByteArray *LibOrgBouncycastleCryptoTlsDTLSProtocol_generateSupplementalDataWithJavaUtilVector_(JavaUtilVector *supplementalData) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initialize();
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeSupplementalDataWithJavaIoOutputStream_withJavaUtilVector_(buf, supplementalData);
  return [buf toByteArray];
}

void LibOrgBouncycastleCryptoTlsDTLSProtocol_validateSelectedCipherSuiteWithInt_withShort_(jint selectedCipherSuite, jshort alertDescription) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initialize();
  switch (LibOrgBouncycastleCryptoTlsTlsUtils_getEncryptionAlgorithmWithInt_(selectedCipherSuite)) {
    case LibOrgBouncycastleCryptoTlsEncryptionAlgorithm_RC4_40:
    case LibOrgBouncycastleCryptoTlsEncryptionAlgorithm_RC4_128:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(alertDescription);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSProtocol)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/engines/NaccacheSternEngine.java
//

#include "Arrays.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "NaccacheSternEngine.h"
#include "NaccacheSternKeyParameters.h"
#include "NaccacheSternPrivateKeyParameters.h"
#include "ParametersWithRandom.h"
#include "java/io/PrintStream.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/util/Vector.h"

@interface LibOrgBouncycastleCryptoEnginesNaccacheSternEngine () {
 @public
  jboolean forEncryption_;
  LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *key_;
  IOSObjectArray *lookup_;
  jboolean debug_;
}

+ (JavaMathBigInteger *)chineseRemainderWithJavaUtilVector:(JavaUtilVector *)congruences
                                        withJavaUtilVector:(JavaUtilVector *)primes;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, key_, LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, lookup_, IOSObjectArray *)

inline JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_get_ZERO(void);
inline JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_set_ZERO(JavaMathBigInteger *value);
static JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ZERO;
J2OBJC_STATIC_FIELD_OBJ(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, ZERO, JavaMathBigInteger *)

inline JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_get_ONE(void);
inline JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_set_ONE(JavaMathBigInteger *value);
static JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ONE;
J2OBJC_STATIC_FIELD_OBJ(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, ONE, JavaMathBigInteger *)

__attribute__((unused)) static JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_chineseRemainderWithJavaUtilVector_withJavaUtilVector_(JavaUtilVector *congruences, JavaUtilVector *primes);

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine)

@implementation LibOrgBouncycastleCryptoEnginesNaccacheSternEngine

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)param {
  self->forEncryption_ = forEncryption;
  if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithRandom class]]) {
    param = [((LibOrgBouncycastleCryptoParamsParametersWithRandom *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithRandom *) param))) getParameters];
  }
  key_ = (LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) cast_chk(param, [LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters class]);
  if (!self->forEncryption_) {
    if (debug_) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"Constructing lookup Array"];
    }
    LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *priv = (LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters class]);
    JavaUtilVector *primes = [((LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *) nil_chk(priv)) getSmallPrimes];
    lookup_ = [IOSObjectArray newArrayWithLength:[((JavaUtilVector *) nil_chk(primes)) size] type:JavaUtilVector_class_()];
    for (jint i = 0; i < [primes size]; i++) {
      JavaMathBigInteger *actualPrime = (JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class]);
      jint actualPrimeValue = [((JavaMathBigInteger *) nil_chk(actualPrime)) intValue];
      (void) IOSObjectArray_SetAndConsume(nil_chk(lookup_), i, new_JavaUtilVector_init());
      [((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) addElementWithId:LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ONE];
      if (debug_) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I", @"Constructing lookup ArrayList for ", actualPrimeValue)];
      }
      JavaMathBigInteger *accJ = LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ZERO;
      for (jint j = 1; j < actualPrimeValue; j++) {
        accJ = [((JavaMathBigInteger *) nil_chk(accJ)) addWithJavaMathBigInteger:[priv getPhi_n]];
        JavaMathBigInteger *comp = [((JavaMathBigInteger *) nil_chk(accJ)) divideWithJavaMathBigInteger:actualPrime];
        [((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) addElementWithId:[((JavaMathBigInteger *) nil_chk([priv getG])) modPowWithJavaMathBigInteger:comp withJavaMathBigInteger:[priv getModulus]]];
      }
    }
  }
}

- (void)setDebugWithBoolean:(jboolean)debug {
  self->debug_ = debug;
}

- (jint)getInputBlockSize {
  if (forEncryption_) {
    return ([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getLowerSigmaBound] + 7) / 8 - 1;
  }
  else {
    return ((IOSByteArray *) nil_chk([((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus])) toByteArray]))->size_;
  }
}

- (jint)getOutputBlockSize {
  if (forEncryption_) {
    return ((IOSByteArray *) nil_chk([((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus])) toByteArray]))->size_;
  }
  else {
    return ([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getLowerSigmaBound] + 7) / 8 - 1;
  }
}

- (IOSByteArray *)processBlockWithByteArray:(IOSByteArray *)inArg
                                    withInt:(jint)inOff
                                    withInt:(jint)len {
  if (key_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"NaccacheStern engine not initialised");
  }
  if (len > ([self getInputBlockSize] + 1)) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input too large for Naccache-Stern cipher.\n");
  }
  if (!forEncryption_) {
    if (len < [self getInputBlockSize]) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"BlockLength does not match modulus for Naccache-Stern cipher.\n");
    }
  }
  IOSByteArray *block;
  if (inOff != 0 || len != ((IOSByteArray *) nil_chk(inArg))->size_) {
    block = [IOSByteArray newArrayWithLength:len];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff, block, 0, len);
  }
  else {
    block = inArg;
  }
  JavaMathBigInteger *input = new_JavaMathBigInteger_initWithInt_withByteArray_(1, block);
  if (debug_) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"input as BigInteger: ", input)];
  }
  IOSByteArray *output;
  if (forEncryption_) {
    output = [self encryptWithJavaMathBigInteger:input];
  }
  else {
    JavaUtilVector *plain = new_JavaUtilVector_init();
    LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *priv = (LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters class]);
    JavaUtilVector *primes = [((LibOrgBouncycastleCryptoParamsNaccacheSternPrivateKeyParameters *) nil_chk(priv)) getSmallPrimes];
    for (jint i = 0; i < [((JavaUtilVector *) nil_chk(primes)) size]; i++) {
      JavaMathBigInteger *exp = [input modPowWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([priv getPhi_n])) divideWithJavaMathBigInteger:(JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class])] withJavaMathBigInteger:[priv getModulus]];
      JavaUtilVector *al = IOSObjectArray_Get(nil_chk(lookup_), i);
      if ([((JavaUtilVector *) nil_chk(IOSObjectArray_Get(lookup_, i))) size] != [((JavaMathBigInteger *) nil_chk(((JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class])))) intValue]) {
        if (debug_) {
          [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@$I", @"Prime is ", [primes elementAtWithInt:i], @", lookup table has size ", [((JavaUtilVector *) nil_chk(al)) size])];
        }
        @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(JreStrcat("$I$I$I", @"Error in lookup Array for ", [((JavaMathBigInteger *) nil_chk(((JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class])))) intValue], @": Size mismatch. Expected ArrayList with length ", [((JavaMathBigInteger *) nil_chk(((JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class])))) intValue], @" but found ArrayList of length ", [((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) size]));
      }
      jint lookedup = [((JavaUtilVector *) nil_chk(al)) indexOfWithId:exp];
      if (lookedup == -1) {
        if (debug_) {
          [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Actual prime is ", [primes elementAtWithInt:i])];
          [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Decrypted value is ", exp)];
          [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@$I$", @"LookupList for ", [primes elementAtWithInt:i], @" with size ", [((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) size], @" is: ")];
          for (jint j = 0; j < [((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) size]; j++) {
            [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithId:[((JavaUtilVector *) nil_chk(IOSObjectArray_Get(nil_chk(lookup_), i))) elementAtWithInt:j]];
          }
        }
        @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"Lookup failed");
      }
      [plain addElementWithId:JavaMathBigInteger_valueOfWithLong_(lookedup)];
    }
    JavaMathBigInteger *test = LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_chineseRemainderWithJavaUtilVector_withJavaUtilVector_(plain, primes);
    output = [((JavaMathBigInteger *) nil_chk(test)) toByteArray];
  }
  return output;
}

- (IOSByteArray *)encryptWithJavaMathBigInteger:(JavaMathBigInteger *)plain {
  IOSByteArray *output = [((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus])) toByteArray];
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(output, (jbyte) 0);
  IOSByteArray *tmp = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getG])) modPowWithJavaMathBigInteger:plain withJavaMathBigInteger:[((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus]])) toByteArray];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, output, ((IOSByteArray *) nil_chk(output))->size_ - ((IOSByteArray *) nil_chk(tmp))->size_, tmp->size_);
  if (debug_) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"Encrypted value is:  ", new_JavaMathBigInteger_initWithByteArray_(output))];
  }
  return output;
}

- (IOSByteArray *)addCryptedBlocksWithByteArray:(IOSByteArray *)block1
                                  withByteArray:(IOSByteArray *)block2 {
  if (forEncryption_) {
    if ((((IOSByteArray *) nil_chk(block1))->size_ > [self getOutputBlockSize]) || (((IOSByteArray *) nil_chk(block2))->size_ > [self getOutputBlockSize])) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"BlockLength too large for simple addition.\n");
    }
  }
  else {
    if ((((IOSByteArray *) nil_chk(block1))->size_ > [self getInputBlockSize]) || (((IOSByteArray *) nil_chk(block2))->size_ > [self getInputBlockSize])) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"BlockLength too large for simple addition.\n");
    }
  }
  JavaMathBigInteger *m1Crypt = new_JavaMathBigInteger_initWithInt_withByteArray_(1, block1);
  JavaMathBigInteger *m2Crypt = new_JavaMathBigInteger_initWithInt_withByteArray_(1, block2);
  JavaMathBigInteger *m1m2Crypt = [m1Crypt multiplyWithJavaMathBigInteger:m2Crypt];
  m1m2Crypt = [((JavaMathBigInteger *) nil_chk(m1m2Crypt)) modWithJavaMathBigInteger:[((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus]];
  if (debug_) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"c(m1) as BigInteger:....... ", m1Crypt)];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"c(m2) as BigInteger:....... ", m2Crypt)];
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"c(m1)*c(m2)%n = c(m1+m2)%n: ", m1m2Crypt)];
  }
  IOSByteArray *output = [((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters *) nil_chk(key_)) getModulus])) toByteArray];
  LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(output, (jbyte) 0);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((JavaMathBigInteger *) nil_chk(m1m2Crypt)) toByteArray], 0, output, ((IOSByteArray *) nil_chk(output))->size_ - ((IOSByteArray *) nil_chk([m1m2Crypt toByteArray]))->size_, ((IOSByteArray *) nil_chk([m1m2Crypt toByteArray]))->size_);
  return output;
}

- (IOSByteArray *)processDataWithByteArray:(IOSByteArray *)data {
  if (debug_) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) println];
  }
  if (((IOSByteArray *) nil_chk(data))->size_ > [self getInputBlockSize]) {
    jint inBlocksize = [self getInputBlockSize];
    jint outBlocksize = [self getOutputBlockSize];
    if (debug_) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I$", @"Input blocksize is:  ", inBlocksize, @" bytes")];
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I$", @"Output blocksize is: ", outBlocksize, @" bytes")];
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I$", @"Data has length:.... ", data->size_, @" bytes")];
    }
    jint datapos = 0;
    jint retpos = 0;
    IOSByteArray *retval = [IOSByteArray newArrayWithLength:(data->size_ / inBlocksize + 1) * outBlocksize];
    while (datapos < data->size_) {
      IOSByteArray *tmp;
      if (datapos + inBlocksize < data->size_) {
        tmp = [self processBlockWithByteArray:data withInt:datapos withInt:inBlocksize];
        datapos += inBlocksize;
      }
      else {
        tmp = [self processBlockWithByteArray:data withInt:datapos withInt:data->size_ - datapos];
        datapos += data->size_ - datapos;
      }
      if (debug_) {
        [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I", @"new datapos is ", datapos)];
      }
      if (tmp != nil) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, retval, retpos, tmp->size_);
        retpos += tmp->size_;
      }
      else {
        if (debug_) {
          [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"cipher returned null"];
        }
        @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"cipher returned null");
      }
    }
    IOSByteArray *ret = [IOSByteArray newArrayWithLength:retpos];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(retval, 0, ret, 0, retpos);
    if (debug_) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$I$", @"returning ", ret->size_, @" bytes")];
    }
    return ret;
  }
  else {
    if (debug_) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:@"data size is less then input block size, processing directly"];
    }
    return [self processBlockWithByteArray:data withInt:0 withInt:data->size_];
  }
}

+ (JavaMathBigInteger *)chineseRemainderWithJavaUtilVector:(JavaUtilVector *)congruences
                                        withJavaUtilVector:(JavaUtilVector *)primes {
  return LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_chineseRemainderWithJavaUtilVector_withJavaUtilVector_(congruences, primes);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "[B", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 9, 10, 6, -1, -1, -1 },
    { NULL, "[B", 0x1, 11, 12, 6, -1, -1, -1 },
    { NULL, "LJavaMathBigInteger;", 0xa, 13, 14, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[2].selector = @selector(setDebugWithBoolean:);
  methods[3].selector = @selector(getInputBlockSize);
  methods[4].selector = @selector(getOutputBlockSize);
  methods[5].selector = @selector(processBlockWithByteArray:withInt:withInt:);
  methods[6].selector = @selector(encryptWithJavaMathBigInteger:);
  methods[7].selector = @selector(addCryptedBlocksWithByteArray:withByteArray:);
  methods[8].selector = @selector(processDataWithByteArray:);
  methods[9].selector = @selector(chineseRemainderWithJavaUtilVector:withJavaUtilVector:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "key_", "LLibOrgBouncycastleCryptoParamsNaccacheSternKeyParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lookup_", "[LJavaUtilVector;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "debug_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ZERO", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0xa, -1, 15, -1, -1 },
    { "ONE", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0xa, -1, 16, -1, -1 },
  };
  static const void *ptrTable[] = { "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "setDebug", "Z", "processBlock", "[BII", "LLibOrgBouncycastleCryptoInvalidCipherTextException;", "encrypt", "LJavaMathBigInteger;", "addCryptedBlocks", "[B[B", "processData", "[B", "chineseRemainder", "LJavaUtilVector;LJavaUtilVector;", &LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ZERO, &LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ONE };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEnginesNaccacheSternEngine = { "NaccacheSternEngine", "lib.org.bouncycastle.crypto.engines", ptrTable, methods, fields, 7, 0x1, 10, 6, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEnginesNaccacheSternEngine;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoEnginesNaccacheSternEngine class]) {
    LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ZERO = JavaMathBigInteger_valueOfWithLong_(0);
    LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ONE = JavaMathBigInteger_valueOfWithLong_(1);
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine)
  }
}

@end

void LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_init(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine *self) {
  NSObject_init(self);
  self->lookup_ = nil;
  self->debug_ = false;
}

LibOrgBouncycastleCryptoEnginesNaccacheSternEngine *new_LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, init)
}

LibOrgBouncycastleCryptoEnginesNaccacheSternEngine *create_LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine, init)
}

JavaMathBigInteger *LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_chineseRemainderWithJavaUtilVector_withJavaUtilVector_(JavaUtilVector *congruences, JavaUtilVector *primes) {
  LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_initialize();
  JavaMathBigInteger *retval = LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ZERO;
  JavaMathBigInteger *all = LibOrgBouncycastleCryptoEnginesNaccacheSternEngine_ONE;
  for (jint i = 0; i < [((JavaUtilVector *) nil_chk(primes)) size]; i++) {
    all = [((JavaMathBigInteger *) nil_chk(all)) multiplyWithJavaMathBigInteger:(JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class])];
  }
  for (jint i = 0; i < [primes size]; i++) {
    JavaMathBigInteger *a = (JavaMathBigInteger *) cast_chk([primes elementAtWithInt:i], [JavaMathBigInteger class]);
    JavaMathBigInteger *b = [((JavaMathBigInteger *) nil_chk(all)) divideWithJavaMathBigInteger:a];
    JavaMathBigInteger *b_ = [((JavaMathBigInteger *) nil_chk(b)) modInverseWithJavaMathBigInteger:a];
    JavaMathBigInteger *tmp = [b multiplyWithJavaMathBigInteger:b_];
    tmp = [((JavaMathBigInteger *) nil_chk(tmp)) multiplyWithJavaMathBigInteger:(JavaMathBigInteger *) cast_chk([((JavaUtilVector *) nil_chk(congruences)) elementAtWithInt:i], [JavaMathBigInteger class])];
    retval = [((JavaMathBigInteger *) nil_chk(retval)) addWithJavaMathBigInteger:tmp];
  }
  return [((JavaMathBigInteger *) nil_chk(retval)) modWithJavaMathBigInteger:all];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoEnginesNaccacheSternEngine)

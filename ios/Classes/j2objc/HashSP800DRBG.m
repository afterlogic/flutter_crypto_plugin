//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/prng/drbg/HashSP800DRBG.java
//

#include "Arrays.h"
#include "CryptoPrngDrbgUtils.h"
#include "Digest.h"
#include "EntropySource.h"
#include "HashSP800DRBG.h"
#include "IOSPrimitiveArray.h"
#include "Integers.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/System.h"
#include "java/util/Hashtable.h"

@interface LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG () {
 @public
  id<LibOrgBouncycastleCryptoDigest> _digest_;
  IOSByteArray *_V_;
  IOSByteArray *_C_;
  jlong _reseedCounter_;
  id<LibOrgBouncycastleCryptoPrngEntropySource> _entropySource_;
  jint _securityStrength_;
  jint _seedLength_;
}

- (IOSByteArray *)getEntropy;

- (void)addToWithByteArray:(IOSByteArray *)longer
             withByteArray:(IOSByteArray *)shorter;

- (IOSByteArray *)hash__WithByteArray:(IOSByteArray *)input;

- (void)doHashWithByteArray:(IOSByteArray *)input
              withByteArray:(IOSByteArray *)output;

- (IOSByteArray *)hashgenWithByteArray:(IOSByteArray *)input
                               withInt:(jint)lengthInBits;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, _digest_, id<LibOrgBouncycastleCryptoDigest>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, _V_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, _C_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, _entropySource_, id<LibOrgBouncycastleCryptoPrngEntropySource>)

inline IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_get_ONE(void);
static IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, ONE, IOSByteArray *)

inline jlong LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_get_RESEED_MAX(void);
#define LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_RESEED_MAX 140737488355328LL
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, RESEED_MAX, jlong)

inline jint LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_get_MAX_BITS_REQUEST(void);
#define LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_MAX_BITS_REQUEST 262144
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, MAX_BITS_REQUEST, jint)

inline JavaUtilHashtable *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_get_seedlens(void);
static JavaUtilHashtable *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, seedlens, JavaUtilHashtable *)

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_getEntropy(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *longer, IOSByteArray *shorter);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hash__WithByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input);

__attribute__((unused)) static void LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_doHashWithByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input, IOSByteArray *output);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hashgenWithByteArray_withInt_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input, jint lengthInBits);

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG)

@implementation LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG

- (instancetype)initWithLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)digest
                                               withInt:(jint)securityStrength
         withLibOrgBouncycastleCryptoPrngEntropySource:(id<LibOrgBouncycastleCryptoPrngEntropySource>)entropySource
                                         withByteArray:(IOSByteArray *)personalizationString
                                         withByteArray:(IOSByteArray *)nonce {
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_(self, digest, securityStrength, entropySource, personalizationString, nonce);
  return self;
}

- (jint)getBlockSize {
  return [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(_digest_)) getDigestSize] * 8;
}

- (jint)generateWithByteArray:(IOSByteArray *)output
                withByteArray:(IOSByteArray *)additionalInput
                  withBoolean:(jboolean)predictionResistant {
  jint numberOfBits = ((IOSByteArray *) nil_chk(output))->size_ * 8;
  if (numberOfBits > LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_MAX_BITS_REQUEST) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Number of bits per request limited to ", LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_MAX_BITS_REQUEST));
  }
  if (_reseedCounter_ > LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_RESEED_MAX) {
    return -1;
  }
  if (predictionResistant) {
    [self reseedWithByteArray:additionalInput];
    additionalInput = nil;
  }
  if (additionalInput != nil) {
    IOSByteArray *newInput = [IOSByteArray newArrayWithLength:1 + ((IOSByteArray *) nil_chk(_V_))->size_ + additionalInput->size_];
    *IOSByteArray_GetRef(newInput, 0) = (jint) 0x02;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_V_, 0, newInput, 1, _V_->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(additionalInput, 0, newInput, 1 + ((IOSByteArray *) nil_chk(_V_))->size_, additionalInput->size_);
    IOSByteArray *w = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hash__WithByteArray_(self, newInput);
    LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, _V_, w);
  }
  IOSByteArray *rv = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hashgenWithByteArray_withInt_(self, _V_, numberOfBits);
  IOSByteArray *subH = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(_V_))->size_ + 1];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_V_, 0, subH, 1, _V_->size_);
  *IOSByteArray_GetRef(subH, 0) = (jint) 0x03;
  IOSByteArray *H = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hash__WithByteArray_(self, subH);
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, _V_, H);
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, _V_, _C_);
  IOSByteArray *c = [IOSByteArray newArrayWithLength:4];
  *IOSByteArray_GetRef(c, 0) = (jbyte) (JreRShift64(_reseedCounter_, 24));
  *IOSByteArray_GetRef(c, 1) = (jbyte) (JreRShift64(_reseedCounter_, 16));
  *IOSByteArray_GetRef(c, 2) = (jbyte) (JreRShift64(_reseedCounter_, 8));
  *IOSByteArray_GetRef(c, 3) = (jbyte) _reseedCounter_;
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, _V_, c);
  _reseedCounter_++;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(rv, 0, output, 0, output->size_);
  return numberOfBits;
}

- (IOSByteArray *)getEntropy {
  return LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_getEntropy(self);
}

- (void)addToWithByteArray:(IOSByteArray *)longer
             withByteArray:(IOSByteArray *)shorter {
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, longer, shorter);
}

- (void)reseedWithByteArray:(IOSByteArray *)additionalInput {
  IOSByteArray *entropy = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_getEntropy(self);
  IOSByteArray *seedMaterial = LibOrgBouncycastleUtilArrays_concatenateWithByteArray_withByteArray_withByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_ONE, _V_, entropy, additionalInput);
  IOSByteArray *seed = LibOrgBouncycastleCryptoPrngDrbgCryptoPrngDrbgUtils_hash_dfWithLibOrgBouncycastleCryptoDigest_withByteArray_withInt_(_digest_, seedMaterial, _seedLength_);
  _V_ = seed;
  IOSByteArray *subV = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(_V_))->size_ + 1];
  *IOSByteArray_GetRef(subV, 0) = (jint) 0x00;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(_V_, 0, subV, 1, _V_->size_);
  _C_ = LibOrgBouncycastleCryptoPrngDrbgCryptoPrngDrbgUtils_hash_dfWithLibOrgBouncycastleCryptoDigest_withByteArray_withInt_(_digest_, subV, _seedLength_);
  _reseedCounter_ = 1;
}

- (IOSByteArray *)hash__WithByteArray:(IOSByteArray *)input {
  return LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hash__WithByteArray_(self, input);
}

- (void)doHashWithByteArray:(IOSByteArray *)input
              withByteArray:(IOSByteArray *)output {
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_doHashWithByteArray_withByteArray_(self, input, output);
}

- (IOSByteArray *)hashgenWithByteArray:(IOSByteArray *)input
                               withInt:(jint)lengthInBits {
  return LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hashgenWithByteArray_withInt_(self, input, lengthInBits);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 7, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 4, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 9, 10, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoDigest:withInt:withLibOrgBouncycastleCryptoPrngEntropySource:withByteArray:withByteArray:);
  methods[1].selector = @selector(getBlockSize);
  methods[2].selector = @selector(generateWithByteArray:withByteArray:withBoolean:);
  methods[3].selector = @selector(getEntropy);
  methods[4].selector = @selector(addToWithByteArray:withByteArray:);
  methods[5].selector = @selector(reseedWithByteArray:);
  methods[6].selector = @selector(hash__WithByteArray:);
  methods[7].selector = @selector(doHashWithByteArray:withByteArray:);
  methods[8].selector = @selector(hashgenWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ONE", "[B", .constantValue.asLong = 0, 0x1a, -1, 11, -1, -1 },
    { "RESEED_MAX", "J", .constantValue.asLong = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_RESEED_MAX, 0x1a, -1, -1, -1, -1 },
    { "MAX_BITS_REQUEST", "I", .constantValue.asInt = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_MAX_BITS_REQUEST, 0x1a, -1, -1, -1, -1 },
    { "seedlens", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x1a, -1, 12, -1, -1 },
    { "_digest_", "LLibOrgBouncycastleCryptoDigest;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_V_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_C_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_reseedCounter_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_entropySource_", "LLibOrgBouncycastleCryptoPrngEntropySource;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_securityStrength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "_seedLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoDigest;ILLibOrgBouncycastleCryptoPrngEntropySource;[B[B", "generate", "[B[BZ", "addTo", "[B[B", "reseed", "[B", "hash", "doHash", "hashgen", "[BI", &LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_ONE, &LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG = { "HashSP800DRBG", "lib.org.bouncycastle.crypto.prng.drbg", ptrTable, methods, fields, 7, 0x1, 9, 11, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG class]) {
    LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_ONE = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jint) 0x01 } count:1];
    LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens = new_JavaUtilHashtable_init();
    {
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-1" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(440)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-224" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(440)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-256" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(440)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-512/256" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(440)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-512/224" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(440)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-384" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(888)];
      (void) [LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens putWithId:@"SHA-512" withId:LibOrgBouncycastleUtilIntegers_valueOfWithInt_(888)];
    }
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG)
  }
}

@end

void LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, id<LibOrgBouncycastleCryptoDigest> digest, jint securityStrength, id<LibOrgBouncycastleCryptoPrngEntropySource> entropySource, IOSByteArray *personalizationString, IOSByteArray *nonce) {
  NSObject_init(self);
  if (securityStrength > LibOrgBouncycastleCryptoPrngDrbgCryptoPrngDrbgUtils_getMaxSecurityStrengthWithLibOrgBouncycastleCryptoDigest_(digest)) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Requested security strength is not supported by the derivation function");
  }
  if ([((id<LibOrgBouncycastleCryptoPrngEntropySource>) nil_chk(entropySource)) entropySize] < securityStrength) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Not enough entropy for security strength required");
  }
  self->_digest_ = digest;
  self->_entropySource_ = entropySource;
  self->_securityStrength_ = securityStrength;
  self->_seedLength_ = [((JavaLangInteger *) nil_chk(((JavaLangInteger *) cast_chk([((JavaUtilHashtable *) nil_chk(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_seedlens)) getWithId:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(digest)) getAlgorithmName]], [JavaLangInteger class])))) intValue];
  IOSByteArray *entropy = LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_getEntropy(self);
  IOSByteArray *seedMaterial = LibOrgBouncycastleUtilArrays_concatenateWithByteArray_withByteArray_withByteArray_(entropy, nonce, personalizationString);
  IOSByteArray *seed = LibOrgBouncycastleCryptoPrngDrbgCryptoPrngDrbgUtils_hash_dfWithLibOrgBouncycastleCryptoDigest_withByteArray_withInt_(self->_digest_, seedMaterial, self->_seedLength_);
  self->_V_ = seed;
  IOSByteArray *subV = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(self->_V_))->size_ + 1];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->_V_, 0, subV, 1, self->_V_->size_);
  self->_C_ = LibOrgBouncycastleCryptoPrngDrbgCryptoPrngDrbgUtils_hash_dfWithLibOrgBouncycastleCryptoDigest_withByteArray_withInt_(self->_digest_, subV, self->_seedLength_);
  self->_reseedCounter_ = 1;
}

LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *new_LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_(id<LibOrgBouncycastleCryptoDigest> digest, jint securityStrength, id<LibOrgBouncycastleCryptoPrngEntropySource> entropySource, IOSByteArray *personalizationString, IOSByteArray *nonce) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_, digest, securityStrength, entropySource, personalizationString, nonce)
}

LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *create_LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_(id<LibOrgBouncycastleCryptoDigest> digest, jint securityStrength, id<LibOrgBouncycastleCryptoPrngEntropySource> entropySource, IOSByteArray *personalizationString, IOSByteArray *nonce) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG, initWithLibOrgBouncycastleCryptoDigest_withInt_withLibOrgBouncycastleCryptoPrngEntropySource_withByteArray_withByteArray_, digest, securityStrength, entropySource, personalizationString, nonce)
}

IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_getEntropy(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self) {
  IOSByteArray *entropy = [((id<LibOrgBouncycastleCryptoPrngEntropySource>) nil_chk(self->_entropySource_)) getEntropy];
  if (((IOSByteArray *) nil_chk(entropy))->size_ < (self->_securityStrength_ + 7) / 8) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Insufficient entropy provided by entropy source");
  }
  return entropy;
}

void LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *longer, IOSByteArray *shorter) {
  jint carry = 0;
  for (jint i = 1; i <= ((IOSByteArray *) nil_chk(shorter))->size_; i++) {
    jint res = (IOSByteArray_Get(longer, ((IOSByteArray *) nil_chk(longer))->size_ - i) & (jint) 0xff) + (IOSByteArray_Get(shorter, shorter->size_ - i) & (jint) 0xff) + carry;
    carry = (res > (jint) 0xff) ? 1 : 0;
    *IOSByteArray_GetRef(longer, longer->size_ - i) = (jbyte) res;
  }
  for (jint i = shorter->size_ + 1; i <= ((IOSByteArray *) nil_chk(longer))->size_; i++) {
    jint res = (IOSByteArray_Get(longer, longer->size_ - i) & (jint) 0xff) + carry;
    carry = (res > (jint) 0xff) ? 1 : 0;
    *IOSByteArray_GetRef(longer, longer->size_ - i) = (jbyte) res;
  }
}

IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hash__WithByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input) {
  IOSByteArray *hash_ = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->_digest_)) getDigestSize]];
  LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_doHashWithByteArray_withByteArray_(self, input, hash_);
  return hash_;
}

void LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_doHashWithByteArray_withByteArray_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input, IOSByteArray *output) {
  [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->_digest_)) updateWithByteArray:input withInt:0 withInt:((IOSByteArray *) nil_chk(input))->size_];
  [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->_digest_)) doFinalWithByteArray:output withInt:0];
}

IOSByteArray *LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_hashgenWithByteArray_withInt_(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG *self, IOSByteArray *input, jint lengthInBits) {
  jint digestSize = [((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->_digest_)) getDigestSize];
  jint m = (lengthInBits / 8) / digestSize;
  IOSByteArray *data = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(input))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(input, 0, data, 0, input->size_);
  IOSByteArray *W = [IOSByteArray newArrayWithLength:lengthInBits / 8];
  IOSByteArray *dig = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoDigest>) nil_chk(self->_digest_)) getDigestSize]];
  for (jint i = 0; i <= m; i++) {
    LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_doHashWithByteArray_withByteArray_(self, data, dig);
    jint bytesToCopy = ((W->size_ - i * dig->size_) > dig->size_) ? dig->size_ : (W->size_ - i * dig->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(dig, 0, W, i * dig->size_, bytesToCopy);
    LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_addToWithByteArray_withByteArray_(self, data, LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG_ONE);
  }
  return W;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoPrngDrbgHashSP800DRBG)

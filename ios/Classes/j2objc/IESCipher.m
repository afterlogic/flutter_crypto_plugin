//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/asymmetric/ec/IESCipher.java
//

#include "AESEngine.h"
#include "AsymmetricKeyParameter.h"
#include "BCJcaJceHelper.h"
#include "BadBlockException.h"
#include "BlockCipher.h"
#include "BufferedBlockCipher.h"
#include "CBCBlockCipher.h"
#include "CipherParameters.h"
#include "DESedeEngine.h"
#include "Digest.h"
#include "DigestFactory.h"
#include "ECCurve.h"
#include "ECDHBasicAgreement.h"
#include "ECDomainParameters.h"
#include "ECIESPublicKeyParser.h"
#include "ECKey.h"
#include "ECKeyGenerationParameters.h"
#include "ECKeyPairGenerator.h"
#include "ECKeyParameters.h"
#include "ECParameterSpec.h"
#include "ECPoint.h"
#include "ECPublicKeyParameters.h"
#include "ECUtils.h"
#include "EphemeralKeyPairGenerator.h"
#include "HMac.h"
#include "IESCipher.h"
#include "IESEngine.h"
#include "IESKey.h"
#include "IESParameterSpec.h"
#include "IESUtil.h"
#include "IESWithCipherParameters.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "JcaJceHelper.h"
#include "JcajceUtilECUtil.h"
#include "KDF2BytesGenerator.h"
#include "KeyEncoder.h"
#include "Mac.h"
#include "PaddedBufferedBlockCipher.h"
#include "ParametersWithIV.h"
#include "Strings.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/security/AlgorithmParameters.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/Key.h"
#include "java/security/PrivateKey.h"
#include "java/security/PublicKey.h"
#include "java/security/SecureRandom.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "javax/crypto/Cipher.h"
#include "javax/crypto/CipherSpi.h"
#include "javax/crypto/NoSuchPaddingException.h"

@interface LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher () {
 @public
  id<LibOrgBouncycastleJcajceUtilJcaJceHelper> helper_;
  jint ivLength_;
  LibOrgBouncycastleCryptoEnginesIESEngine *engine_;
  jint state_;
  JavaIoByteArrayOutputStream *buffer_;
  JavaSecurityAlgorithmParameters *engineParam_;
  LibOrgBouncycastleJceSpecIESParameterSpec *engineSpec_;
  LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *key_;
  JavaSecuritySecureRandom *random_;
  jboolean dhaesMode_;
  LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *otherKeyParameter_;
}

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, helper_, id<LibOrgBouncycastleJcajceUtilJcaJceHelper>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, engine_, LibOrgBouncycastleCryptoEnginesIESEngine *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, buffer_, JavaIoByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, engineParam_, JavaSecurityAlgorithmParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, engineSpec_, LibOrgBouncycastleJceSpecIESParameterSpec *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, key_, LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, random_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, otherKeyParameter_, LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)

@interface LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 : NSObject < LibOrgBouncycastleCryptoKeyEncoder > {
 @public
  jboolean val$usePointCompression_;
}

- (instancetype)initWithBoolean:(jboolean)capture$0;

- (IOSByteArray *)getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:(LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)keyParameter;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1)

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *self, jboolean capture$0);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(jboolean capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(jboolean capture$0);

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher

- (instancetype)initWithLibOrgBouncycastleCryptoEnginesIESEngine:(LibOrgBouncycastleCryptoEnginesIESEngine *)engine {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(self, engine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoEnginesIESEngine:(LibOrgBouncycastleCryptoEnginesIESEngine *)engine
                                                         withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(self, engine, ivLength);
  return self;
}

- (jint)engineGetBlockSize {
  if ([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher] != nil) {
    return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getBlockSize];
  }
  else {
    return 0;
  }
}

- (jint)engineGetKeySizeWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if ([LibOrgBouncycastleJceInterfacesECKey_class_() isInstance:key]) {
    return [((LibOrgBouncycastleMathEcECCurve *) nil_chk([((LibOrgBouncycastleJceSpecECParameterSpec *) nil_chk([((id<LibOrgBouncycastleJceInterfacesECKey>) nil_chk(((id<LibOrgBouncycastleJceInterfacesECKey>) cast_check(key, LibOrgBouncycastleJceInterfacesECKey_class_())))) getParameters])) getCurve])) getFieldSize];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"not an EC key");
  }
}

- (IOSByteArray *)engineGetIV {
  if (engineSpec_ != nil) {
    return [engineSpec_ getNonce];
  }
  return nil;
}

- (JavaSecurityAlgorithmParameters *)engineGetParameters {
  if (engineParam_ == nil && engineSpec_ != nil) {
    @try {
      engineParam_ = [((id<LibOrgBouncycastleJcajceUtilJcaJceHelper>) nil_chk(helper_)) createAlgorithmParametersWithNSString:@"IES"];
      [((JavaSecurityAlgorithmParameters *) nil_chk(engineParam_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:engineSpec_];
    }
    @catch (JavaLangException *e) {
      @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
    }
  }
  return engineParam_;
}

- (void)engineSetModeWithNSString:(NSString *)mode {
  NSString *modeName = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(mode);
  if ([((NSString *) nil_chk(modeName)) isEqual:@"NONE"]) {
    dhaesMode_ = false;
  }
  else if ([modeName isEqual:@"DHAES"]) {
    dhaesMode_ = true;
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
  }
}

- (jint)engineGetOutputSizeWithInt:(jint)inputLen {
  jint len1;
  jint len2;
  jint len3;
  if (key_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
  len1 = [((id<LibOrgBouncycastleCryptoMac>) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getMac])) getMacSize];
  if (otherKeyParameter_ == nil) {
    LibOrgBouncycastleMathEcECCurve *c = [((LibOrgBouncycastleCryptoParamsECDomainParameters *) nil_chk([((LibOrgBouncycastleCryptoParamsECKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsECKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsECKeyParameters class])))) getParameters])) getCurve];
    jint feSize = ([((LibOrgBouncycastleMathEcECCurve *) nil_chk(c)) getFieldSize] + 7) / 8;
    len2 = 2 * feSize;
  }
  else {
    len2 = 0;
  }
  if ([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher] == nil) {
    len3 = inputLen;
  }
  else if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    len3 = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getOutputSizeWithInt:inputLen];
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    len3 = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getOutputSizeWithInt:inputLen - len1 - len2];
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
  if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    return [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) size] + len1 + 1 + len2 + len3;
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    return [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) size] - len1 - len2 + len3;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
}

- (void)engineSetPaddingWithNSString:(NSString *)padding {
  NSString *paddingName = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(padding);
  if ([((NSString *) nil_chk(paddingName)) isEqual:@"NOPADDING"]) {
  }
  else if ([paddingName isEqual:@"PKCS5PADDING"] || [paddingName isEqual:@"PKCS7PADDING"]) {
  }
  else {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(@"padding not available with IESCipher");
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec = nil;
  if (params != nil) {
    @try {
      paramSpec = [params getParameterSpecWithIOSClass:LibOrgBouncycastleJceSpecIESParameterSpec_class_()];
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"cannot recognise parameters: ", [e description]));
    }
  }
  engineParam_ = params;
  [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:paramSpec withJavaSecuritySecureRandom:random];
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)engineSpec
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  otherKeyParameter_ = nil;
  if (engineSpec == nil) {
    IOSByteArray *nonce = nil;
    if (ivLength_ != 0 && opmode == JavaxCryptoCipher_ENCRYPT_MODE) {
      nonce = [IOSByteArray newArrayWithLength:ivLength_];
      [((JavaSecuritySecureRandom *) nil_chk(random)) nextBytesWithByteArray:nonce];
    }
    self->engineSpec_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilIESUtil_guessParameterSpecWithLibOrgBouncycastleCryptoBufferedBlockCipher_withByteArray_([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher], nonce);
  }
  else if ([engineSpec isKindOfClass:[LibOrgBouncycastleJceSpecIESParameterSpec class]]) {
    self->engineSpec_ = (LibOrgBouncycastleJceSpecIESParameterSpec *) engineSpec;
  }
  else {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"must be passed IES parameters");
  }
  IOSByteArray *nonce = [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(self->engineSpec_)) getNonce];
  if (ivLength_ != 0 && (nonce == nil || nonce->size_ != ivLength_)) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$I$", @"NONCE in IES Parameters needs to be ", ivLength_, @" bytes long"));
  }
  if (opmode == JavaxCryptoCipher_ENCRYPT_MODE || opmode == JavaxCryptoCipher_WRAP_MODE) {
    if ([JavaSecurityPublicKey_class_() isInstance:key]) {
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricEcECUtils_generatePublicKeyParameterWithJavaSecurityPublicKey_((id<JavaSecurityPublicKey>) cast_check(key, JavaSecurityPublicKey_class_()));
    }
    else if ([LibOrgBouncycastleJceInterfacesIESKey_class_() isInstance:key]) {
      id<LibOrgBouncycastleJceInterfacesIESKey> ieKey = (id<LibOrgBouncycastleJceInterfacesIESKey>) cast_check(key, LibOrgBouncycastleJceInterfacesIESKey_class_());
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricEcECUtils_generatePublicKeyParameterWithJavaSecurityPublicKey_([((id<LibOrgBouncycastleJceInterfacesIESKey>) nil_chk(ieKey)) getPublic]);
      self->otherKeyParameter_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcajceUtilECUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_([ieKey getPrivate]);
    }
    else {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed recipient's public EC key for encryption");
    }
  }
  else if (opmode == JavaxCryptoCipher_DECRYPT_MODE || opmode == JavaxCryptoCipher_UNWRAP_MODE) {
    if ([JavaSecurityPrivateKey_class_() isInstance:key]) {
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcajceUtilECUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_((id<JavaSecurityPrivateKey>) cast_check(key, JavaSecurityPrivateKey_class_()));
    }
    else if ([LibOrgBouncycastleJceInterfacesIESKey_class_() isInstance:key]) {
      id<LibOrgBouncycastleJceInterfacesIESKey> ieKey = (id<LibOrgBouncycastleJceInterfacesIESKey>) cast_check(key, LibOrgBouncycastleJceInterfacesIESKey_class_());
      self->otherKeyParameter_ = LibOrgBouncycastleJcajceProviderAsymmetricEcECUtils_generatePublicKeyParameterWithJavaSecurityPublicKey_([((id<LibOrgBouncycastleJceInterfacesIESKey>) nil_chk(ieKey)) getPublic]);
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcajceUtilECUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_([ieKey getPrivate]);
    }
    else {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed recipient's private EC key for decryption");
    }
  }
  else {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed EC key");
  }
  self->random_ = random;
  self->state_ = opmode;
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) reset];
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @try {
    [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:nil withJavaSecuritySecureRandom:random];
  }
  @catch (JavaSecurityInvalidAlgorithmParameterException *e) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"cannot handle supplied parameter spec: ", [e getMessage]));
  }
}

- (IOSByteArray *)engineUpdateWithByteArray:(IOSByteArray *)input
                                    withInt:(jint)inputOffset
                                    withInt:(jint)inputLen {
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return nil;
}

- (jint)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inputOffset
                          withInt:(jint)inputLen
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outputOffset {
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return 0;
}

- (IOSByteArray *)engineDoFinalWithByteArray:(IOSByteArray *)input
                                     withInt:(jint)inputOffset
                                     withInt:(jint)inputLen {
  if (inputLen != 0) {
    [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  IOSByteArray *in = [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) toByteArray];
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) reset];
  id<LibOrgBouncycastleCryptoCipherParameters> params = new_LibOrgBouncycastleCryptoParamsIESWithCipherParameters_initWithByteArray_withByteArray_withInt_withInt_([((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getDerivationV], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getEncodingV], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getMacKeySize], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getCipherKeySize]);
  if ([((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getNonce] != nil) {
    params = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(params, [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getNonce]);
  }
  LibOrgBouncycastleCryptoParamsECDomainParameters *ecParams = [((LibOrgBouncycastleCryptoParamsECKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsECKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsECKeyParameters class])))) getParameters];
  IOSByteArray *V;
  if (otherKeyParameter_ != nil) {
    @try {
      if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
        [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:otherKeyParameter_ withLibOrgBouncycastleCryptoCipherParameters:key_ withLibOrgBouncycastleCryptoCipherParameters:params];
      }
      else {
        [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:key_ withLibOrgBouncycastleCryptoCipherParameters:otherKeyParameter_ withLibOrgBouncycastleCryptoCipherParameters:params];
      }
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (JavaLangException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    LibOrgBouncycastleCryptoGeneratorsECKeyPairGenerator *gen = new_LibOrgBouncycastleCryptoGeneratorsECKeyPairGenerator_init();
    [gen init__WithLibOrgBouncycastleCryptoKeyGenerationParameters:new_LibOrgBouncycastleCryptoParamsECKeyGenerationParameters_initWithLibOrgBouncycastleCryptoParamsECDomainParameters_withJavaSecuritySecureRandom_(ecParams, random_)];
    jboolean usePointCompression = [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getPointCompression];
    LibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator *kGen = new_LibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator_initWithLibOrgBouncycastleCryptoAsymmetricCipherKeyPairGenerator_withLibOrgBouncycastleCryptoKeyEncoder_(gen, new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(usePointCompression));
    @try {
      [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:key_ withLibOrgBouncycastleCryptoCipherParameters:params withLibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator:kGen];
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (JavaLangException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    @try {
      [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:key_ withLibOrgBouncycastleCryptoCipherParameters:params withLibOrgBouncycastleCryptoKeyParser:new_LibOrgBouncycastleCryptoParsersECIESPublicKeyParser_initWithLibOrgBouncycastleCryptoParamsECDomainParameters_(ecParams)];
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
}

- (jint)engineDoFinalWithByteArray:(IOSByteArray *)input
                           withInt:(jint)inputOffset
                           withInt:(jint)inputLength
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outputOffset {
  IOSByteArray *buf = [self engineDoFinalWithByteArray:input withInt:inputOffset withInt:inputLength];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buf, 0, output, outputOffset, ((IOSByteArray *) nil_chk(buf))->size_);
  return buf->size_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityAlgorithmParameters;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "I", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 5, 10, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 16, 17, -1, -1, -1 },
    { NULL, "[B", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 20, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 21, 19, 22, -1, -1, -1 },
    { NULL, "I", 0x1, 21, 20, 23, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoEnginesIESEngine:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoEnginesIESEngine:withInt:);
  methods[2].selector = @selector(engineGetBlockSize);
  methods[3].selector = @selector(engineGetKeySizeWithJavaSecurityKey:);
  methods[4].selector = @selector(engineGetIV);
  methods[5].selector = @selector(engineGetParameters);
  methods[6].selector = @selector(engineSetModeWithNSString:);
  methods[7].selector = @selector(engineGetOutputSizeWithInt:);
  methods[8].selector = @selector(engineSetPaddingWithNSString:);
  methods[9].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecurityAlgorithmParameters:withJavaSecuritySecureRandom:);
  methods[10].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:withJavaSecuritySecureRandom:);
  methods[11].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySecureRandom:);
  methods[12].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[13].selector = @selector(engineUpdateWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[14].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:);
  methods[15].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:withByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "helper_", "LLibOrgBouncycastleJcajceUtilJcaJceHelper;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ivLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoEnginesIESEngine;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "state_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "LJavaIoByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineParam_", "LJavaSecurityAlgorithmParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineSpec_", "LLibOrgBouncycastleJceSpecIESParameterSpec;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "key_", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "random_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "dhaesMode_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "otherKeyParameter_", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoEnginesIESEngine;", "LLibOrgBouncycastleCryptoEnginesIESEngine;I", "engineGetKeySize", "LJavaSecurityKey;", "engineSetMode", "LNSString;", "LJavaSecurityNoSuchAlgorithmException;", "engineGetOutputSize", "I", "engineSetPadding", "LJavaxCryptoNoSuchPaddingException;", "engineInit", "ILJavaSecurityKey;LJavaSecurityAlgorithmParameters;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "ILJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidAlgorithmParameterException;LJavaSecurityInvalidKeyException;", "ILJavaSecurityKey;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;", "engineUpdate", "[BII", "[BII[BI", "engineDoFinal", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LJavaxCryptoShortBufferException;LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES;LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher;LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC;LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher = { "IESCipher", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, fields, 7, 0x1, 16, 11, -1, 24, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *self, LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  JavaxCryptoCipherSpi_init(self);
  self->helper_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->state_ = -1;
  self->buffer_ = new_JavaIoByteArrayOutputStream_init();
  self->engineParam_ = nil;
  self->engineSpec_ = nil;
  self->dhaesMode_ = false;
  self->otherKeyParameter_ = nil;
  self->engine_ = engine;
  self->ivLength_ = 0;
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_, engine)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_, engine)
}

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *self, LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  JavaxCryptoCipherSpi_init(self);
  self->helper_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->state_ = -1;
  self->buffer_ = new_JavaIoByteArrayOutputStream_init();
  self->engineParam_ = nil;
  self->engineSpec_ = nil;
  self->dhaesMode_ = false;
  self->otherKeyParameter_ = nil;
  self->engine_ = engine;
  self->ivLength_ = ivLength;
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_, engine, ivLength)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_, engine, ivLength)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1

- (instancetype)initWithBoolean:(jboolean)capture$0 {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(self, capture$0);
  return self;
}

- (IOSByteArray *)getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:(LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)keyParameter {
  return [((LibOrgBouncycastleMathEcECPoint *) nil_chk([((LibOrgBouncycastleCryptoParamsECPublicKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsECPublicKeyParameters *) cast_chk(keyParameter, [LibOrgBouncycastleCryptoParamsECPublicKeyParameters class])))) getQ])) getEncodedWithBoolean:val$usePointCompression_];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithBoolean:);
  methods[1].selector = @selector(getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$usePointCompression_", "Z", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getEncoded", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;", "engineDoFinalWithByteArray:withInt:withInt:" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 = { "", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, fields, 7, 0x8010, 2, 1, 2, -1, 3, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *self, jboolean capture$0) {
  self->val$usePointCompression_ = capture$0;
  NSObject_init(self);
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(jboolean capture$0) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1, initWithBoolean_, capture$0)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1 *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1_initWithBoolean_(jboolean capture$0) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_1, initWithBoolean_, capture$0)
}

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES = { "ECIES", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES_init(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(self, new_LibOrgBouncycastleCryptoEnginesIESEngine_initWithLibOrgBouncycastleCryptoBasicAgreement_withLibOrgBouncycastleCryptoDerivationFunction_withLibOrgBouncycastleCryptoMac_(new_LibOrgBouncycastleCryptoAgreementECDHBasicAgreement_init(), new_LibOrgBouncycastleCryptoGeneratorsKDF2BytesGenerator_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1())));
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIES)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher
                                                    withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, cipher, ivLength);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withInt:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;I", "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher = { "ECIESwithCipher", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, NULL, 7, 0x9, 1, 0, 1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher, jint ivLength) {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(self, new_LibOrgBouncycastleCryptoEnginesIESEngine_initWithLibOrgBouncycastleCryptoBasicAgreement_withLibOrgBouncycastleCryptoDerivationFunction_withLibOrgBouncycastleCryptoMac_withLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoAgreementECDHBasicAgreement_init(), new_LibOrgBouncycastleCryptoGeneratorsKDF2BytesGenerator_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoPaddingsPaddedBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(cipher)), ivLength);
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, cipher, ivLength)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, cipher, ivLength)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC = { "ECIESwithDESedeCBC", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC_init(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoEnginesDESedeEngine_init()), 8);
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithDESedeCBC)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC = { "ECIESwithAESCBC", "lib.org.bouncycastle.jcajce.provider.asymmetric.ec", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC_init(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoEnginesAESEngine_init()), 16);
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC *new_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC *create_LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricEcIESCipher_ECIESwithAESCBC)

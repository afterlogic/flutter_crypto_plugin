//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/symmetric/util/BaseMac.java
//

#include "AEADParameterSpec.h"
#include "AEADParameters.h"
#include "BCPBEKey.h"
#include "BaseMac.h"
#include "CipherParameters.h"
#include "ClassUtil.h"
#include "HMac.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "Mac.h"
#include "PBE.h"
#include "PKCS12Key.h"
#include "ParametersWithIV.h"
#include "RC2Parameters.h"
#include "SkeinParameterSpec.h"
#include "SkeinParameters.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/reflect/Method.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/Key.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "java/util/Hashtable.h"
#include "java/util/Iterator.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "javax/crypto/MacSpi.h"
#include "javax/crypto/SecretKey.h"
#include "javax/crypto/interfaces/PBEKey.h"
#include "javax/crypto/spec/IvParameterSpec.h"
#include "javax/crypto/spec/PBEParameterSpec.h"
#include "javax/crypto/spec/RC2ParameterSpec.h"

@interface LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac () {
 @public
  id<LibOrgBouncycastleCryptoMac> macEngine_;
  jint scheme_;
  jint pbeHash_;
  jint keySize_;
}

+ (JavaUtilHashtable *)copyMapWithJavaUtilMap:(id<JavaUtilMap>)paramsMap OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, macEngine_, id<LibOrgBouncycastleCryptoMac>)

inline IOSClass *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_get_gcmSpecClass(void);
static IOSClass *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, gcmSpecClass, IOSClass *)

__attribute__((unused)) static JavaUtilHashtable *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_copyMapWithJavaUtilMap_(id<JavaUtilMap> paramsMap);

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac)

@implementation LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac

- (instancetype)initWithLibOrgBouncycastleCryptoMac:(id<LibOrgBouncycastleCryptoMac>)macEngine {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_(self, macEngine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoMac:(id<LibOrgBouncycastleCryptoMac>)macEngine
                                            withInt:(jint)scheme
                                            withInt:(jint)pbeHash
                                            withInt:(jint)keySize {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_(self, macEngine, scheme, pbeHash, keySize);
  return self;
}

- (void)engineInitWithJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params {
  id<LibOrgBouncycastleCryptoCipherParameters> param;
  if (key == nil) {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"key is null");
  }
  if ([key isKindOfClass:[LibOrgBouncycastleJcajcePKCS12Key class]]) {
    id<JavaxCryptoSecretKey> k;
    JavaxCryptoSpecPBEParameterSpec *pbeSpec;
    @try {
      k = (id<JavaxCryptoSecretKey>) cast_check(key, JavaxCryptoSecretKey_class_());
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"PKCS12 requires a SecretKey/PBEKey");
    }
    @try {
      pbeSpec = (JavaxCryptoSpecPBEParameterSpec *) cast_chk(params, [JavaxCryptoSpecPBEParameterSpec class]);
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"PKCS12 requires a PBEParameterSpec");
    }
    if ([JavaxCryptoInterfacesPBEKey_class_() isInstance:k] && pbeSpec == nil) {
      pbeSpec = new_JavaxCryptoSpecPBEParameterSpec_initWithByteArray_withInt_([((id<JavaxCryptoInterfacesPBEKey>) cast_check(k, JavaxCryptoInterfacesPBEKey_class_())) getSalt], [((id<JavaxCryptoInterfacesPBEKey>) cast_check(k, JavaxCryptoInterfacesPBEKey_class_())) getIterationCount]);
    }
    jint digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA1;
    jint keySize = 160;
    if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"GOST"]) {
      digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_GOST3411;
      keySize = 256;
    }
    else if ([macEngine_ isKindOfClass:[LibOrgBouncycastleCryptoMacsHMac class]]) {
      if (![((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"SHA-1"]) {
        if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"SHA-224"]) {
          digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA224;
          keySize = 224;
        }
        else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"SHA-256"]) {
          digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA256;
          keySize = 256;
        }
        else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"SHA-384"]) {
          digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA384;
          keySize = 384;
        }
        else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"SHA-512"]) {
          digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA512;
          keySize = 512;
        }
        else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName])) java_hasPrefix:@"RIPEMD160"]) {
          digest = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_RIPEMD160;
          keySize = 160;
        }
        else {
          @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"no PKCS12 mapping for HMAC: ", [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getAlgorithmName]));
        }
      }
    }
    param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEMacParametersWithJavaxCryptoSecretKey_withInt_withInt_withInt_withJavaxCryptoSpecPBEParameterSpec_(k, LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12, digest, keySize, pbeSpec);
  }
  else if ([key isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey class]]) {
    LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *k = (LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *) key;
    if ([k getParam] != nil) {
      param = [k getParam];
    }
    else if ([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]]) {
      param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEMacParametersWithLibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey_withJavaSecuritySpecAlgorithmParameterSpec_(k, params);
    }
    else {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"PBE requires PBE parameters to be set.");
    }
  }
  else {
    if ([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]]) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"inappropriate parameter type: ", [[((id<JavaSecuritySpecAlgorithmParameterSpec>) nil_chk(params)) java_getClass] getName]));
    }
    param = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_([key getEncoded]);
  }
  LibOrgBouncycastleCryptoParamsKeyParameter *keyParam;
  if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) param))) getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  }
  else {
    keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk(param, [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  }
  if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecAEADParameterSpec class]]) {
    LibOrgBouncycastleJcajceSpecAEADParameterSpec *aeadSpec = (LibOrgBouncycastleJcajceSpecAEADParameterSpec *) params;
    param = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_withByteArray_(keyParam, [((LibOrgBouncycastleJcajceSpecAEADParameterSpec *) nil_chk(aeadSpec)) getMacSizeInBits], [aeadSpec getNonce], [aeadSpec getAssociatedData]);
  }
  else if ([params isKindOfClass:[JavaxCryptoSpecIvParameterSpec class]]) {
    param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(keyParam, [((JavaxCryptoSpecIvParameterSpec *) nil_chk(((JavaxCryptoSpecIvParameterSpec *) params))) getIV]);
  }
  else if ([params isKindOfClass:[JavaxCryptoSpecRC2ParameterSpec class]]) {
    param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(new_LibOrgBouncycastleCryptoParamsRC2Parameters_initWithByteArray_withInt_([((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(keyParam)) getKey], [((JavaxCryptoSpecRC2ParameterSpec *) nil_chk(((JavaxCryptoSpecRC2ParameterSpec *) params))) getEffectiveKeyBits]), [((JavaxCryptoSpecRC2ParameterSpec *) nil_chk(((JavaxCryptoSpecRC2ParameterSpec *) params))) getIV]);
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecSkeinParameterSpec class]]) {
    param = [((LibOrgBouncycastleCryptoParamsSkeinParameters_Builder *) nil_chk([new_LibOrgBouncycastleCryptoParamsSkeinParameters_Builder_initWithJavaUtilHashtable_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_copyMapWithJavaUtilMap_([((LibOrgBouncycastleJcajceSpecSkeinParameterSpec *) nil_chk(((LibOrgBouncycastleJcajceSpecSkeinParameterSpec *) params))) getParameters])) setKeyWithByteArray:[((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(keyParam)) getKey]])) build];
  }
  else if (params == nil) {
    param = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_([key getEncoded]);
  }
  else if (LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass != nil && [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass isAssignableFrom:[params java_getClass]]) {
    @try {
      JavaLangReflectMethod *tLen = [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass getDeclaredMethod:@"getTLen" parameterTypes:[IOSObjectArray newArrayWithLength:0 type:IOSClass_class_()]];
      JavaLangReflectMethod *iv = [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass getDeclaredMethod:@"getIV" parameterTypes:[IOSObjectArray newArrayWithLength:0 type:IOSClass_class_()]];
      param = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_(keyParam, [((JavaLangInteger *) nil_chk(((JavaLangInteger *) cast_chk([((JavaLangReflectMethod *) nil_chk(tLen)) invokeWithId:params withNSObjectArray:[IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]], [JavaLangInteger class])))) intValue], (IOSByteArray *) cast_chk([((JavaLangReflectMethod *) nil_chk(iv)) invokeWithId:params withNSObjectArray:[IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]], [IOSByteArray class]));
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"Cannot process GCMParameterSpec.");
    }
  }
  else if (!([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]])) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"unknown parameter type: ", [[params java_getClass] getName]));
  }
  @try {
    [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) init__WithLibOrgBouncycastleCryptoCipherParameters:param];
  }
  @catch (JavaLangException *e) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"cannot initialize MAC: ", [e getMessage]));
  }
}

- (jint)engineGetMacLength {
  return [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) getMacSize];
}

- (void)engineReset {
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) reset];
}

- (void)engineUpdateWithByte:(jbyte)input {
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) updateWithByte:input];
}

- (void)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)offset
                          withInt:(jint)len {
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) updateWithByteArray:input withInt:offset withInt:len];
}

- (IOSByteArray *)engineDoFinal {
  IOSByteArray *out = [IOSByteArray newArrayWithLength:[self engineGetMacLength]];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(macEngine_)) doFinalWithByteArray:out withInt:0];
  return out;
}

+ (JavaUtilHashtable *)copyMapWithJavaUtilMap:(id<JavaUtilMap>)paramsMap {
  return LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_copyMapWithJavaUtilMap_(paramsMap);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 2, 3, 4, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 7, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilHashtable;", 0xa, 8, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoMac:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoMac:withInt:withInt:withInt:);
  methods[2].selector = @selector(engineInitWithJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:);
  methods[3].selector = @selector(engineGetMacLength);
  methods[4].selector = @selector(engineReset);
  methods[5].selector = @selector(engineUpdateWithByte:);
  methods[6].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[7].selector = @selector(engineDoFinal);
  methods[8].selector = @selector(copyMapWithJavaUtilMap:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "gcmSpecClass", "LIOSClass;", .constantValue.asLong = 0, 0x1a, -1, 10, -1, -1 },
    { "macEngine_", "LLibOrgBouncycastleCryptoMac;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scheme_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pbeHash_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "keySize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoMac;", "LLibOrgBouncycastleCryptoMac;III", "engineInit", "LJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "engineUpdate", "B", "[BII", "copyMap", "LJavaUtilMap;", &LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac = { "BaseMac", "lib.org.bouncycastle.jcajce.provider.symmetric.util", ptrTable, methods, fields, 7, 0x1, 9, 5, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac class]) {
    LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_gcmSpecClass = LibOrgBouncycastleJcajceProviderSymmetricUtilClassUtil_loadClassWithIOSClass_withNSString_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_class_(), @"javax.crypto.spec.GCMParameterSpec");
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac)
  }
}

@end

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *self, id<LibOrgBouncycastleCryptoMac> macEngine) {
  JavaxCryptoMacSpi_init(self);
  self->scheme_ = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12;
  self->pbeHash_ = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA1;
  self->keySize_ = 160;
  self->macEngine_ = macEngine;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_(id<LibOrgBouncycastleCryptoMac> macEngine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, initWithLibOrgBouncycastleCryptoMac_, macEngine)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_(id<LibOrgBouncycastleCryptoMac> macEngine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, initWithLibOrgBouncycastleCryptoMac_, macEngine)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *self, id<LibOrgBouncycastleCryptoMac> macEngine, jint scheme, jint pbeHash, jint keySize) {
  JavaxCryptoMacSpi_init(self);
  self->scheme_ = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12;
  self->pbeHash_ = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_SHA1;
  self->keySize_ = 160;
  self->macEngine_ = macEngine;
  self->scheme_ = scheme;
  self->pbeHash_ = pbeHash;
  self->keySize_ = keySize;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoMac> macEngine, jint scheme, jint pbeHash, jint keySize) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_, macEngine, scheme, pbeHash, keySize)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoMac> macEngine, jint scheme, jint pbeHash, jint keySize) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac, initWithLibOrgBouncycastleCryptoMac_withInt_withInt_withInt_, macEngine, scheme, pbeHash, keySize)
}

JavaUtilHashtable *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_copyMapWithJavaUtilMap_(id<JavaUtilMap> paramsMap) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac_initialize();
  JavaUtilHashtable *newTable = new_JavaUtilHashtable_init();
  id<JavaUtilIterator> keys = [((id<JavaUtilSet>) nil_chk([((id<JavaUtilMap>) nil_chk(paramsMap)) keySet])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(keys)) hasNext]) {
    id key = [keys next];
    (void) [newTable putWithId:key withId:[paramsMap getWithId:key]];
  }
  return newTable;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseMac)

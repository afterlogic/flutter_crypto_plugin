//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/asymmetric/rsa/RsaCipherSpi.java
//

#include "ASN1ObjectIdentifier.h"
#include "AsymmetricBlockCipher.h"
#include "BCJcaJceHelper.h"
#include "BadBlockException.h"
#include "BaseCipherSpi.h"
#include "CipherParameters.h"
#include "CryptoServicesRegistrar.h"
#include "Digest.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "ISO9796d1Encoding.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "JcaJceHelper.h"
#include "OAEPEncoding.h"
#include "PKCS1Encoding.h"
#include "PKCSObjectIdentifiers.h"
#include "ParametersWithRandom.h"
#include "RSABlindedEngine.h"
#include "RSAKeyParameters.h"
#include "RSAUtil.h"
#include "RsaCipherSpi.h"
#include "Strings.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/RuntimeException.h"
#include "java/math/BigInteger.h"
#include "java/security/AlgorithmParameters.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/InvalidParameterException.h"
#include "java/security/Key.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/security/SecureRandom.h"
#include "java/security/interfaces/RSAPrivateKey.h"
#include "java/security/interfaces/RSAPublicKey.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "java/security/spec/InvalidParameterSpecException.h"
#include "java/security/spec/MGF1ParameterSpec.h"
#include "javax/crypto/Cipher.h"
#include "javax/crypto/NoSuchPaddingException.h"
#include "javax/crypto/ShortBufferException.h"
#include "javax/crypto/spec/OAEPParameterSpec.h"
#include "javax/crypto/spec/PSource.h"
#include "jcaJceUtilDigestFactory.h"

@interface LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi () {
 @public
  id<LibOrgBouncycastleJcajceUtilJcaJceHelper> helper_RsaCipherSpi_;
  id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher_;
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec_;
  JavaSecurityAlgorithmParameters *engineParams_RsaCipherSpi_;
  jboolean publicKeyOnly_;
  jboolean privateKeyOnly_;
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *bOut_;
}

- (void)initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:(JavaxCryptoSpecOAEPParameterSpec *)pSpec OBJC_METHOD_FAMILY_NONE;

- (IOSByteArray *)getOutput;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, helper_RsaCipherSpi_, id<LibOrgBouncycastleJcajceUtilJcaJceHelper>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, cipher_, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, paramSpec_, id<JavaSecuritySpecAlgorithmParameterSpec>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, engineParams_RsaCipherSpi_, JavaSecurityAlgorithmParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, bOut_, LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *)

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self, JavaxCryptoSpecOAEPParameterSpec *pSpec);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_getOutput(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self);

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)engine {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, engine);
  return self;
}

- (instancetype)initWithJavaxCryptoSpecOAEPParameterSpec:(JavaxCryptoSpecOAEPParameterSpec *)pSpec {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithJavaxCryptoSpecOAEPParameterSpec_(self, pSpec);
  return self;
}

- (instancetype)initWithBoolean:(jboolean)publicKeyOnly
                    withBoolean:(jboolean)privateKeyOnly
withLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)engine {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, publicKeyOnly, privateKeyOnly, engine);
  return self;
}

- (void)initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:(JavaxCryptoSpecOAEPParameterSpec *)pSpec {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, pSpec);
}

- (jint)engineGetBlockSize {
  @try {
    return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize];
  }
  @catch (JavaLangNullPointerException *e) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"RSA Cipher not initialised");
  }
}

- (jint)engineGetKeySizeWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if ([JavaSecurityInterfacesRSAPrivateKey_class_() isInstance:key]) {
    id<JavaSecurityInterfacesRSAPrivateKey> k = (id<JavaSecurityInterfacesRSAPrivateKey>) cast_check(key, JavaSecurityInterfacesRSAPrivateKey_class_());
    return [((JavaMathBigInteger *) nil_chk([((id<JavaSecurityInterfacesRSAPrivateKey>) nil_chk(k)) getModulus])) bitLength];
  }
  else if ([JavaSecurityInterfacesRSAPublicKey_class_() isInstance:key]) {
    id<JavaSecurityInterfacesRSAPublicKey> k = (id<JavaSecurityInterfacesRSAPublicKey>) cast_check(key, JavaSecurityInterfacesRSAPublicKey_class_());
    return [((JavaMathBigInteger *) nil_chk([((id<JavaSecurityInterfacesRSAPublicKey>) nil_chk(k)) getModulus])) bitLength];
  }
  @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"not an RSA key!");
}

- (jint)engineGetOutputSizeWithInt:(jint)inputLen {
  @try {
    return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getOutputBlockSize];
  }
  @catch (JavaLangNullPointerException *e) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"RSA Cipher not initialised");
  }
}

- (JavaSecurityAlgorithmParameters *)engineGetParameters {
  if (engineParams_RsaCipherSpi_ == nil) {
    if (paramSpec_ != nil) {
      @try {
        engineParams_RsaCipherSpi_ = [((id<LibOrgBouncycastleJcajceUtilJcaJceHelper>) nil_chk(helper_RsaCipherSpi_)) createAlgorithmParametersWithNSString:@"OAEP"];
        [((JavaSecurityAlgorithmParameters *) nil_chk(engineParams_RsaCipherSpi_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:paramSpec_];
      }
      @catch (JavaLangException *e) {
        @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
      }
    }
  }
  return engineParams_RsaCipherSpi_;
}

- (void)engineSetModeWithNSString:(NSString *)mode {
  NSString *md = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(mode);
  if ([((NSString *) nil_chk(md)) isEqual:@"NONE"] || [md isEqual:@"ECB"]) {
    return;
  }
  if ([md isEqual:@"1"]) {
    privateKeyOnly_ = true;
    publicKeyOnly_ = false;
    return;
  }
  else if ([md isEqual:@"2"]) {
    privateKeyOnly_ = false;
    publicKeyOnly_ = true;
    return;
  }
  @throw new_JavaSecurityNoSuchAlgorithmException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
}

- (void)engineSetPaddingWithNSString:(NSString *)padding {
  NSString *pad = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(padding);
  if ([((NSString *) nil_chk(pad)) isEqual:@"NOPADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init();
  }
  else if ([pad isEqual:@"PKCS1PADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init());
  }
  else if ([pad isEqual:@"ISO9796-1PADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEncodingsISO9796d1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init());
  }
  else if ([pad isEqual:@"OAEPWITHMD5ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"MD5", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"MD5"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPPADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, JreLoadStatic(JavaxCryptoSpecOAEPParameterSpec, DEFAULT));
  }
  else if ([pad isEqual:@"OAEPWITHSHA1ANDMGF1PADDING"] || [pad isEqual:@"OAEPWITHSHA-1ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, JreLoadStatic(JavaxCryptoSpecOAEPParameterSpec, DEFAULT));
  }
  else if ([pad isEqual:@"OAEPWITHSHA224ANDMGF1PADDING"] || [pad isEqual:@"OAEPWITHSHA-224ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-224", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA-224"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA256ANDMGF1PADDING"] || [pad isEqual:@"OAEPWITHSHA-256ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-256", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA256), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA384ANDMGF1PADDING"] || [pad isEqual:@"OAEPWITHSHA-384ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-384", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA384), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA512ANDMGF1PADDING"] || [pad isEqual:@"OAEPWITHSHA-512ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-512", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA512), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-224ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-224", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-224"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-256ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-256", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-256"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-384ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-384", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-384"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-512ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-512", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-512"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(JreStrcat("$$", padding, @" unavailable with RSA."));
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<LibOrgBouncycastleCryptoCipherParameters> param;
  if (params == nil || [params isKindOfClass:[JavaxCryptoSpecOAEPParameterSpec class]]) {
    if ([JavaSecurityInterfacesRSAPublicKey_class_() isInstance:key]) {
      if (privateKeyOnly_ && opmode == JavaxCryptoCipher_ENCRYPT_MODE) {
        @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"mode 1 requires RSAPrivateKey");
      }
      param = LibOrgBouncycastleJcajceProviderAsymmetricRsaRSAUtil_generatePublicKeyParameterWithJavaSecurityInterfacesRSAPublicKey_((id<JavaSecurityInterfacesRSAPublicKey>) cast_check(key, JavaSecurityInterfacesRSAPublicKey_class_()));
    }
    else if ([JavaSecurityInterfacesRSAPrivateKey_class_() isInstance:key]) {
      if (publicKeyOnly_ && opmode == JavaxCryptoCipher_ENCRYPT_MODE) {
        @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"mode 2 requires RSAPublicKey");
      }
      param = LibOrgBouncycastleJcajceProviderAsymmetricRsaRSAUtil_generatePrivateKeyParameterWithJavaSecurityInterfacesRSAPrivateKey_((id<JavaSecurityInterfacesRSAPrivateKey>) cast_check(key, JavaSecurityInterfacesRSAPrivateKey_class_()));
    }
    else {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"unknown key type passed to RSA");
    }
    if (params != nil) {
      JavaxCryptoSpecOAEPParameterSpec *spec = (JavaxCryptoSpecOAEPParameterSpec *) cast_chk(params, [JavaxCryptoSpecOAEPParameterSpec class]);
      paramSpec_ = params;
      if (![((NSString *) nil_chk([spec getMGFAlgorithm])) java_equalsIgnoreCase:@"MGF1"] && ![((NSString *) nil_chk([spec getMGFAlgorithm])) isEqual:[((LibOrgBouncycastleAsn1ASN1ObjectIdentifier *) nil_chk(JreLoadStatic(LibOrgBouncycastleAsn1PkcsPKCSObjectIdentifiers, id_mgf1))) getId]]) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unknown mask generation function specified");
      }
      if (!([[spec getMGFParameters] isKindOfClass:[JavaSecuritySpecMGF1ParameterSpec class]])) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unkown MGF parameters");
      }
      id<LibOrgBouncycastleCryptoDigest> digest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([spec getDigestAlgorithm]);
      if (digest == nil) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"no match on digest algorithm: ", [spec getDigestAlgorithm]));
      }
      JavaSecuritySpecMGF1ParameterSpec *mgfParams = (JavaSecuritySpecMGF1ParameterSpec *) cast_chk([spec getMGFParameters], [JavaSecuritySpecMGF1ParameterSpec class]);
      id<LibOrgBouncycastleCryptoDigest> mgfDigest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([((JavaSecuritySpecMGF1ParameterSpec *) nil_chk(mgfParams)) getDigestAlgorithm]);
      if (mgfDigest == nil) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"no match on MGF digest algorithm: ", [mgfParams getDigestAlgorithm]));
      }
      cipher_ = new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init(), digest, mgfDigest, [((JavaxCryptoSpecPSource_PSpecified *) nil_chk(((JavaxCryptoSpecPSource_PSpecified *) cast_chk([spec getPSource], [JavaxCryptoSpecPSource_PSpecified class])))) getValue]);
    }
  }
  else {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"unknown parameter type: ", [[params java_getClass] getName]));
  }
  if (!([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesRSABlindedEngine class]])) {
    if (random != nil) {
      param = new_LibOrgBouncycastleCryptoParamsParametersWithRandom_initWithLibOrgBouncycastleCryptoCipherParameters_withJavaSecuritySecureRandom_(param, random);
    }
    else {
      param = new_LibOrgBouncycastleCryptoParamsParametersWithRandom_initWithLibOrgBouncycastleCryptoCipherParameters_withJavaSecuritySecureRandom_(param, LibOrgBouncycastleCryptoCryptoServicesRegistrar_getSecureRandom());
    }
  }
  [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) reset];
  switch (opmode) {
    case JavaxCryptoCipher_ENCRYPT_MODE:
    case JavaxCryptoCipher_WRAP_MODE:
    [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:param];
    break;
    case JavaxCryptoCipher_DECRYPT_MODE:
    case JavaxCryptoCipher_UNWRAP_MODE:
    [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:param];
    break;
    default:
    @throw new_JavaSecurityInvalidParameterException_initWithNSString_(JreStrcat("$I$", @"unknown opmode ", opmode, @" passed to RSA"));
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec = nil;
  if (params != nil) {
    @try {
      paramSpec = [params getParameterSpecWithIOSClass:JavaxCryptoSpecOAEPParameterSpec_class_()];
    }
    @catch (JavaSecuritySpecInvalidParameterSpecException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_withJavaLangThrowable_(JreStrcat("$$", @"cannot recognise parameters: ", [e description]), e);
    }
  }
  engineParams_RsaCipherSpi_ = params;
  [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:paramSpec withJavaSecuritySecureRandom:random];
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @try {
    [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:nil withJavaSecuritySecureRandom:random];
  }
  @catch (JavaSecurityInvalidAlgorithmParameterException *e) {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_withJavaLangThrowable_(JreStrcat("$$", @"Eeeek! ", [e description]), e);
  }
}

- (IOSByteArray *)engineUpdateWithByteArray:(IOSByteArray *)input
                                    withInt:(jint)inputOffset
                                    withInt:(jint)inputLen {
  [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesRSABlindedEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  return nil;
}

- (jint)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inputOffset
                          withInt:(jint)inputLen
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outputOffset {
  [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesRSABlindedEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  return 0;
}

- (IOSByteArray *)engineDoFinalWithByteArray:(IOSByteArray *)input
                                     withInt:(jint)inputOffset
                                     withInt:(jint)inputLen {
  if (input != nil) {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesRSABlindedEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  return LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_getOutput(self);
}

- (jint)engineDoFinalWithByteArray:(IOSByteArray *)input
                           withInt:(jint)inputOffset
                           withInt:(jint)inputLen
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outputOffset {
  if (outputOffset + [self engineGetOutputSizeWithInt:inputLen] > ((IOSByteArray *) nil_chk(output))->size_) {
    @throw new_JavaxCryptoShortBufferException_initWithNSString_(@"output buffer too short for input.");
  }
  if (input != nil) {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesRSABlindedEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for RSA block");
    }
  }
  IOSByteArray *out = LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_getOutput(self);
  for (jint i = 0; i != ((IOSByteArray *) nil_chk(out))->size_; i++) {
    *IOSByteArray_GetRef(output, outputOffset + i) = IOSByteArray_Get(out, i);
  }
  return out->size_;
}

- (IOSByteArray *)getOutput {
  return LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_getOutput(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 3, 1, 4, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 5, 6, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 7, 8, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityAlgorithmParameters;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 10, 11, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 16, 15, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 17, 18, -1, -1, -1 },
    { NULL, "[B", 0x4, 19, 20, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 19, 21, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 22, 20, 23, -1, -1, -1 },
    { NULL, "I", 0x4, 22, 21, 24, -1, -1, -1 },
    { NULL, "[B", 0x2, -1, -1, 25, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:);
  methods[1].selector = @selector(initWithJavaxCryptoSpecOAEPParameterSpec:);
  methods[2].selector = @selector(initWithBoolean:withBoolean:withLibOrgBouncycastleCryptoAsymmetricBlockCipher:);
  methods[3].selector = @selector(initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:);
  methods[4].selector = @selector(engineGetBlockSize);
  methods[5].selector = @selector(engineGetKeySizeWithJavaSecurityKey:);
  methods[6].selector = @selector(engineGetOutputSizeWithInt:);
  methods[7].selector = @selector(engineGetParameters);
  methods[8].selector = @selector(engineSetModeWithNSString:);
  methods[9].selector = @selector(engineSetPaddingWithNSString:);
  methods[10].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:withJavaSecuritySecureRandom:);
  methods[11].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecurityAlgorithmParameters:withJavaSecuritySecureRandom:);
  methods[12].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySecureRandom:);
  methods[13].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(engineUpdateWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[15].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:);
  methods[16].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[17].selector = @selector(getOutput);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "helper_RsaCipherSpi_", "LLibOrgBouncycastleJcajceUtilJcaJceHelper;", .constantValue.asLong = 0, 0x12, 26, -1, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "paramSpec_", "LJavaSecuritySpecAlgorithmParameterSpec;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineParams_RsaCipherSpi_", "LJavaSecurityAlgorithmParameters;", .constantValue.asLong = 0, 0x2, 27, -1, -1, -1 },
    { "publicKeyOnly_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "privateKeyOnly_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bOut_", "LLibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", "LJavaxCryptoSpecOAEPParameterSpec;", "ZZLLibOrgBouncycastleCryptoAsymmetricBlockCipher;", "initFromSpec", "LJavaxCryptoNoSuchPaddingException;", "engineGetKeySize", "LJavaSecurityKey;", "engineGetOutputSize", "I", "engineSetMode", "LNSString;", "LJavaSecurityNoSuchAlgorithmException;", "engineSetPadding", "engineInit", "ILJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "ILJavaSecurityKey;LJavaSecurityAlgorithmParameters;LJavaSecuritySecureRandom;", "ILJavaSecurityKey;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;", "engineUpdate", "[BII", "[BII[BI", "engineDoFinal", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;LJavaxCryptoShortBufferException;", "LJavaxCryptoBadPaddingException;", "helper", "engineParams", "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding;LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding;LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly;LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly;LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding;LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi = { "RsaCipherSpi", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, fields, 7, 0x1, 18, 7, -1, 28, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_init(self);
  self->helper_RsaCipherSpi_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->publicKeyOnly_ = false;
  self->privateKeyOnly_ = false;
  self->bOut_ = new_LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream_init();
  self->cipher_ = engine;
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, engine)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, engine)
}

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithJavaxCryptoSpecOAEPParameterSpec_(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self, JavaxCryptoSpecOAEPParameterSpec *pSpec) {
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_init(self);
  self->helper_RsaCipherSpi_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->publicKeyOnly_ = false;
  self->privateKeyOnly_ = false;
  self->bOut_ = new_LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream_init();
  @try {
    LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, pSpec);
  }
  @catch (JavaxCryptoNoSuchPaddingException *e) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_([e getMessage]);
  }
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithJavaxCryptoSpecOAEPParameterSpec_(JavaxCryptoSpecOAEPParameterSpec *pSpec) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithJavaxCryptoSpecOAEPParameterSpec_, pSpec)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithJavaxCryptoSpecOAEPParameterSpec_(JavaxCryptoSpecOAEPParameterSpec *pSpec) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithJavaxCryptoSpecOAEPParameterSpec_, pSpec)
}

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self, jboolean publicKeyOnly, jboolean privateKeyOnly, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_init(self);
  self->helper_RsaCipherSpi_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->publicKeyOnly_ = false;
  self->privateKeyOnly_ = false;
  self->bOut_ = new_LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream_init();
  self->publicKeyOnly_ = publicKeyOnly;
  self->privateKeyOnly_ = privateKeyOnly;
  self->cipher_ = engine;
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(jboolean publicKeyOnly, jboolean privateKeyOnly, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_, publicKeyOnly, privateKeyOnly, engine)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(jboolean publicKeyOnly, jboolean privateKeyOnly, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi, initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_, publicKeyOnly, privateKeyOnly, engine)
}

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self, JavaxCryptoSpecOAEPParameterSpec *pSpec) {
  JavaSecuritySpecMGF1ParameterSpec *mgfParams = (JavaSecuritySpecMGF1ParameterSpec *) cast_chk([((JavaxCryptoSpecOAEPParameterSpec *) nil_chk(pSpec)) getMGFParameters], [JavaSecuritySpecMGF1ParameterSpec class]);
  id<LibOrgBouncycastleCryptoDigest> digest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([((JavaSecuritySpecMGF1ParameterSpec *) nil_chk(mgfParams)) getDigestAlgorithm]);
  if (digest == nil) {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(JreStrcat("$$", @"no match on OAEP constructor for digest algorithm: ", [mgfParams getDigestAlgorithm]));
  }
  self->cipher_ = new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init(), digest, [((JavaxCryptoSpecPSource_PSpecified *) nil_chk(((JavaxCryptoSpecPSource_PSpecified *) cast_chk([pSpec getPSource], [JavaxCryptoSpecPSource_PSpecified class])))) getValue]);
  self->paramSpec_ = pSpec;
}

IOSByteArray *LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_getOutput(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi *self) {
  @try {
    return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->cipher_)) processBlockWithByteArray:[((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) getBuf] withInt:0 withInt:[((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) size]];
  }
  @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
    @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to decrypt block", e);
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *e) {
    @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to decrypt block", e);
  }
  @finally {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) erase];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding = { "NoPadding", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init());
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_NoPadding)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding = { "PKCS1v1_5Padding", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init()));
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly = { "PKCS1v1_5Padding_PrivateOnly", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, false, true, new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init()));
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PrivateOnly)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly = { "PKCS1v1_5Padding_PublicOnly", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithBoolean_withBoolean_withLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, true, false, new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init()));
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_PKCS1v1_5Padding_PublicOnly)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding = { "OAEPPadding", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithJavaxCryptoSpecOAEPParameterSpec_(self, JreLoadStatic(JavaxCryptoSpecOAEPParameterSpec, DEFAULT));
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_OAEPPadding)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding = { "ISO9796d1Padding", "lib.org.bouncycastle.jcajce.provider.asymmetric.rsa", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding_init(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, new_LibOrgBouncycastleCryptoEncodingsISO9796d1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesRSABlindedEngine_init()));
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding *new_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding *create_LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricRsaRsaCipherSpi_ISO9796d1Padding)

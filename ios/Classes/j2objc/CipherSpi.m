//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/asymmetric/elgamal/CipherSpi.java
//

#include "ASN1ObjectIdentifier.h"
#include "AsymmetricBlockCipher.h"
#include "AsymmetricKeyParameter.h"
#include "BadBlockException.h"
#include "BaseCipherSpi.h"
#include "CipherParameters.h"
#include "CipherSpi.h"
#include "Digest.h"
#include "ElGamalEngine.h"
#include "ElGamalKey.h"
#include "ElGamalParameterSpec.h"
#include "ElGamalUtil.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "ISO9796d1Encoding.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "OAEPEncoding.h"
#include "PKCS1Encoding.h"
#include "PKCSObjectIdentifiers.h"
#include "ParametersWithRandom.h"
#include "Strings.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/RuntimeException.h"
#include "java/math/BigInteger.h"
#include "java/security/AlgorithmParameters.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/InvalidParameterException.h"
#include "java/security/Key.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/security/PrivateKey.h"
#include "java/security/PublicKey.h"
#include "java/security/SecureRandom.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "java/security/spec/MGF1ParameterSpec.h"
#include "javax/crypto/Cipher.h"
#include "javax/crypto/NoSuchPaddingException.h"
#include "javax/crypto/ShortBufferException.h"
#include "javax/crypto/interfaces/DHKey.h"
#include "javax/crypto/interfaces/DHPrivateKey.h"
#include "javax/crypto/interfaces/DHPublicKey.h"
#include "javax/crypto/spec/DHParameterSpec.h"
#include "javax/crypto/spec/OAEPParameterSpec.h"
#include "javax/crypto/spec/PSource.h"
#include "jcaJceUtilDigestFactory.h"

@interface LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi () {
 @public
  id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> cipher_;
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec_;
  JavaSecurityAlgorithmParameters *engineParams_CipherSpi_;
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *bOut_;
}

- (void)initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:(JavaxCryptoSpecOAEPParameterSpec *)pSpec OBJC_METHOD_FAMILY_NONE;

- (IOSByteArray *)getOutput;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, cipher_, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, paramSpec_, id<JavaSecuritySpecAlgorithmParameterSpec>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, engineParams_CipherSpi_, JavaSecurityAlgorithmParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, bOut_, LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *)

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *self, JavaxCryptoSpecOAEPParameterSpec *pSpec);

__attribute__((unused)) static IOSByteArray *LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_getOutput(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *self);

@implementation LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi

- (instancetype)initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>)engine {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, engine);
  return self;
}

- (void)initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:(JavaxCryptoSpecOAEPParameterSpec *)pSpec {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, pSpec);
}

- (jint)engineGetBlockSize {
  return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize];
}

- (jint)engineGetKeySizeWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if ([LibOrgBouncycastleJceInterfacesElGamalKey_class_() isInstance:key]) {
    id<LibOrgBouncycastleJceInterfacesElGamalKey> k = (id<LibOrgBouncycastleJceInterfacesElGamalKey>) cast_check(key, LibOrgBouncycastleJceInterfacesElGamalKey_class_());
    return [((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleJceSpecElGamalParameterSpec *) nil_chk([((id<LibOrgBouncycastleJceInterfacesElGamalKey>) nil_chk(k)) getParameters])) getP])) bitLength];
  }
  else if ([JavaxCryptoInterfacesDHKey_class_() isInstance:key]) {
    id<JavaxCryptoInterfacesDHKey> k = (id<JavaxCryptoInterfacesDHKey>) cast_check(key, JavaxCryptoInterfacesDHKey_class_());
    return [((JavaMathBigInteger *) nil_chk([((JavaxCryptoSpecDHParameterSpec *) nil_chk([((id<JavaxCryptoInterfacesDHKey>) nil_chk(k)) getParams])) getP])) bitLength];
  }
  @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"not an ElGamal key!");
}

- (jint)engineGetOutputSizeWithInt:(jint)inputLen {
  return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getOutputBlockSize];
}

- (JavaSecurityAlgorithmParameters *)engineGetParameters {
  if (engineParams_CipherSpi_ == nil) {
    if (paramSpec_ != nil) {
      @try {
        engineParams_CipherSpi_ = [self createParametersInstanceWithNSString:@"OAEP"];
        [((JavaSecurityAlgorithmParameters *) nil_chk(engineParams_CipherSpi_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:paramSpec_];
      }
      @catch (JavaLangException *e) {
        @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
      }
    }
  }
  return engineParams_CipherSpi_;
}

- (void)engineSetModeWithNSString:(NSString *)mode {
  NSString *md = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(mode);
  if ([((NSString *) nil_chk(md)) isEqual:@"NONE"] || [md isEqual:@"ECB"]) {
    return;
  }
  @throw new_JavaSecurityNoSuchAlgorithmException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
}

- (void)engineSetPaddingWithNSString:(NSString *)padding {
  NSString *pad = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(padding);
  if ([((NSString *) nil_chk(pad)) isEqual:@"NOPADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init();
  }
  else if ([pad isEqual:@"PKCS1PADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init());
  }
  else if ([pad isEqual:@"ISO9796-1PADDING"]) {
    cipher_ = new_LibOrgBouncycastleCryptoEncodingsISO9796d1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init());
  }
  else if ([pad isEqual:@"OAEPPADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, JreLoadStatic(JavaxCryptoSpecOAEPParameterSpec, DEFAULT));
  }
  else if ([pad isEqual:@"OAEPWITHMD5ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"MD5", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"MD5"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA1ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, JreLoadStatic(JavaxCryptoSpecOAEPParameterSpec, DEFAULT));
  }
  else if ([pad isEqual:@"OAEPWITHSHA224ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-224", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA-224"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA256ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-256", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA256), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA384ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-384", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA384), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA512ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA-512", @"MGF1", JreLoadStatic(JavaSecuritySpecMGF1ParameterSpec, SHA512), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-224ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-224", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-224"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-256ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-256", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-256"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-384ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-384", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-384"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else if ([pad isEqual:@"OAEPWITHSHA3-512ANDMGF1PADDING"]) {
    LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(self, new_JavaxCryptoSpecOAEPParameterSpec_initWithNSString_withNSString_withJavaSecuritySpecAlgorithmParameterSpec_withJavaxCryptoSpecPSource_(@"SHA3-512", @"MGF1", new_JavaSecuritySpecMGF1ParameterSpec_initWithNSString_(@"SHA3-512"), JreLoadStatic(JavaxCryptoSpecPSource_PSpecified, DEFAULT)));
  }
  else {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(JreStrcat("$$", padding, @" unavailable with ElGamal."));
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<LibOrgBouncycastleCryptoCipherParameters> param;
  if ([JavaxCryptoInterfacesDHPublicKey_class_() isInstance:key]) {
    param = LibOrgBouncycastleJcajceProviderAsymmetricElgamalElGamalUtil_generatePublicKeyParameterWithJavaSecurityPublicKey_((id<JavaSecurityPublicKey>) cast_check(key, JavaSecurityPublicKey_class_()));
  }
  else if ([JavaxCryptoInterfacesDHPrivateKey_class_() isInstance:key]) {
    param = LibOrgBouncycastleJcajceProviderAsymmetricElgamalElGamalUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_((id<JavaSecurityPrivateKey>) cast_check(key, JavaSecurityPrivateKey_class_()));
  }
  else {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"unknown key type passed to ElGamal");
  }
  if ([params isKindOfClass:[JavaxCryptoSpecOAEPParameterSpec class]]) {
    JavaxCryptoSpecOAEPParameterSpec *spec = (JavaxCryptoSpecOAEPParameterSpec *) params;
    paramSpec_ = params;
    if (![((NSString *) nil_chk([((JavaxCryptoSpecOAEPParameterSpec *) nil_chk(spec)) getMGFAlgorithm])) java_equalsIgnoreCase:@"MGF1"] && ![((NSString *) nil_chk([spec getMGFAlgorithm])) isEqual:[((LibOrgBouncycastleAsn1ASN1ObjectIdentifier *) nil_chk(JreLoadStatic(LibOrgBouncycastleAsn1PkcsPKCSObjectIdentifiers, id_mgf1))) getId]]) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unknown mask generation function specified");
    }
    if (!([[spec getMGFParameters] isKindOfClass:[JavaSecuritySpecMGF1ParameterSpec class]])) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unkown MGF parameters");
    }
    id<LibOrgBouncycastleCryptoDigest> digest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([spec getDigestAlgorithm]);
    if (digest == nil) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"no match on digest algorithm: ", [spec getDigestAlgorithm]));
    }
    JavaSecuritySpecMGF1ParameterSpec *mgfParams = (JavaSecuritySpecMGF1ParameterSpec *) cast_chk([spec getMGFParameters], [JavaSecuritySpecMGF1ParameterSpec class]);
    id<LibOrgBouncycastleCryptoDigest> mgfDigest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([((JavaSecuritySpecMGF1ParameterSpec *) nil_chk(mgfParams)) getDigestAlgorithm]);
    if (mgfDigest == nil) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"no match on MGF digest algorithm: ", [mgfParams getDigestAlgorithm]));
    }
    cipher_ = new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withLibOrgBouncycastleCryptoDigest_withByteArray_(new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init(), digest, mgfDigest, [((JavaxCryptoSpecPSource_PSpecified *) nil_chk(((JavaxCryptoSpecPSource_PSpecified *) cast_chk([spec getPSource], [JavaxCryptoSpecPSource_PSpecified class])))) getValue]);
  }
  else if (params != nil) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unknown parameter type.");
  }
  if (random != nil) {
    param = new_LibOrgBouncycastleCryptoParamsParametersWithRandom_initWithLibOrgBouncycastleCryptoCipherParameters_withJavaSecuritySecureRandom_(param, random);
  }
  switch (opmode) {
    case JavaxCryptoCipher_ENCRYPT_MODE:
    case JavaxCryptoCipher_WRAP_MODE:
    [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:param];
    break;
    case JavaxCryptoCipher_DECRYPT_MODE:
    case JavaxCryptoCipher_UNWRAP_MODE:
    [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:param];
    break;
    default:
    @throw new_JavaSecurityInvalidParameterException_initWithNSString_(JreStrcat("$I$", @"unknown opmode ", opmode, @" passed to ElGamal"));
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"can't handle parameters in ElGamal");
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @try {
    [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:nil withJavaSecuritySecureRandom:random];
  }
  @catch (JavaSecurityInvalidAlgorithmParameterException *e) {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_withJavaLangThrowable_(JreStrcat("$$", @"Eeeek! ", [e description]), e);
  }
}

- (IOSByteArray *)engineUpdateWithByteArray:(IOSByteArray *)input
                                    withInt:(jint)inputOffset
                                    withInt:(jint)inputLen {
  [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return nil;
}

- (jint)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inputOffset
                          withInt:(jint)inputLen
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outputOffset {
  [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return 0;
}

- (IOSByteArray *)engineDoFinalWithByteArray:(IOSByteArray *)input
                                     withInt:(jint)inputOffset
                                     withInt:(jint)inputLen {
  if (input != nil) {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesElGamalEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for ElGamal block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for ElGamal block");
    }
  }
  return LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_getOutput(self);
}

- (jint)engineDoFinalWithByteArray:(IOSByteArray *)input
                           withInt:(jint)inputOffset
                           withInt:(jint)inputLen
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outputOffset {
  if (outputOffset + [self engineGetOutputSizeWithInt:inputLen] > ((IOSByteArray *) nil_chk(output))->size_) {
    @throw new_JavaxCryptoShortBufferException_initWithNSString_(@"output buffer too short for input.");
  }
  if (input != nil) {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  if ([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesElGamalEngine class]]) {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize] + 1) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for ElGamal block");
    }
  }
  else {
    if ([((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(bOut_)) size] > [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(cipher_)) getInputBlockSize]) {
      @throw new_JavaLangArrayIndexOutOfBoundsException_initWithNSString_(@"too much data for ElGamal block");
    }
  }
  IOSByteArray *out = LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_getOutput(self);
  for (jint i = 0; i != ((IOSByteArray *) nil_chk(out))->size_; i++) {
    *IOSByteArray_GetRef(output, outputOffset + i) = IOSByteArray_Get(out, i);
  }
  return out->size_;
}

- (IOSByteArray *)getOutput {
  return LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_getOutput(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 1, 2, 3, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 4, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityAlgorithmParameters;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 8, 9, 10, -1, -1, -1 },
    { NULL, "V", 0x4, 11, 9, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 13, 14, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 15, 14, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 16, 17, -1, -1, -1 },
    { NULL, "[B", 0x4, 18, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 18, 20, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 21, 19, 22, -1, -1, -1 },
    { NULL, "I", 0x4, 21, 20, 23, -1, -1, -1 },
    { NULL, "[B", 0x2, -1, -1, 24, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher:);
  methods[1].selector = @selector(initFromSpecWithJavaxCryptoSpecOAEPParameterSpec:);
  methods[2].selector = @selector(engineGetBlockSize);
  methods[3].selector = @selector(engineGetKeySizeWithJavaSecurityKey:);
  methods[4].selector = @selector(engineGetOutputSizeWithInt:);
  methods[5].selector = @selector(engineGetParameters);
  methods[6].selector = @selector(engineSetModeWithNSString:);
  methods[7].selector = @selector(engineSetPaddingWithNSString:);
  methods[8].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:withJavaSecuritySecureRandom:);
  methods[9].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecurityAlgorithmParameters:withJavaSecuritySecureRandom:);
  methods[10].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySecureRandom:);
  methods[11].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[12].selector = @selector(engineUpdateWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[15].selector = @selector(getOutput);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cipher_", "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "paramSpec_", "LJavaSecuritySpecAlgorithmParameterSpec;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineParams_CipherSpi_", "LJavaSecurityAlgorithmParameters;", .constantValue.asLong = 0, 0x2, 25, -1, -1, -1 },
    { "bOut_", "LLibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoAsymmetricBlockCipher;", "initFromSpec", "LJavaxCryptoSpecOAEPParameterSpec;", "LJavaxCryptoNoSuchPaddingException;", "engineGetKeySize", "LJavaSecurityKey;", "engineGetOutputSize", "I", "engineSetMode", "LNSString;", "LJavaSecurityNoSuchAlgorithmException;", "engineSetPadding", "engineInit", "ILJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "ILJavaSecurityKey;LJavaSecurityAlgorithmParameters;LJavaSecuritySecureRandom;", "ILJavaSecurityKey;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;", "engineUpdate", "[BII", "[BII[BI", "engineDoFinal", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;LJavaxCryptoShortBufferException;", "LJavaxCryptoBadPaddingException;", "engineParams", "LLibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding;LLibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi = { "CipherSpi", "lib.org.bouncycastle.jcajce.provider.asymmetric.elgamal", ptrTable, methods, fields, 7, 0x1, 16, 4, -1, 26, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *self, id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_init(self);
  self->bOut_ = new_LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream_init();
  self->cipher_ = engine;
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *new_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, engine)
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *create_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(id<LibOrgBouncycastleCryptoAsymmetricBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi, initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_, engine)
}

void LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initFromSpecWithJavaxCryptoSpecOAEPParameterSpec_(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *self, JavaxCryptoSpecOAEPParameterSpec *pSpec) {
  JavaSecuritySpecMGF1ParameterSpec *mgfParams = (JavaSecuritySpecMGF1ParameterSpec *) cast_chk([((JavaxCryptoSpecOAEPParameterSpec *) nil_chk(pSpec)) getMGFParameters], [JavaSecuritySpecMGF1ParameterSpec class]);
  id<LibOrgBouncycastleCryptoDigest> digest = LibOrgBouncycastleJcajceProviderUtiljcaJceUtilDigestFactory_getDigestWithNSString_([((JavaSecuritySpecMGF1ParameterSpec *) nil_chk(mgfParams)) getDigestAlgorithm]);
  if (digest == nil) {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(JreStrcat("$$", @"no match on OAEP constructor for digest algorithm: ", [mgfParams getDigestAlgorithm]));
  }
  self->cipher_ = new_LibOrgBouncycastleCryptoEncodingsOAEPEncoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_withLibOrgBouncycastleCryptoDigest_withByteArray_(new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init(), digest, [((JavaxCryptoSpecPSource_PSpecified *) nil_chk(((JavaxCryptoSpecPSource_PSpecified *) cast_chk([pSpec getPSource], [JavaxCryptoSpecPSource_PSpecified class])))) getValue]);
  self->paramSpec_ = pSpec;
}

IOSByteArray *LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_getOutput(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi *self) {
  @try {
    return [((id<LibOrgBouncycastleCryptoAsymmetricBlockCipher>) nil_chk(self->cipher_)) processBlockWithByteArray:[((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) getBuf] withInt:0 withInt:[((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) size]];
  }
  @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
    @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to decrypt block", e);
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *e) {
    @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to decrypt block", e);
  }
  @finally {
    [((LibOrgBouncycastleJcajceProviderAsymmetricUtilBaseCipherSpi_ErasableOutputStream *) nil_chk(self->bOut_)) erase];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding = { "NoPadding", "lib.org.bouncycastle.jcajce.provider.asymmetric.elgamal", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding_init(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init());
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding *new_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding *create_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_NoPadding)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding = { "PKCS1v1_5Padding", "lib.org.bouncycastle.jcajce.provider.asymmetric.elgamal", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding_init(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(self, new_LibOrgBouncycastleCryptoEncodingsPKCS1Encoding_initWithLibOrgBouncycastleCryptoAsymmetricBlockCipher_(new_LibOrgBouncycastleCryptoEnginesElGamalEngine_init()));
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding *new_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding *create_LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricElgamalCipherSpi_PKCS1v1_5Padding)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/decryption_verification/DecryptionStreamFactory.java
//

#include "BcKeyFingerprintCalculator.h"
#include "BcPGPContentVerifierBuilderProvider.h"
#include "BcPublicKeyDataDecryptorFactory.h"
#include "CompressionAlgorithm.h"
#include "DecryptionStream.h"
#include "DecryptionStreamFactory.h"
#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "KeyFingerPrintCalculator.h"
#include "MissingPublicKeyCallback.h"
#include "OpenPgpMetadata.h"
#include "OpenPgpV4Fingerprint.h"
#include "PBESecretKeyDecryptor.h"
#include "PGPCompressedData.h"
#include "PGPContentVerifierBuilderProvider.h"
#include "PGPEncryptedDataList.h"
#include "PGPException.h"
#include "PGPLiteralData.h"
#include "PGPObjectFactory.h"
#include "PGPOnePassSignature.h"
#include "PGPOnePassSignatureList.h"
#include "PGPPrivateKey.h"
#include "PGPPublicKey.h"
#include "PGPPublicKeyEncryptedData.h"
#include "PGPPublicKeyRing.h"
#include "PGPSecretKey.h"
#include "PGPSecretKeyRingCollection.h"
#include "PGPUtil.h"
#include "PublicKeyDataDecryptorFactory.h"
#include "SecretKeyRingProtector.h"
#include "SignatureVerifyingInputStream.h"
#include "SymmetricKeyAlgorithm.h"
#include "java/io/InputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Long.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"

@interface LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory () {
 @public
  LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys_;
  id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptionKeyDecryptor_;
  id<JavaUtilSet> verificationKeys_;
  id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback_;
  LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *resultBuilder_;
  id<LibOrgBouncycastleOpenpgpOperatorPGPContentVerifierBuilderProvider> verifierBuilderProvider_;
  id<LibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator> fingerCalc_;
  id<JavaUtilMap> verifiableOnePassSignatures_;
}

- (instancetype)initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *)decryptionKeys
                 withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                            withJavaUtilSet:(id<JavaUtilSet>)verificationKeys
     withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:(id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback>)missingPublicKeyCallback;

- (JavaIoInputStream *)wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory:(LibOrgBouncycastleOpenpgpPGPObjectFactory *)objectFactory;

- (JavaIoInputStream *)decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList:(LibOrgBouncycastleOpenpgpPGPEncryptedDataList *)encryptedDataList;

- (void)initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList:(LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *)onePassSignatureList OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, decryptionKeys_, LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, decryptionKeyDecryptor_, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, verificationKeys_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, missingPublicKeyCallback_, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, resultBuilder_, LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, verifierBuilderProvider_, id<LibOrgBouncycastleOpenpgpOperatorPGPContentVerifierBuilderProvider>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, fingerCalc_, id<LibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, verifiableOnePassSignatures_, id<JavaUtilMap>)

inline JavaUtilLoggingLogger *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_get_LOGGER(void);
static JavaUtilLoggingLogger *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, LOGGER, JavaUtilLoggingLogger *)

inline JavaUtilLoggingLevel *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_get_LEVEL(void);
static JavaUtilLoggingLevel *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, LEVEL, JavaUtilLoggingLevel *)

__attribute__((unused)) static void LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback);

__attribute__((unused)) static LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *new_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *create_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback);

__attribute__((unused)) static JavaIoInputStream *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPObjectFactory *objectFactory);

__attribute__((unused)) static JavaIoInputStream *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPEncryptedDataList *encryptedDataList);

__attribute__((unused)) static void LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *onePassSignatureList);

J2OBJC_INITIALIZED_DEFN(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory)

@implementation LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory

- (instancetype)initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *)decryptionKeys
                 withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                            withJavaUtilSet:(id<JavaUtilSet>)verificationKeys
     withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:(id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback>)missingPublicKeyCallback {
  LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(self, decryptionKeys, decryptor, verificationKeys, missingPublicKeyCallback);
  return self;
}

+ (LibComAfterlogicPgpDecryption_verificationDecryptionStream *)createWithJavaIoInputStream:(JavaIoInputStream *)inputStream
                                    withLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *)decryptionKeys
                                 withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                                            withJavaUtilSet:(id<JavaUtilSet>)verificationKeys
                     withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:(id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback>)missingPublicKeyCallback {
  return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_createWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(inputStream, decryptionKeys, decryptor, verificationKeys, missingPublicKeyCallback);
}

- (JavaIoInputStream *)wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory:(LibOrgBouncycastleOpenpgpPGPObjectFactory *)objectFactory {
  return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(self, objectFactory);
}

- (JavaIoInputStream *)decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList:(LibOrgBouncycastleOpenpgpPGPEncryptedDataList *)encryptedDataList {
  return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList_(self, encryptedDataList);
}

- (void)initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList:(LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *)onePassSignatureList {
  LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList_(self, onePassSignatureList);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, 1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpDecryption_verificationDecryptionStream;", 0x9, 2, 3, 4, 5, -1, -1 },
    { NULL, "LJavaIoInputStream;", 0x2, 6, 7, 4, -1, -1, -1 },
    { NULL, "LJavaIoInputStream;", 0x2, 8, 9, 10, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, 10, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:withJavaUtilSet:withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:);
  methods[1].selector = @selector(createWithJavaIoInputStream:withLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:withJavaUtilSet:withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:);
  methods[2].selector = @selector(wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory:);
  methods[3].selector = @selector(decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList:);
  methods[4].selector = @selector(initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "LOGGER", "LJavaUtilLoggingLogger;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "LEVEL", "LJavaUtilLoggingLevel;", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "decryptionKeys_", "LLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "decryptionKeyDecryptor_", "LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "verificationKeys_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x12, -1, -1, 15, -1 },
    { "missingPublicKeyCallback_", "LLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "resultBuilder_", "LLibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "verifierBuilderProvider_", "LLibOrgBouncycastleOpenpgpOperatorPGPContentVerifierBuilderProvider;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "fingerCalc_", "LLibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "verifiableOnePassSignatures_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 16, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection;LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;LJavaUtilSet;LLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback;", "(Llib/org/bouncycastle/openpgp/PGPSecretKeyRingCollection;Llib/com/afterlogic/pgp/key/protection/SecretKeyRingProtector;Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPublicKeyRing;>;Llib/com/afterlogic/pgp/decryption_verification/MissingPublicKeyCallback;)V", "create", "LJavaIoInputStream;LLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection;LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;LJavaUtilSet;LLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback;", "LJavaIoIOException;LLibOrgBouncycastleOpenpgpPGPException;", "(Ljava/io/InputStream;Llib/org/bouncycastle/openpgp/PGPSecretKeyRingCollection;Llib/com/afterlogic/pgp/key/protection/SecretKeyRingProtector;Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPublicKeyRing;>;Llib/com/afterlogic/pgp/decryption_verification/MissingPublicKeyCallback;)Llib/com/afterlogic/pgp/decryption_verification/DecryptionStream;", "wrap", "LLibOrgBouncycastleOpenpgpPGPObjectFactory;", "decrypt", "LLibOrgBouncycastleOpenpgpPGPEncryptedDataList;", "LLibOrgBouncycastleOpenpgpPGPException;", "initOnePassSignatures", "LLibOrgBouncycastleOpenpgpPGPOnePassSignatureList;", &LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER, &LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL, "Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPublicKeyRing;>;", "Ljava/util/Map<Llib/com/afterlogic/pgp/key/OpenPgpV4Fingerprint;Llib/org/bouncycastle/openpgp/PGPOnePassSignature;>;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory = { "DecryptionStreamFactory", "lib.com.afterlogic.pgp.decryption_verification", ptrTable, methods, fields, 7, 0x11, 5, 10, -1, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory;
}

+ (void)initialize {
  if (self == [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory class]) {
    LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER = JavaUtilLoggingLogger_getLoggerWithNSString_([LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_class_() getName]);
    LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL = JreLoadStatic(JavaUtilLoggingLevel, FINE);
    J2OBJC_SET_INITIALIZED(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory)
  }
}

@end

void LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback) {
  NSObject_init(self);
  self->verificationKeys_ = new_JavaUtilHashSet_init();
  self->resultBuilder_ = LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_getBuilder();
  self->verifierBuilderProvider_ = new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPContentVerifierBuilderProvider_init();
  self->fingerCalc_ = new_LibOrgBouncycastleOpenpgpOperatorBcBcKeyFingerprintCalculator_init();
  self->verifiableOnePassSignatures_ = new_JavaUtilHashMap_init();
  self->decryptionKeys_ = decryptionKeys;
  self->decryptionKeyDecryptor_ = decryptor;
  [self->verificationKeys_ addAllWithJavaUtilCollection:verificationKeys != nil ? verificationKeys : (id) JavaUtilCollections_emptyList()];
  self->missingPublicKeyCallback_ = missingPublicKeyCallback;
}

LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *new_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_, decryptionKeys, decryptor, verificationKeys, missingPublicKeyCallback)
}

LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *create_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory, initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_, decryptionKeys, decryptor, verificationKeys, missingPublicKeyCallback)
}

LibComAfterlogicPgpDecryption_verificationDecryptionStream *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_createWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(JavaIoInputStream *inputStream, LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *decryptionKeys, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> decryptor, id<JavaUtilSet> verificationKeys, id<LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback> missingPublicKeyCallback) {
  LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initialize();
  LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *factory = new_LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection_withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector_withJavaUtilSet_withLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback_(decryptionKeys, decryptor, verificationKeys, missingPublicKeyCallback);
  LibOrgBouncycastleOpenpgpPGPObjectFactory *objectFactory = new_LibOrgBouncycastleOpenpgpPGPObjectFactory_initWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator_(LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(inputStream), new_LibOrgBouncycastleOpenpgpOperatorBcBcKeyFingerprintCalculator_init());
  return new_LibComAfterlogicPgpDecryption_verificationDecryptionStream_initWithJavaIoInputStream_withLibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(factory, objectFactory), factory->resultBuilder_);
}

JavaIoInputStream *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPObjectFactory *objectFactory) {
  id pgpObj;
  while ((pgpObj = [((LibOrgBouncycastleOpenpgpPGPObjectFactory *) nil_chk(objectFactory)) nextObject]) != nil) {
    if ([pgpObj isKindOfClass:[LibOrgBouncycastleOpenpgpPGPEncryptedDataList class]]) {
      [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:@"Encountered PGPEncryptedDataList"];
      LibOrgBouncycastleOpenpgpPGPEncryptedDataList *encDataList = (LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) pgpObj;
      JavaIoInputStream *nextStream = LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList_(self, encDataList);
      objectFactory = new_LibOrgBouncycastleOpenpgpPGPObjectFactory_initWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator_(LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(nextStream), self->fingerCalc_);
      return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(self, objectFactory);
    }
    if ([pgpObj isKindOfClass:[LibOrgBouncycastleOpenpgpPGPCompressedData class]]) {
      LibOrgBouncycastleOpenpgpPGPCompressedData *compressedData = (LibOrgBouncycastleOpenpgpPGPCompressedData *) pgpObj;
      JavaIoInputStream *nextStream = [((LibOrgBouncycastleOpenpgpPGPCompressedData *) nil_chk(compressedData)) getDataStream];
      (void) [((LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *) nil_chk(self->resultBuilder_)) setCompressionAlgorithmWithLibComAfterlogicPgpAlgorithmCompressionAlgorithm:LibComAfterlogicPgpAlgorithmCompressionAlgorithm_fromIdWithInt_([compressedData getAlgorithm])];
      objectFactory = new_LibOrgBouncycastleOpenpgpPGPObjectFactory_initWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpOperatorKeyFingerPrintCalculator_(LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(nextStream), self->fingerCalc_);
      [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$@", @"Encountered PGPCompressedData: ", LibComAfterlogicPgpAlgorithmCompressionAlgorithm_fromIdWithInt_([compressedData getAlgorithm]))];
      return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(self, objectFactory);
    }
    if ([pgpObj isKindOfClass:[LibOrgBouncycastleOpenpgpPGPOnePassSignatureList class]]) {
      LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *onePassSignatures = (LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *) pgpObj;
      [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$I", @"Encountered PGPOnePassSignatureList of size ", [((LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *) nil_chk(onePassSignatures)) size])];
      LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList_(self, onePassSignatures);
      return LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_wrapWithLibOrgBouncycastleOpenpgpPGPObjectFactory_(self, objectFactory);
    }
    if ([pgpObj isKindOfClass:[LibOrgBouncycastleOpenpgpPGPLiteralData class]]) {
      [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:@"Found PGPLiteralData"];
      LibOrgBouncycastleOpenpgpPGPLiteralData *literalData = (LibOrgBouncycastleOpenpgpPGPLiteralData *) pgpObj;
      JavaIoInputStream *literalDataInputStream = [((LibOrgBouncycastleOpenpgpPGPLiteralData *) nil_chk(literalData)) getInputStream];
      if ([((id<JavaUtilMap>) nil_chk(self->verifiableOnePassSignatures_)) isEmpty]) {
        [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:@"No OnePassSignatures found -> We are done"];
        return literalDataInputStream;
      }
      return new_LibComAfterlogicPgpDecryption_verificationSignatureVerifyingInputStream_initWithJavaIoInputStream_withLibOrgBouncycastleOpenpgpPGPObjectFactory_withJavaUtilMap_withLibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder_(literalDataInputStream, objectFactory, self->verifiableOnePassSignatures_, self->resultBuilder_);
    }
  }
  @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"No Literal Data Packet found");
}

JavaIoInputStream *LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_decryptWithLibOrgBouncycastleOpenpgpPGPEncryptedDataList_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPEncryptedDataList *encryptedDataList) {
  id<JavaUtilIterator> iterator = [((LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) nil_chk(encryptedDataList)) getEncryptedDataObjects];
  if (![((id<JavaUtilIterator>) nil_chk(iterator)) hasNext]) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"Decryption failed - EncryptedDataList has no items");
  }
  LibOrgBouncycastleOpenpgpPGPPrivateKey *decryptionKey = nil;
  LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData *encryptedSessionKey = nil;
  while ([iterator hasNext]) {
    LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData *encryptedData = (LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData *) cast_chk([iterator next], [LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData class]);
    jlong keyId = [((LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData *) nil_chk(encryptedData)) getKeyID];
    (void) [((LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *) nil_chk(self->resultBuilder_)) addRecipientKeyIdWithJavaLangLong:JavaLangLong_valueOfWithLong_(keyId)];
    [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$$", @"PGPEncryptedData is encrypted for key ", JavaLangLong_toHexStringWithLong_(keyId))];
    LibOrgBouncycastleOpenpgpPGPSecretKey *secretKey = [((LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *) nil_chk(self->decryptionKeys_)) getSecretKeyWithLong:keyId];
    if (secretKey != nil) {
      [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$$", @"Found respective secret key ", JavaLangLong_toHexStringWithLong_(keyId))];
      encryptedSessionKey = encryptedData;
      decryptionKey = [secretKey extractPrivateKeyWithLibOrgBouncycastleOpenpgpOperatorPBESecretKeyDecryptor:[((id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>) nil_chk(self->decryptionKeyDecryptor_)) getDecryptorWithJavaLangLong:JavaLangLong_valueOfWithLong_(keyId)]];
      (void) [self->resultBuilder_ setDecryptionFingerprintWithLibComAfterlogicPgpKeyOpenPgpV4Fingerprint:new_LibComAfterlogicPgpKeyOpenPgpV4Fingerprint_initWithLibOrgBouncycastleOpenpgpPGPSecretKey_(secretKey)];
    }
  }
  if (decryptionKey == nil) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"Decryption failed - No suitable decryption key found");
  }
  id<LibOrgBouncycastleOpenpgpOperatorPublicKeyDataDecryptorFactory> keyDecryptor = new_LibOrgBouncycastleOpenpgpOperatorBcBcPublicKeyDataDecryptorFactory_initWithLibOrgBouncycastleOpenpgpPGPPrivateKey_(decryptionKey);
  LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *symmetricKeyAlgorithm = LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_fromIdWithInt_([((LibOrgBouncycastleOpenpgpPGPPublicKeyEncryptedData *) nil_chk(encryptedSessionKey)) getSymmetricAlgorithmWithLibOrgBouncycastleOpenpgpOperatorPublicKeyDataDecryptorFactory:keyDecryptor]);
  [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$@", @"Message is encrypted using ", symmetricKeyAlgorithm)];
  (void) [((LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *) nil_chk(self->resultBuilder_)) setSymmetricKeyAlgorithmWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:symmetricKeyAlgorithm];
  if ([encryptedSessionKey isIntegrityProtected]) {
    [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:@"Message is integrity protected"];
    (void) [self->resultBuilder_ setIntegrityProtectedWithBoolean:true];
  }
  else {
    [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:@"Message is not integrity protected"];
    (void) [self->resultBuilder_ setIntegrityProtectedWithBoolean:false];
  }
  JavaIoInputStream *decryptionStream = [encryptedSessionKey getDataStreamWithLibOrgBouncycastleOpenpgpOperatorPublicKeyDataDecryptorFactory:keyDecryptor];
  return decryptionStream;
}

void LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_initOnePassSignaturesWithLibOrgBouncycastleOpenpgpPGPOnePassSignatureList_(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory *self, LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *onePassSignatureList) {
  id<JavaUtilIterator> iterator = [((LibOrgBouncycastleOpenpgpPGPOnePassSignatureList *) nil_chk(onePassSignatureList)) iterator];
  if (![((id<JavaUtilIterator>) nil_chk(iterator)) hasNext]) {
    @throw new_LibOrgBouncycastleOpenpgpPGPException_initWithNSString_(@"Verification failed - No OnePassSignatures found");
  }
  while ([iterator hasNext]) {
    LibOrgBouncycastleOpenpgpPGPOnePassSignature *signature = [iterator next];
    jlong keyId = [((LibOrgBouncycastleOpenpgpPGPOnePassSignature *) nil_chk(signature)) getKeyID];
    (void) [((LibComAfterlogicPgpDecryption_verificationOpenPgpMetadata_Builder *) nil_chk(self->resultBuilder_)) addUnverifiedSignatureKeyIdWithJavaLangLong:JavaLangLong_valueOfWithLong_(keyId)];
    [((JavaUtilLoggingLogger *) nil_chk(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER)) logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$$", @"Message contains OnePassSignature from ", JavaLangLong_toHexStringWithLong_(keyId))];
    LibOrgBouncycastleOpenpgpPGPPublicKey *verificationKey = nil;
    for (LibOrgBouncycastleOpenpgpPGPPublicKeyRing * __strong publicKeyRing in nil_chk(self->verificationKeys_)) {
      verificationKey = [((LibOrgBouncycastleOpenpgpPGPPublicKeyRing *) nil_chk(publicKeyRing)) getPublicKeyWithLong:keyId];
      if (verificationKey != nil) {
        [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LEVEL withNSString:JreStrcat("$$", @"Found respective public key ", JavaLangLong_toHexStringWithLong_(keyId))];
        break;
      }
    }
    if (verificationKey == nil) {
      [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINER) withNSString:JreStrcat("$$$", @"No public key for signature of ", JavaLangLong_toHexStringWithLong_(keyId), @" found.")];
      if (self->missingPublicKeyCallback_ == nil) {
        [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINER) withNSString:JreStrcat("$$", @"Skip signature of ", JavaLangLong_toHexStringWithLong_(keyId))];
        continue;
      }
      LibOrgBouncycastleOpenpgpPGPPublicKey *missingPublicKey = [self->missingPublicKeyCallback_ onMissingPublicKeyEncounteredWithJavaLangLong:JavaLangLong_valueOfWithLong_(keyId)];
      if (missingPublicKey == nil) {
        [LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory_LOGGER logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINER) withNSString:JreStrcat("$$", @"Skip signature of ", JavaLangLong_toHexStringWithLong_(keyId))];
        continue;
      }
      if ([missingPublicKey getKeyID] != keyId) {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$$", @"KeyID of the provided public key differs from the signatures keyId. The signature was created from ", JavaLangLong_toHexStringWithLong_(keyId), @" while the provided key has ID ", JavaLangLong_toHexStringWithLong_([missingPublicKey getKeyID])));
      }
      verificationKey = missingPublicKey;
    }
    [signature init__WithLibOrgBouncycastleOpenpgpOperatorPGPContentVerifierBuilderProvider:self->verifierBuilderProvider_ withLibOrgBouncycastleOpenpgpPGPPublicKey:verificationKey];
    (void) [((id<JavaUtilMap>) nil_chk(self->verifiableOnePassSignatures_)) putWithId:new_LibComAfterlogicPgpKeyOpenPgpV4Fingerprint_initWithLibOrgBouncycastleOpenpgpPGPPublicKey_(verificationKey) withId:signature];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpDecryption_verificationDecryptionStreamFactory)

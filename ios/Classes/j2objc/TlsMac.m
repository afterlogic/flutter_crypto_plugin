//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/TlsMac.java
//

#include "Arrays.h"
#include "Digest.h"
#include "HMac.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "LongDigest.h"
#include "Mac.h"
#include "ProtocolVersion.h"
#include "SSL3Mac.h"
#include "SecurityParameters.h"
#include "TlsContext.h"
#include "TlsMac.h"
#include "TlsUtils.h"
#include "java/lang/Math.h"

@implementation LibOrgBouncycastleCryptoTlsTlsMac

- (instancetype)initWithLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
                           withLibOrgBouncycastleCryptoDigest:(id<LibOrgBouncycastleCryptoDigest>)digest
                                                withByteArray:(IOSByteArray *)key
                                                      withInt:(jint)keyOff
                                                      withInt:(jint)keyLen {
  LibOrgBouncycastleCryptoTlsTlsMac_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_(self, context, digest, key, keyOff, keyLen);
  return self;
}

- (IOSByteArray *)getMACSecret {
  return self->secret_;
}

- (jint)getSize {
  return macLength_;
}

- (IOSByteArray *)calculateMacWithLong:(jlong)seqNo
                             withShort:(jshort)type
                         withByteArray:(IOSByteArray *)message
                               withInt:(jint)offset
                               withInt:(jint)length {
  LibOrgBouncycastleCryptoTlsProtocolVersion *serverVersion = [((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context_)) getServerVersion];
  jboolean isSSL = [((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(serverVersion)) isSSL];
  IOSByteArray *macHeader = [IOSByteArray newArrayWithLength:isSSL ? 11 : 13];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint64WithLong_withByteArray_withInt_(seqNo, macHeader, 0);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withByteArray_withInt_(type, macHeader, 8);
  if (!isSSL) {
    LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withByteArray_withInt_(serverVersion, macHeader, 9);
  }
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withByteArray_withInt_(length, macHeader, macHeader->size_ - 2);
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:macHeader withInt:0 withInt:macHeader->size_];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:message withInt:offset withInt:length];
  IOSByteArray *result = [IOSByteArray newArrayWithLength:[((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) getMacSize]];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) doFinalWithByteArray:result withInt:0];
  return [self truncateWithByteArray:result];
}

- (IOSByteArray *)calculateMacConstantTimeWithLong:(jlong)seqNo
                                         withShort:(jshort)type
                                     withByteArray:(IOSByteArray *)message
                                           withInt:(jint)offset
                                           withInt:(jint)length
                                           withInt:(jint)fullLength
                                     withByteArray:(IOSByteArray *)dummyData {
  IOSByteArray *result = [self calculateMacWithLong:seqNo withShort:type withByteArray:message withInt:offset withInt:length];
  jint headerLength = LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_(context_) ? 11 : 13;
  jint extra = [self getDigestBlockCountWithInt:headerLength + fullLength] - [self getDigestBlockCountWithInt:headerLength + length];
  while (--extra >= 0) {
    [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByteArray:dummyData withInt:0 withInt:digestBlockSize_];
  }
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) updateWithByte:IOSByteArray_Get(nil_chk(dummyData), 0)];
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(mac_)) reset];
  return result;
}

- (jint)getDigestBlockCountWithInt:(jint)inputLength {
  return (inputLength + digestOverhead_) / digestBlockSize_;
}

- (IOSByteArray *)truncateWithByteArray:(IOSByteArray *)bs {
  if (((IOSByteArray *) nil_chk(bs))->size_ <= macLength_) {
    return bs;
  }
  return LibOrgBouncycastleUtilArrays_copyOfWithByteArray_withInt_(bs, macLength_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 5, 6, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 7, 8, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoDigest:withByteArray:withInt:withInt:);
  methods[1].selector = @selector(getMACSecret);
  methods[2].selector = @selector(getSize);
  methods[3].selector = @selector(calculateMacWithLong:withShort:withByteArray:withInt:withInt:);
  methods[4].selector = @selector(calculateMacConstantTimeWithLong:withShort:withByteArray:withInt:withInt:withInt:withByteArray:);
  methods[5].selector = @selector(getDigestBlockCountWithInt:);
  methods[6].selector = @selector(truncateWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "context_", "LLibOrgBouncycastleCryptoTlsTlsContext;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "secret_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "mac_", "LLibOrgBouncycastleCryptoMac;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "digestBlockSize_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "digestOverhead_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "macLength_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoDigest;[BII", "calculateMac", "JS[BII", "calculateMacConstantTime", "JS[BIII[B", "getDigestBlockCount", "I", "truncate", "[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsMac = { "TlsMac", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 7, 6, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsMac;
}

@end

void LibOrgBouncycastleCryptoTlsTlsMac_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_(LibOrgBouncycastleCryptoTlsTlsMac *self, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoDigest> digest, IOSByteArray *key, jint keyOff, jint keyLen) {
  NSObject_init(self);
  self->context_ = context;
  LibOrgBouncycastleCryptoParamsKeyParameter *keyParameter = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key, keyOff, keyLen);
  self->secret_ = LibOrgBouncycastleUtilArrays_cloneWithByteArray_([keyParameter getKey]);
  if ([digest isKindOfClass:[LibOrgBouncycastleCryptoDigestsLongDigest class]]) {
    self->digestBlockSize_ = 128;
    self->digestOverhead_ = 16;
  }
  else {
    self->digestBlockSize_ = 64;
    self->digestOverhead_ = 8;
  }
  if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_(context)) {
    self->mac_ = new_LibOrgBouncycastleCryptoTlsSSL3Mac_initWithLibOrgBouncycastleCryptoDigest_(digest);
    if ([((id<LibOrgBouncycastleCryptoDigest>) nil_chk(digest)) getDigestSize] == 20) {
      self->digestOverhead_ = 4;
    }
  }
  else {
    self->mac_ = new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(digest);
  }
  [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) init__WithLibOrgBouncycastleCryptoCipherParameters:keyParameter];
  self->macLength_ = [((id<LibOrgBouncycastleCryptoMac>) nil_chk(self->mac_)) getMacSize];
  if (((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk([((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk(context)) getSecurityParameters]))->truncatedHMac_) {
    self->macLength_ = JavaLangMath_minWithInt_withInt_(self->macLength_, 10);
  }
}

LibOrgBouncycastleCryptoTlsTlsMac *new_LibOrgBouncycastleCryptoTlsTlsMac_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoDigest> digest, IOSByteArray *key, jint keyOff, jint keyLen) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsMac, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_, context, digest, key, keyOff, keyLen)
}

LibOrgBouncycastleCryptoTlsTlsMac *create_LibOrgBouncycastleCryptoTlsTlsMac_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_(id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoDigest> digest, IOSByteArray *key, jint keyOff, jint keyLen) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsMac, initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoDigest_withByteArray_withInt_withInt_, context, digest, key, keyOff, keyLen)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsMac)

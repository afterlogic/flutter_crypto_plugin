//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/TlsClientProtocol.java
//

#include "AbstractTlsContext.h"
#include "AlertDescription.h"
#include "Arrays.h"
#include "Certificate.h"
#include "CertificateRequest.h"
#include "CertificateStatus.h"
#include "CipherSuite.h"
#include "ConnectionEnd.h"
#include "DigitallySigned.h"
#include "HandshakeType.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "NewSessionTicket.h"
#include "ProtocolVersion.h"
#include "RandomGenerator.h"
#include "RecordStream.h"
#include "SecurityParameters.h"
#include "SessionParameters.h"
#include "SignatureAndHashAlgorithm.h"
#include "TlsAuthentication.h"
#include "TlsCipher.h"
#include "TlsClient.h"
#include "TlsClientContextImpl.h"
#include "TlsClientProtocol.h"
#include "TlsCompression.h"
#include "TlsContext.h"
#include "TlsCredentials.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsHandshakeHash.h"
#include "TlsKeyExchange.h"
#include "TlsPeer.h"
#include "TlsProtocol.h"
#include "TlsSession.h"
#include "TlsSessionImpl.h"
#include "TlsSignerCredentials.h"
#include "TlsUtils.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/security/SecureRandom.h"
#include "java/util/Enumeration.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@implementation LibOrgBouncycastleCryptoTlsTlsClientProtocol

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)input
                   withJavaIoOutputStream:(JavaIoOutputStream *)output
             withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  return self;
}

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (void)connectWithLibOrgBouncycastleCryptoTlsTlsClient:(id<LibOrgBouncycastleCryptoTlsTlsClient>)tlsClient {
  if (tlsClient == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'tlsClient' cannot be null");
  }
  if (self->tlsClient_ != nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"'connect' can only be called once");
  }
  self->tlsClient_ = tlsClient;
  self->securityParameters_ = new_LibOrgBouncycastleCryptoTlsSecurityParameters_init();
  self->securityParameters_->entity_ = LibOrgBouncycastleCryptoTlsConnectionEnd_client;
  self->tlsClientContext_ = new_LibOrgBouncycastleCryptoTlsTlsClientContextImpl_initWithJavaSecuritySecureRandom_withLibOrgBouncycastleCryptoTlsSecurityParameters_(secureRandom_, securityParameters_);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->clientRandom_ = LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_([tlsClient shouldUseGMTUnixTime], [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(tlsClientContext_)) getNonceRandomGenerator]);
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) init__WithLibOrgBouncycastleCryptoTlsTlsClientContext:tlsClientContext_];
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:tlsClientContext_];
  id<LibOrgBouncycastleCryptoTlsTlsSession> sessionToResume = [tlsClient getSessionToResume];
  if (sessionToResume != nil && [sessionToResume isResumable]) {
    LibOrgBouncycastleCryptoTlsSessionParameters *sessionParameters = [sessionToResume exportSessionParameters];
    if (sessionParameters != nil && [sessionParameters isExtendedMasterSecret]) {
      self->tlsSession_ = sessionToResume;
      self->sessionParameters_ = sessionParameters;
    }
  }
  [self sendClientHelloMessage];
  self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO;
  [self blockForHandshake];
}

- (void)cleanupHandshake {
  [super cleanupHandshake];
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

- (id<LibOrgBouncycastleCryptoTlsTlsContext>)getContext {
  return tlsClientContext_;
}

- (LibOrgBouncycastleCryptoTlsAbstractTlsContext *)getContextAdmin {
  return tlsClientContext_;
}

- (id<LibOrgBouncycastleCryptoTlsTlsPeer>)getPeer {
  return tlsClient_;
}

- (void)handleHandshakeMessageWithShort:(jshort)type
         withJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  if (self->resumedSession_) {
    if (type != LibOrgBouncycastleCryptoTlsHandshakeType_finished || self->connection_state_ != LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
    }
    [self processFinishedMessageWithJavaIoByteArrayInputStream:buf];
    self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
    [self sendChangeCipherSpecMessage];
    [self sendFinishedMessage];
    self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
    [self completeHandshake];
    return;
  }
  switch (type) {
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          self->peerCertificate_ = LibOrgBouncycastleCryptoTlsCertificate_parseWithJavaIoInputStream_(buf);
          LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          if (self->peerCertificate_ == nil || [self->peerCertificate_ isEmpty]) {
            self->allowCertificateStatus_ = false;
          }
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processServerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:self->peerCertificate_];
          self->authentication_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getAuthentication];
          [((id<LibOrgBouncycastleCryptoTlsTlsAuthentication>) nil_chk(self->authentication_)) notifyServerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:self->peerCertificate_];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE;
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate_status:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        {
          if (!self->allowCertificateStatus_) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
          self->certificateStatus_ = LibOrgBouncycastleCryptoTlsCertificateStatus_parseWithJavaIoInputStream_(buf);
          LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS;
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_finished:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED:
        {
          if (self->expectSessionTicket_) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET:
        {
          [self processFinishedMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
          [self completeHandshake];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_hello:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO:
        {
          [self receiveServerHelloMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO;
          [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) notifyHelloComplete];
          [self applyMaxFragmentLengthExtension];
          if (self->resumedSession_) {
            ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->masterSecret_ = LibOrgBouncycastleUtilArrays_cloneWithByteArray_([((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getMasterSecret]);
            [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setPendingConnectionStateWithLibOrgBouncycastleCryptoTlsTlsCompression:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCompression] withLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCipher]];
          }
          else {
            [self invalidateSession];
            if (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 0) {
              self->tlsSession_ = new_LibOrgBouncycastleCryptoTlsTlsSessionImpl_initWithByteArray_withLibOrgBouncycastleCryptoTlsSessionParameters_(self->selectedSessionID_, nil);
            }
          }
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(buf)];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_hello_done:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerCredentials];
          self->authentication_ = nil;
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerKeyExchange];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE:
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST:
        {
          LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE;
          [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash])) sealHashAlgorithms];
          JavaUtilVector *clientSupplementalData = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getClientSupplementalData];
          if (clientSupplementalData != nil) {
            [self sendSupplementalDataMessageWithJavaUtilVector:clientSupplementalData];
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA;
          id<LibOrgBouncycastleCryptoTlsTlsCredentials> clientCreds = nil;
          if (certificateRequest_ == nil) {
            [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
          }
          else {
            clientCreds = [((id<LibOrgBouncycastleCryptoTlsTlsAuthentication>) nil_chk(self->authentication_)) getClientCredentialsWithLibOrgBouncycastleCryptoTlsCertificateRequest:certificateRequest_];
            if (clientCreds == nil) {
              [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
              [self sendCertificateMessageWithLibOrgBouncycastleCryptoTlsCertificate:JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN)];
            }
            else {
              [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processClientCredentialsWithLibOrgBouncycastleCryptoTlsTlsCredentials:clientCreds];
              [self sendCertificateMessageWithLibOrgBouncycastleCryptoTlsCertificate:[clientCreds getCertificate]];
            }
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE;
          [self sendClientKeyExchangeMessage];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE;
          if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
            LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
          }
          id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash> prepareFinishHash = [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) prepareToFinish];
          ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->sessionHash_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_([self getContext], prepareFinishHash, nil);
          if (!LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
            LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
          }
          [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setPendingConnectionStateWithLibOrgBouncycastleCryptoTlsTlsCompression:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCompression] withLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCipher]];
          if (clientCreds != nil && [LibOrgBouncycastleCryptoTlsTlsSignerCredentials_class_() isInstance:clientCreds]) {
            id<LibOrgBouncycastleCryptoTlsTlsSignerCredentials> signerCredentials = (id<LibOrgBouncycastleCryptoTlsTlsSignerCredentials>) cast_check(clientCreds, LibOrgBouncycastleCryptoTlsTlsSignerCredentials_class_());
            LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *signatureAndHashAlgorithm = LibOrgBouncycastleCryptoTlsTlsUtils_getSignatureAndHashAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsSignerCredentials_([self getContext], signerCredentials);
            IOSByteArray *hash_;
            if (signatureAndHashAlgorithm == nil) {
              hash_ = [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) getSessionHash];
            }
            else {
              hash_ = [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk(prepareFinishHash)) getFinalHashWithShort:[signatureAndHashAlgorithm getHash]];
            }
            IOSByteArray *signature = [signerCredentials generateCertificateSignatureWithByteArray:hash_];
            LibOrgBouncycastleCryptoTlsDigitallySigned *certificateVerify = new_LibOrgBouncycastleCryptoTlsDigitallySigned_initWithLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm_withByteArray_(signatureAndHashAlgorithm, signature);
            [self sendCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDigitallySigned:certificateVerify];
            self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY;
          }
          [self sendChangeCipherSpecMessage];
          [self sendFinishedMessage];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_key_exchange:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerCredentials];
          self->authentication_ = nil;
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processServerKeyExchangeWithJavaIoInputStream:buf];
          LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE;
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate_request:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerKeyExchange];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE:
        {
          if (self->authentication_ == nil) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
          }
          self->certificateRequest_ = LibOrgBouncycastleCryptoTlsCertificateRequest_parseWithLibOrgBouncycastleCryptoTlsTlsContext_withJavaIoInputStream_([self getContext], buf);
          LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) validateCertificateRequestWithLibOrgBouncycastleCryptoTlsCertificateRequest:self->certificateRequest_];
          LibOrgBouncycastleCryptoTlsTlsUtils_trackHashAlgorithmsWithLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withJavaUtilVector_([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash], [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(self->certificateRequest_)) getSupportedSignatureAlgorithms]);
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST;
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_session_ticket:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED:
        {
          if (!self->expectSessionTicket_) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
          [self invalidateSession];
          [self receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:buf];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET;
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_hello_request:
    {
      LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
      if (self->connection_state_ == LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END) {
        [self refuseRenegotiation];
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_client_hello:
    case LibOrgBouncycastleCryptoTlsHandshakeType_client_key_exchange:
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate_verify:
    case LibOrgBouncycastleCryptoTlsHandshakeType_hello_verify_request:
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
}

- (void)handleSupplementalDataWithJavaUtilVector:(JavaUtilVector *)serverSupplementalData {
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) processServerSupplementalDataWithJavaUtilVector:serverSupplementalData];
  self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA;
  self->keyExchange_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getKeyExchange];
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:[self getContext]];
}

- (void)receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  LibOrgBouncycastleCryptoTlsNewSessionTicket *newSessionTicket = LibOrgBouncycastleCryptoTlsNewSessionTicket_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) notifyNewSessionTicketWithLibOrgBouncycastleCryptoTlsNewSessionTicket:newSessionTicket];
}

- (void)receiveServerHelloMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  {
    LibOrgBouncycastleCryptoTlsProtocolVersion *server_version = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
    if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(server_version)) isDTLS]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    if (![server_version equalsWithLibOrgBouncycastleCryptoTlsProtocolVersion:[((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getReadVersion]]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = [((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getClientVersion];
    if (![server_version isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    [((LibOrgBouncycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifyServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->serverRandom_ = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(32, buf);
  self->selectedSessionID_ = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  if (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 32) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySessionIDWithByteArray:self->selectedSessionID_];
  self->resumedSession_ = (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 0 && self->tlsSession_ != nil && LibOrgBouncycastleUtilArrays_areEqualWithByteArray_withByteArray_(self->selectedSessionID_, [self->tlsSession_ getSessionID]));
  jint selectedCipherSuite = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
  if (!LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(self->offeredCipherSuites_, selectedCipherSuite) || selectedCipherSuite == LibOrgBouncycastleCryptoTlsCipherSuite_TLS_NULL_WITH_NULL_NULL || LibOrgBouncycastleCryptoTlsCipherSuite_isSCSVWithInt_(selectedCipherSuite) || !LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withLibOrgBouncycastleCryptoTlsProtocolVersion_(selectedCipherSuite, [((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getServerVersion])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySelectedCipherSuiteWithInt:selectedCipherSuite];
  jshort selectedCompressionMethod = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithJavaIoInputStream_(buf);
  if (!LibOrgBouncycastleUtilArrays_containsWithShortArray_withShort_(self->offeredCompressionMethods_, selectedCompressionMethod)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySelectedCompressionMethodWithShort:selectedCompressionMethod];
  self->serverExtensions_ = LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(buf);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->extendedMasterSecret_ = (!LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_(tlsClientContext_) && LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasExtendedMasterSecretExtensionWithJavaUtilHashtable_(serverExtensions_));
  if (![((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) isExtendedMasterSecret] && (resumedSession_ || [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) requiresExtendedMasterSecret])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  if (self->serverExtensions_ != nil) {
    id<JavaUtilEnumeration> e = [self->serverExtensions_ keys];
    while ([((id<JavaUtilEnumeration>) nil_chk(e)) hasMoreElements]) {
      JavaLangInteger *extType = (JavaLangInteger *) cast_chk([e nextElement], [JavaLangInteger class]);
      if ([((JavaLangInteger *) nil_chk(extType)) isEqual:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo)]) {
        continue;
      }
      if (nil == LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(self->clientExtensions_, extType)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unsupported_extension);
      }
      if (self->resumedSession_) {
      }
    }
  }
  {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(self->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    if (renegExtData != nil) {
      self->secure_renegotiation_ = true;
      if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(renegExtData, LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES)))) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
      }
    }
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySecureRenegotiationWithBoolean:self->secure_renegotiation_];
  JavaUtilHashtable *sessionClientExtensions = clientExtensions_;
  JavaUtilHashtable *sessionServerExtensions = serverExtensions_;
  if (self->resumedSession_) {
    if (selectedCipherSuite != [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getCipherSuite] || selectedCompressionMethod != [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getCompressionAlgorithm]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    sessionClientExtensions = nil;
    sessionServerExtensions = [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) readServerExtensions];
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->cipherSuite_ = selectedCipherSuite;
  self->securityParameters_->compressionAlgorithm_ = selectedCompressionMethod;
  if (sessionServerExtensions != nil && ![sessionServerExtensions isEmpty]) {
    {
      jboolean serverSentEncryptThenMAC = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(sessionServerExtensions);
      if (serverSentEncryptThenMAC && !LibOrgBouncycastleCryptoTlsTlsUtils_isBlockCipherSuiteWithInt_(selectedCipherSuite)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
      }
      ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->encryptThenMAC_ = serverSentEncryptThenMAC;
    }
    self->securityParameters_->maxFragmentLength_ = [self processMaxFragmentLengthExtensionWithJavaUtilHashtable:sessionClientExtensions withJavaUtilHashtable:sessionServerExtensions withShort:LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter];
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->truncatedHMac_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(sessionServerExtensions);
    self->allowCertificateStatus_ = (!self->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsExtensionsUtils, EXT_status_request), LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter));
    self->expectSessionTicket_ = (!self->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_SessionTicket), LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter));
  }
  if (sessionClientExtensions != nil) {
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) processServerExtensionsWithJavaUtilHashtable:sessionServerExtensions];
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->prfAlgorithm_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_([self getContext], [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getCipherSuite]);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->verifyDataLength_ = 12;
}

- (void)sendCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDigitallySigned:(LibOrgBouncycastleCryptoTlsDigitallySigned *)certificateVerify {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_certificate_verify);
  [((LibOrgBouncycastleCryptoTlsDigitallySigned *) nil_chk(certificateVerify)) encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendClientHelloMessage {
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:[((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientHelloRecordLayerVersion]];
  LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientVersion];
  if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(client_version)) isDTLS]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  [((LibOrgBouncycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  IOSByteArray *session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
  if (self->tlsSession_ != nil) {
    session_id = [self->tlsSession_ getSessionID];
    if (session_id == nil || session_id->size_ > 32) {
      session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  jboolean fallback = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) isFallback];
  self->offeredCipherSuites_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getCipherSuites];
  self->offeredCompressionMethods_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getCompressionMethods];
  if (((IOSByteArray *) nil_chk(session_id))->size_ > 0 && self->sessionParameters_ != nil) {
    if (![sessionParameters_ isExtendedMasterSecret] || !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(self->offeredCipherSuites_, [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(sessionParameters_)) getCipherSuite]) || !LibOrgBouncycastleUtilArrays_containsWithShortArray_withShort_(self->offeredCompressionMethods_, [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(sessionParameters_)) getCompressionAlgorithm])) {
      session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  self->clientExtensions_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_ensureExtensionsInitialisedWithJavaUtilHashtable_([((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientExtensions]);
  if (![client_version isSSL]) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addExtendedMasterSecretExtensionWithJavaUtilHashtable_(self->clientExtensions_);
  }
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_client_hello);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withJavaIoOutputStream_(client_version, message);
  [message writeWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getClientRandom]];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(session_id, message);
  {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(clientExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    jboolean noRenegExt = nil == renegExtData;
    jboolean noRenegSCSV = !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    if (noRenegExt && noRenegSCSV) {
      self->offeredCipherSuites_ = LibOrgBouncycastleUtilArrays_appendWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    }
    if (fallback && !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV)) {
      self->offeredCipherSuites_ = LibOrgBouncycastleUtilArrays_appendWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV);
    }
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16ArrayWithUint16LengthWithIntArray_withJavaIoOutputStream_(offeredCipherSuites_, message);
  }
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8ArrayWithUint8LengthWithShortArray_withJavaIoOutputStream_(offeredCompressionMethods_, message);
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(message, clientExtensions_);
  [message writeToRecordStream];
}

- (void)sendClientKeyExchangeMessage {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_client_key_exchange);
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) generateClientKeyExchangeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsContext;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsAbstractTlsContext;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsPeer;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 6, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 7, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 11, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 13, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoInputStream:withJavaIoOutputStream:withJavaSecuritySecureRandom:);
  methods[1].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[2].selector = @selector(connectWithLibOrgBouncycastleCryptoTlsTlsClient:);
  methods[3].selector = @selector(cleanupHandshake);
  methods[4].selector = @selector(getContext);
  methods[5].selector = @selector(getContextAdmin);
  methods[6].selector = @selector(getPeer);
  methods[7].selector = @selector(handleHandshakeMessageWithShort:withJavaIoByteArrayInputStream:);
  methods[8].selector = @selector(handleSupplementalDataWithJavaUtilVector:);
  methods[9].selector = @selector(receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:);
  methods[10].selector = @selector(receiveServerHelloMessageWithJavaIoByteArrayInputStream:);
  methods[11].selector = @selector(sendCertificateVerifyMessageWithLibOrgBouncycastleCryptoTlsDigitallySigned:);
  methods[12].selector = @selector(sendClientHelloMessage);
  methods[13].selector = @selector(sendClientKeyExchangeMessage);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tlsClient_", "LLibOrgBouncycastleCryptoTlsTlsClient;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "tlsClientContext_", "LLibOrgBouncycastleCryptoTlsTlsClientContextImpl;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "selectedSessionID_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "keyExchange_", "LLibOrgBouncycastleCryptoTlsTlsKeyExchange;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "authentication_", "LLibOrgBouncycastleCryptoTlsTlsAuthentication;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "certificateStatus_", "LLibOrgBouncycastleCryptoTlsCertificateStatus;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "certificateRequest_", "LLibOrgBouncycastleCryptoTlsCertificateRequest;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoInputStream;LJavaIoOutputStream;LJavaSecuritySecureRandom;", "LJavaSecuritySecureRandom;", "connect", "LLibOrgBouncycastleCryptoTlsTlsClient;", "LJavaIoIOException;", "handleHandshakeMessage", "SLJavaIoByteArrayInputStream;", "handleSupplementalData", "LJavaUtilVector;", "receiveNewSessionTicketMessage", "LJavaIoByteArrayInputStream;", "receiveServerHelloMessage", "sendCertificateVerifyMessage", "LLibOrgBouncycastleCryptoTlsDigitallySigned;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsClientProtocol = { "TlsClientProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 14, 7, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsClientProtocol;
}

@end

void LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsClientProtocol *self, JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  self->tlsClient_ = nil;
  self->tlsClientContext_ = nil;
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

LibOrgBouncycastleCryptoTlsTlsClientProtocol *new_LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsClientProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

LibOrgBouncycastleCryptoTlsTlsClientProtocol *create_LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsClientProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

void LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsClientProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  self->tlsClient_ = nil;
  self->tlsClientContext_ = nil;
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

LibOrgBouncycastleCryptoTlsTlsClientProtocol *new_LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

LibOrgBouncycastleCryptoTlsTlsClientProtocol *create_LibOrgBouncycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsClientProtocol)

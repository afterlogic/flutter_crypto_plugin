//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/DTLSClientProtocol.java
//

#include "AlertDescription.h"
#include "Arrays.h"
#include "Certificate.h"
#include "CertificateRequest.h"
#include "CertificateStatus.h"
#include "CipherSuite.h"
#include "CompressionMethod.h"
#include "ConnectionEnd.h"
#include "ContentType.h"
#include "DTLSClientProtocol.h"
#include "DTLSProtocol.h"
#include "DTLSRecordLayer.h"
#include "DTLSReliableHandshake.h"
#include "DTLSTransport.h"
#include "DatagramTransport.h"
#include "DigitallySigned.h"
#include "ExporterLabel.h"
#include "HandshakeType.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "NewSessionTicket.h"
#include "ProtocolVersion.h"
#include "RandomGenerator.h"
#include "SecurityParameters.h"
#include "SessionParameters.h"
#include "SignatureAndHashAlgorithm.h"
#include "TlsAuthentication.h"
#include "TlsCipher.h"
#include "TlsClient.h"
#include "TlsClientContextImpl.h"
#include "TlsCredentials.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsHandshakeHash.h"
#include "TlsKeyExchange.h"
#include "TlsProtocol.h"
#include "TlsSession.h"
#include "TlsSessionImpl.h"
#include "TlsSignerCredentials.h"
#include "TlsUtils.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/security/SecureRandom.h"
#include "java/util/Enumeration.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@implementation LibOrgBouncycastleCryptoTlsDTLSClientProtocol

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsDTLSClientProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (LibOrgBouncycastleCryptoTlsDTLSTransport *)connectWithLibOrgBouncycastleCryptoTlsTlsClient:(id<LibOrgBouncycastleCryptoTlsTlsClient>)client
                                             withLibOrgBouncycastleCryptoTlsDatagramTransport:(id<LibOrgBouncycastleCryptoTlsDatagramTransport>)transport {
  if (client == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'client' cannot be null");
  }
  if (transport == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'transport' cannot be null");
  }
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = new_LibOrgBouncycastleCryptoTlsSecurityParameters_init();
  securityParameters->entity_ = LibOrgBouncycastleCryptoTlsConnectionEnd_client;
  LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *state = new_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState_init();
  state->client_ = client;
  state->clientContext_ = new_LibOrgBouncycastleCryptoTlsTlsClientContextImpl_initWithJavaSecuritySecureRandom_withLibOrgBouncycastleCryptoTlsSecurityParameters_(secureRandom_, securityParameters);
  securityParameters->clientRandom_ = LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_([client shouldUseGMTUnixTime], [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(state->clientContext_)) getNonceRandomGenerator]);
  [client init__WithLibOrgBouncycastleCryptoTlsTlsClientContext:state->clientContext_];
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer *recordLayer = new_LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(transport, state->clientContext_, client, LibOrgBouncycastleCryptoTlsContentType_handshake);
  id<LibOrgBouncycastleCryptoTlsTlsSession> sessionToResume = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getSessionToResume];
  if (sessionToResume != nil && [sessionToResume isResumable]) {
    LibOrgBouncycastleCryptoTlsSessionParameters *sessionParameters = [sessionToResume exportSessionParameters];
    if (sessionParameters != nil && [sessionParameters isExtendedMasterSecret]) {
      state->tlsSession_ = sessionToResume;
      state->sessionParameters_ = sessionParameters;
    }
  }
  @try {
    return [self clientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer];
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *fatalAlert) {
    [self abortClientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:[fatalAlert getAlertDescription]];
    @throw fatalAlert;
  }
  @catch (JavaIoIOException *e) {
    [self abortClientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error];
    @throw e;
  }
  @catch (JavaLangRuntimeException *e) {
    [self abortClientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:recordLayer withShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error];
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error, e);
  }
  @finally {
    [securityParameters clear];
  }
}

- (void)abortClientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                    withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)recordLayer
                                                                                         withShort:(jshort)alertDescription {
  [((LibOrgBouncycastleCryptoTlsDTLSRecordLayer *) nil_chk(recordLayer)) failWithShort:alertDescription];
  [self invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state];
}

- (LibOrgBouncycastleCryptoTlsDTLSTransport *)clientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                     withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)recordLayer {
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->clientContext_)) getSecurityParameters];
  LibOrgBouncycastleCryptoTlsDTLSReliableHandshake *handshake = new_LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_initWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsDTLSRecordLayer_(state->clientContext_, recordLayer);
  IOSByteArray *clientHelloBody = [self generateClientHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsTlsClient:state->client_];
  [((LibOrgBouncycastleCryptoTlsDTLSRecordLayer *) nil_chk(recordLayer)) setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:JreLoadStatic(LibOrgBouncycastleCryptoTlsProtocolVersion, DTLSv10)];
  [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_client_hello withByteArray:clientHelloBody];
  LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *serverMessage = [handshake receiveMessage];
  while ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_hello_verify_request) {
    LibOrgBouncycastleCryptoTlsProtocolVersion *recordLayerVersion = [recordLayer getReadVersion];
    LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(state->clientContext_)) getClientVersion];
    if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(recordLayerVersion)) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    [recordLayer setReadVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:nil];
    IOSByteArray *cookie = [self processHelloVerifyRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    IOSByteArray *patched = LibOrgBouncycastleCryptoTlsDTLSClientProtocol_patchClientHelloWithCookieWithByteArray_withByteArray_(clientHelloBody, cookie);
    [handshake resetHandshakeMessagesDigest];
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_client_hello withByteArray:patched];
    serverMessage = [handshake receiveMessage];
  }
  if ([serverMessage getType] == LibOrgBouncycastleCryptoTlsHandshakeType_server_hello) {
    LibOrgBouncycastleCryptoTlsProtocolVersion *recordLayerVersion = [recordLayer getReadVersion];
    [self reportServerVersionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsProtocolVersion:recordLayerVersion];
    [recordLayer setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:recordLayerVersion];
    [self processServerHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
  }
  else {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  [handshake notifyHelloComplete];
  LibOrgBouncycastleCryptoTlsDTLSProtocol_applyMaxFragmentLengthExtensionWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_withShort_(recordLayer, ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters))->maxFragmentLength_);
  if (state->resumedSession_) {
    securityParameters->masterSecret_ = LibOrgBouncycastleUtilArrays_cloneWithByteArray_([((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) getMasterSecret]);
    [recordLayer initPendingEpochWithLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getCipher]];
    IOSByteArray *expectedServerVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->clientContext_, LibOrgBouncycastleCryptoTlsExporterLabel_server_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->clientContext_, [handshake getHandshakeHash], nil));
    [self processFinishedWithByteArray:[handshake receiveMessageBodyWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished] withByteArray:expectedServerVerifyData];
    IOSByteArray *clientVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->clientContext_, LibOrgBouncycastleCryptoTlsExporterLabel_client_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->clientContext_, [handshake getHandshakeHash], nil));
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished withByteArray:clientVerifyData];
    [handshake finish];
    [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(state->clientContext_)) setResumableSessionWithLibOrgBouncycastleCryptoTlsTlsSession:state->tlsSession_];
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifyHandshakeComplete];
    return new_LibOrgBouncycastleCryptoTlsDTLSTransport_initWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_(recordLayer);
  }
  [self invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state];
  if (((IOSByteArray *) nil_chk(state->selectedSessionID_))->size_ > 0) {
    state->tlsSession_ = new_LibOrgBouncycastleCryptoTlsTlsSessionImpl_initWithByteArray_withLibOrgBouncycastleCryptoTlsSessionParameters_(state->selectedSessionID_, nil);
  }
  serverMessage = [handshake receiveMessage];
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data) {
    [self processServerSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    serverMessage = [handshake receiveMessage];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) processServerSupplementalDataWithJavaUtilVector:nil];
  }
  state->keyExchange_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getKeyExchange];
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:state->clientContext_];
  LibOrgBouncycastleCryptoTlsCertificate *serverCertificate = nil;
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_certificate) {
    serverCertificate = [self processServerCertificateWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    serverMessage = [handshake receiveMessage];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipServerCredentials];
  }
  if (serverCertificate == nil || [serverCertificate isEmpty]) {
    state->allowCertificateStatus_ = false;
  }
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_certificate_status) {
    [self processCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    serverMessage = [handshake receiveMessage];
  }
  else {
  }
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_server_key_exchange) {
    [self processServerKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    serverMessage = [handshake receiveMessage];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipServerKeyExchange];
  }
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_certificate_request) {
    [self processCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    LibOrgBouncycastleCryptoTlsTlsUtils_trackHashAlgorithmsWithLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withJavaUtilVector_([handshake getHandshakeHash], [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(state->certificateRequest_)) getSupportedSignatureAlgorithms]);
    serverMessage = [handshake receiveMessage];
  }
  else {
  }
  if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_server_hello_done) {
    if (((IOSByteArray *) nil_chk([serverMessage getBody]))->size_ != 0) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
    }
  }
  else {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk([handshake getHandshakeHash])) sealHashAlgorithms];
  JavaUtilVector *clientSupplementalData = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getClientSupplementalData];
  if (clientSupplementalData != nil) {
    IOSByteArray *supplementalDataBody = LibOrgBouncycastleCryptoTlsDTLSProtocol_generateSupplementalDataWithJavaUtilVector_(clientSupplementalData);
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data withByteArray:supplementalDataBody];
  }
  if (state->certificateRequest_ != nil) {
    state->clientCredentials_ = [((id<LibOrgBouncycastleCryptoTlsTlsAuthentication>) nil_chk(state->authentication_)) getClientCredentialsWithLibOrgBouncycastleCryptoTlsCertificateRequest:state->certificateRequest_];
    LibOrgBouncycastleCryptoTlsCertificate *clientCertificate = nil;
    if (state->clientCredentials_ != nil) {
      clientCertificate = [state->clientCredentials_ getCertificate];
    }
    if (clientCertificate == nil) {
      clientCertificate = JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN);
    }
    IOSByteArray *certificateBody = LibOrgBouncycastleCryptoTlsDTLSProtocol_generateCertificateWithLibOrgBouncycastleCryptoTlsCertificate_(clientCertificate);
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate withByteArray:certificateBody];
  }
  if (state->clientCredentials_ != nil) {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) processClientCredentialsWithLibOrgBouncycastleCryptoTlsTlsCredentials:state->clientCredentials_];
  }
  else {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) skipClientCredentials];
  }
  IOSByteArray *clientKeyExchangeBody = [self generateClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state];
  [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_client_key_exchange withByteArray:clientKeyExchangeBody];
  id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash> prepareFinishHash = [handshake prepareToFinish];
  securityParameters->sessionHash_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->clientContext_, prepareFinishHash, nil);
  LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_(state->clientContext_, state->keyExchange_);
  [recordLayer initPendingEpochWithLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getCipher]];
  if (state->clientCredentials_ != nil && [LibOrgBouncycastleCryptoTlsTlsSignerCredentials_class_() isInstance:state->clientCredentials_]) {
    id<LibOrgBouncycastleCryptoTlsTlsSignerCredentials> signerCredentials = (id<LibOrgBouncycastleCryptoTlsTlsSignerCredentials>) cast_check(state->clientCredentials_, LibOrgBouncycastleCryptoTlsTlsSignerCredentials_class_());
    LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *signatureAndHashAlgorithm = LibOrgBouncycastleCryptoTlsTlsUtils_getSignatureAndHashAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsSignerCredentials_(state->clientContext_, signerCredentials);
    IOSByteArray *hash_;
    if (signatureAndHashAlgorithm == nil) {
      hash_ = [securityParameters getSessionHash];
    }
    else {
      hash_ = [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk(prepareFinishHash)) getFinalHashWithShort:[signatureAndHashAlgorithm getHash]];
    }
    IOSByteArray *signature = [signerCredentials generateCertificateSignatureWithByteArray:hash_];
    LibOrgBouncycastleCryptoTlsDigitallySigned *certificateVerify = new_LibOrgBouncycastleCryptoTlsDigitallySigned_initWithLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm_withByteArray_(signatureAndHashAlgorithm, signature);
    IOSByteArray *certificateVerifyBody = [self generateCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsDigitallySigned:certificateVerify];
    [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_certificate_verify withByteArray:certificateVerifyBody];
  }
  IOSByteArray *clientVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->clientContext_, LibOrgBouncycastleCryptoTlsExporterLabel_client_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->clientContext_, [handshake getHandshakeHash], nil));
  [handshake sendMessageWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished withByteArray:clientVerifyData];
  if (state->expectSessionTicket_) {
    serverMessage = [handshake receiveMessage];
    if ([((LibOrgBouncycastleCryptoTlsDTLSReliableHandshake_Message *) nil_chk(serverMessage)) getType] == LibOrgBouncycastleCryptoTlsHandshakeType_session_ticket) {
      [self processNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withByteArray:[serverMessage getBody]];
    }
    else {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
    }
  }
  IOSByteArray *expectedServerVerifyData = LibOrgBouncycastleCryptoTlsTlsUtils_calculateVerifyDataWithLibOrgBouncycastleCryptoTlsTlsContext_withNSString_withByteArray_(state->clientContext_, LibOrgBouncycastleCryptoTlsExporterLabel_server_finished, LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_(state->clientContext_, [handshake getHandshakeHash], nil));
  [self processFinishedWithByteArray:[handshake receiveMessageBodyWithShort:LibOrgBouncycastleCryptoTlsHandshakeType_finished] withByteArray:expectedServerVerifyData];
  [handshake finish];
  if (state->tlsSession_ != nil) {
    state->sessionParameters_ = [((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([((LibOrgBouncycastleCryptoTlsSessionParameters_Builder *) nil_chk([new_LibOrgBouncycastleCryptoTlsSessionParameters_Builder_init() setCipherSuiteWithInt:[securityParameters getCipherSuite]])) setCompressionAlgorithmWithShort:[securityParameters getCompressionAlgorithm]])) setExtendedMasterSecretWithBoolean:[securityParameters isExtendedMasterSecret]])) setMasterSecretWithByteArray:[securityParameters getMasterSecret]])) setPeerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:serverCertificate])) setPSKIdentityWithByteArray:[securityParameters getPSKIdentity]])) setSRPIdentityWithByteArray:[securityParameters getSRPIdentity]])) setServerExtensionsWithJavaUtilHashtable:state->serverExtensions_])) build];
    state->tlsSession_ = LibOrgBouncycastleCryptoTlsTlsUtils_importSessionWithByteArray_withLibOrgBouncycastleCryptoTlsSessionParameters_([((id<LibOrgBouncycastleCryptoTlsTlsSession>) nil_chk(state->tlsSession_)) getSessionID], state->sessionParameters_);
    [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(state->clientContext_)) setResumableSessionWithLibOrgBouncycastleCryptoTlsTlsSession:state->tlsSession_];
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifyHandshakeComplete];
  return new_LibOrgBouncycastleCryptoTlsDTLSTransport_initWithLibOrgBouncycastleCryptoTlsDTLSRecordLayer_(recordLayer);
}

- (IOSByteArray *)generateCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                   withLibOrgBouncycastleCryptoTlsDigitallySigned:(LibOrgBouncycastleCryptoTlsDigitallySigned *)certificateVerify {
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((LibOrgBouncycastleCryptoTlsDigitallySigned *) nil_chk(certificateVerify)) encodeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

- (IOSByteArray *)generateClientHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                   withLibOrgBouncycastleCryptoTlsTlsClient:(id<LibOrgBouncycastleCryptoTlsTlsClient>)client {
  LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(client)) getClientVersion];
  if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(client_version)) isDTLS]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  LibOrgBouncycastleCryptoTlsTlsClientContextImpl *context = ((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->clientContext_;
  [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(context)) setClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [context getSecurityParameters];
  IOSByteArray *session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
  if (state->tlsSession_ != nil) {
    session_id = [state->tlsSession_ getSessionID];
    if (session_id == nil || session_id->size_ > 32) {
      session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  jboolean fallback = [client isFallback];
  state->offeredCipherSuites_ = [client getCipherSuites];
  if (((IOSByteArray *) nil_chk(session_id))->size_ > 0 && state->sessionParameters_ != nil) {
    if (![state->sessionParameters_ isExtendedMasterSecret] || !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) getCipherSuite]) || LibOrgBouncycastleCryptoTlsCompressionMethod__null != [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) getCompressionAlgorithm]) {
      session_id = JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  state->clientExtensions_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_ensureExtensionsInitialisedWithJavaUtilHashtable_([client getClientExtensions]);
  LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addExtendedMasterSecretExtensionWithJavaUtilHashtable_(state->clientExtensions_);
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withJavaIoOutputStream_(client_version, buf);
  [buf writeWithByteArray:[((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters)) getClientRandom]];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(session_id, buf);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES), buf);
  {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(state->clientExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    jboolean noRenegExt = nil == renegExtData;
    jboolean noRenegSCSV = !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    if (noRenegExt && noRenegSCSV) {
      state->offeredCipherSuites_ = LibOrgBouncycastleUtilArrays_appendWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    }
    if (fallback && !LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV)) {
      state->offeredCipherSuites_ = LibOrgBouncycastleUtilArrays_appendWithIntArray_withInt_(state->offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV);
    }
    LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16ArrayWithUint16LengthWithIntArray_withJavaIoOutputStream_(state->offeredCipherSuites_, buf);
  }
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8ArrayWithUint8LengthWithShortArray_withJavaIoOutputStream_([IOSShortArray newArrayWithShorts:(jshort[]){ LibOrgBouncycastleCryptoTlsCompressionMethod__null } count:1], buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(buf, state->clientExtensions_);
  return [buf toByteArray];
}

- (IOSByteArray *)generateClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state {
  JavaIoByteArrayOutputStream *buf = new_JavaIoByteArrayOutputStream_init();
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->keyExchange_)) generateClientKeyExchangeWithJavaIoOutputStream:buf];
  return [buf toByteArray];
}

- (void)invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state {
  if (((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->sessionParameters_ != nil) {
    [state->sessionParameters_ clear];
    state->sessionParameters_ = nil;
  }
  if (state->tlsSession_ != nil) {
    [state->tlsSession_ invalidate];
    state->tlsSession_ = nil;
  }
}

- (void)processCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                          withByteArray:(IOSByteArray *)body {
  if (((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->authentication_ == nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  state->certificateRequest_ = LibOrgBouncycastleCryptoTlsCertificateRequest_parseWithLibOrgBouncycastleCryptoTlsTlsContext_withJavaIoInputStream_(state->clientContext_, buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(state->keyExchange_)) validateCertificateRequestWithLibOrgBouncycastleCryptoTlsCertificateRequest:state->certificateRequest_];
}

- (void)processCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                         withByteArray:(IOSByteArray *)body {
  if (!((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->allowCertificateStatus_) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  state->certificateStatus_ = LibOrgBouncycastleCryptoTlsCertificateStatus_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
}

- (IOSByteArray *)processHelloVerifyRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                                    withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsProtocolVersion *server_version = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
  IOSByteArray *cookie = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(server_version)) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:[((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->clientContext_)) getClientVersion]]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(JreLoadStatic(LibOrgBouncycastleCryptoTlsProtocolVersion, DTLSv12))) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version] && ((IOSByteArray *) nil_chk(cookie))->size_ > 32) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  return cookie;
}

- (void)processNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                        withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsNewSessionTicket *newSessionTicket = LibOrgBouncycastleCryptoTlsNewSessionTicket_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->client_)) notifyNewSessionTicketWithLibOrgBouncycastleCryptoTlsNewSessionTicket:newSessionTicket];
}

- (LibOrgBouncycastleCryptoTlsCertificate *)processServerCertificateWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                                                             withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  LibOrgBouncycastleCryptoTlsCertificate *serverCertificate = LibOrgBouncycastleCryptoTlsCertificate_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->keyExchange_)) processServerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:serverCertificate];
  state->authentication_ = [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) getAuthentication];
  [((id<LibOrgBouncycastleCryptoTlsTlsAuthentication>) nil_chk(state->authentication_)) notifyServerCertificateWithLibOrgBouncycastleCryptoTlsCertificate:serverCertificate];
  return serverCertificate;
}

- (void)processServerHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                   withByteArray:(IOSByteArray *)body {
  LibOrgBouncycastleCryptoTlsSecurityParameters *securityParameters = [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->clientContext_)) getSecurityParameters];
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  {
    LibOrgBouncycastleCryptoTlsProtocolVersion *server_version = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
    [self reportServerVersionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:state withLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters))->serverRandom_ = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(32, buf);
  state->selectedSessionID_ = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  if (((IOSByteArray *) nil_chk(state->selectedSessionID_))->size_ > 32) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifySessionIDWithByteArray:state->selectedSessionID_];
  state->resumedSession_ = (((IOSByteArray *) nil_chk(state->selectedSessionID_))->size_ > 0 && state->tlsSession_ != nil && LibOrgBouncycastleUtilArrays_areEqualWithByteArray_withByteArray_(state->selectedSessionID_, [state->tlsSession_ getSessionID]));
  jint selectedCipherSuite = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
  if (!LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(state->offeredCipherSuites_, selectedCipherSuite) || selectedCipherSuite == LibOrgBouncycastleCryptoTlsCipherSuite_TLS_NULL_WITH_NULL_NULL || LibOrgBouncycastleCryptoTlsCipherSuite_isSCSVWithInt_(selectedCipherSuite) || !LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withLibOrgBouncycastleCryptoTlsProtocolVersion_(selectedCipherSuite, [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(state->clientContext_)) getServerVersion])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  LibOrgBouncycastleCryptoTlsDTLSProtocol_validateSelectedCipherSuiteWithInt_withShort_(selectedCipherSuite, LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifySelectedCipherSuiteWithInt:selectedCipherSuite];
  jshort selectedCompressionMethod = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithJavaIoInputStream_(buf);
  if (LibOrgBouncycastleCryptoTlsCompressionMethod__null != selectedCompressionMethod) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifySelectedCompressionMethodWithShort:selectedCompressionMethod];
  state->serverExtensions_ = LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(buf);
  securityParameters->extendedMasterSecret_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasExtendedMasterSecretExtensionWithJavaUtilHashtable_(state->serverExtensions_);
  if (![securityParameters isExtendedMasterSecret] && (state->resumedSession_ || [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) requiresExtendedMasterSecret])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  if (state->serverExtensions_ != nil) {
    id<JavaUtilEnumeration> e = [state->serverExtensions_ keys];
    while ([((id<JavaUtilEnumeration>) nil_chk(e)) hasMoreElements]) {
      JavaLangInteger *extType = (JavaLangInteger *) cast_chk([e nextElement], [JavaLangInteger class]);
      if ([((JavaLangInteger *) nil_chk(extType)) isEqual:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo)]) {
        continue;
      }
      if (nil == LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(state->clientExtensions_, extType)) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unsupported_extension);
      }
      if (state->resumedSession_) {
      }
    }
  }
  {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(state->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    if (renegExtData != nil) {
      state->secure_renegotiation_ = true;
      if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(renegExtData, LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES)))) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
      }
    }
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifySecureRenegotiationWithBoolean:state->secure_renegotiation_];
  JavaUtilHashtable *sessionClientExtensions = state->clientExtensions_;
  JavaUtilHashtable *sessionServerExtensions = state->serverExtensions_;
  if (state->resumedSession_) {
    if (selectedCipherSuite != [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) getCipherSuite] || selectedCompressionMethod != [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) getCompressionAlgorithm]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    sessionClientExtensions = nil;
    sessionServerExtensions = [((LibOrgBouncycastleCryptoTlsSessionParameters *) nil_chk(state->sessionParameters_)) readServerExtensions];
  }
  securityParameters->cipherSuite_ = selectedCipherSuite;
  securityParameters->compressionAlgorithm_ = selectedCompressionMethod;
  if (sessionServerExtensions != nil && ![sessionServerExtensions isEmpty]) {
    {
      jboolean serverSentEncryptThenMAC = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(sessionServerExtensions);
      if (serverSentEncryptThenMAC && !LibOrgBouncycastleCryptoTlsTlsUtils_isBlockCipherSuiteWithInt_([securityParameters getCipherSuite])) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
      }
      securityParameters->encryptThenMAC_ = serverSentEncryptThenMAC;
    }
    securityParameters->maxFragmentLength_ = LibOrgBouncycastleCryptoTlsDTLSProtocol_evaluateMaxFragmentLengthExtensionWithBoolean_withJavaUtilHashtable_withJavaUtilHashtable_withShort_(state->resumedSession_, sessionClientExtensions, sessionServerExtensions, LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
    securityParameters->truncatedHMac_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(sessionServerExtensions);
    state->allowCertificateStatus_ = (!state->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsExtensionsUtils, EXT_status_request), LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter));
    state->expectSessionTicket_ = (!state->resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_SessionTicket), LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter));
  }
  if (sessionClientExtensions != nil) {
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) processServerExtensionsWithJavaUtilHashtable:sessionServerExtensions];
  }
  securityParameters->prfAlgorithm_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_(state->clientContext_, [securityParameters getCipherSuite]);
  securityParameters->verifyDataLength_ = 12;
}

- (void)processServerKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                         withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->keyExchange_)) processServerKeyExchangeWithJavaIoInputStream:buf];
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
}

- (void)processServerSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                                                              withByteArray:(IOSByteArray *)body {
  JavaIoByteArrayInputStream *buf = new_JavaIoByteArrayInputStream_initWithByteArray_(body);
  JavaUtilVector *serverSupplementalData = LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(buf);
  [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->client_)) processServerSupplementalDataWithJavaUtilVector:serverSupplementalData];
}

- (void)reportServerVersionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *)state
                                                   withLibOrgBouncycastleCryptoTlsProtocolVersion:(LibOrgBouncycastleCryptoTlsProtocolVersion *)server_version {
  LibOrgBouncycastleCryptoTlsTlsClientContextImpl *clientContext = ((LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *) nil_chk(state))->clientContext_;
  LibOrgBouncycastleCryptoTlsProtocolVersion *currentServerVersion = [((LibOrgBouncycastleCryptoTlsTlsClientContextImpl *) nil_chk(clientContext)) getServerVersion];
  if (nil == currentServerVersion) {
    [clientContext setServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    [((id<LibOrgBouncycastleCryptoTlsTlsClient>) nil_chk(state->client_)) notifyServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
  }
  else if (![currentServerVersion equalsWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
}

+ (IOSByteArray *)patchClientHelloWithCookieWithByteArray:(IOSByteArray *)clientHelloBody
                                            withByteArray:(IOSByteArray *)cookie {
  return LibOrgBouncycastleCryptoTlsDTLSClientProtocol_patchClientHelloWithCookieWithByteArray_withByteArray_(clientHelloBody, cookie);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsDTLSTransport;", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 4, 5, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsDTLSTransport;", 0x4, 6, 7, 3, -1, -1, -1 },
    { NULL, "[B", 0x4, 8, 9, 3, -1, -1, -1 },
    { NULL, "[B", 0x4, 10, 11, 3, -1, -1, -1 },
    { NULL, "[B", 0x4, 12, 13, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 14, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 15, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 17, 16, 3, -1, -1, -1 },
    { NULL, "[B", 0x4, 18, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 19, 16, 3, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsCertificate;", 0x4, 20, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 21, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 22, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 23, 16, 3, -1, -1, -1 },
    { NULL, "V", 0x4, 24, 25, 3, -1, -1, -1 },
    { NULL, "[B", 0xc, 26, 27, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[1].selector = @selector(connectWithLibOrgBouncycastleCryptoTlsTlsClient:withLibOrgBouncycastleCryptoTlsDatagramTransport:);
  methods[2].selector = @selector(abortClientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:withShort:);
  methods[3].selector = @selector(clientHandshakeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withLibOrgBouncycastleCryptoTlsDTLSRecordLayer:);
  methods[4].selector = @selector(generateCertificateVerifyWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withLibOrgBouncycastleCryptoTlsDigitallySigned:);
  methods[5].selector = @selector(generateClientHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withLibOrgBouncycastleCryptoTlsTlsClient:);
  methods[6].selector = @selector(generateClientKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:);
  methods[7].selector = @selector(invalidateSessionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:);
  methods[8].selector = @selector(processCertificateRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[9].selector = @selector(processCertificateStatusWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[10].selector = @selector(processHelloVerifyRequestWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[11].selector = @selector(processNewSessionTicketWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[12].selector = @selector(processServerCertificateWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[13].selector = @selector(processServerHelloWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[14].selector = @selector(processServerKeyExchangeWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[15].selector = @selector(processServerSupplementalDataWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withByteArray:);
  methods[16].selector = @selector(reportServerVersionWithLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState:withLibOrgBouncycastleCryptoTlsProtocolVersion:);
  methods[17].selector = @selector(patchClientHelloWithCookieWithByteArray:withByteArray:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaSecuritySecureRandom;", "connect", "LLibOrgBouncycastleCryptoTlsTlsClient;LLibOrgBouncycastleCryptoTlsDatagramTransport;", "LJavaIoIOException;", "abortClientHandshake", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;LLibOrgBouncycastleCryptoTlsDTLSRecordLayer;S", "clientHandshake", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;LLibOrgBouncycastleCryptoTlsDTLSRecordLayer;", "generateCertificateVerify", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;LLibOrgBouncycastleCryptoTlsDigitallySigned;", "generateClientHello", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;LLibOrgBouncycastleCryptoTlsTlsClient;", "generateClientKeyExchange", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;", "invalidateSession", "processCertificateRequest", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;[B", "processCertificateStatus", "processHelloVerifyRequest", "processNewSessionTicket", "processServerCertificate", "processServerHello", "processServerKeyExchange", "processServerSupplementalData", "reportServerVersion", "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;LLibOrgBouncycastleCryptoTlsProtocolVersion;", "patchClientHelloWithCookie", "[B[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSClientProtocol = { "DTLSClientProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, NULL, 7, 0x1, 18, 0, -1, 13, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSClientProtocol;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSClientProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsDTLSClientProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsDTLSProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
}

LibOrgBouncycastleCryptoTlsDTLSClientProtocol *new_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsDTLSClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

LibOrgBouncycastleCryptoTlsDTLSClientProtocol *create_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsDTLSClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

IOSByteArray *LibOrgBouncycastleCryptoTlsDTLSClientProtocol_patchClientHelloWithCookieWithByteArray_withByteArray_(IOSByteArray *clientHelloBody, IOSByteArray *cookie) {
  LibOrgBouncycastleCryptoTlsDTLSClientProtocol_initialize();
  jint sessionIDPos = 34;
  jint sessionIDLength = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(clientHelloBody, sessionIDPos);
  jint cookieLengthPos = sessionIDPos + 1 + sessionIDLength;
  jint cookiePos = cookieLengthPos + 1;
  IOSByteArray *patched = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(clientHelloBody))->size_ + ((IOSByteArray *) nil_chk(cookie))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(clientHelloBody, 0, patched, 0, cookieLengthPos);
  LibOrgBouncycastleCryptoTlsTlsUtils_checkUint8WithInt_(cookie->size_);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithInt_withByteArray_withInt_(cookie->size_, patched, cookieLengthPos);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(cookie, 0, patched, cookiePos, cookie->size_);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(clientHelloBody, cookiePos, patched, cookiePos + cookie->size_, clientHelloBody->size_ - cookiePos);
  return patched;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSClientProtocol)

@implementation LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "client_", "LLibOrgBouncycastleCryptoTlsTlsClient;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientContext_", "LLibOrgBouncycastleCryptoTlsTlsClientContextImpl;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tlsSession_", "LLibOrgBouncycastleCryptoTlsTlsSession;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sessionParameters_", "LLibOrgBouncycastleCryptoTlsSessionParameters;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sessionParametersBuilder_", "LLibOrgBouncycastleCryptoTlsSessionParameters_Builder;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "offeredCipherSuites_", "[I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "serverExtensions_", "LJavaUtilHashtable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "selectedSessionID_", "[B", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "resumedSession_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "secure_renegotiation_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "allowCertificateStatus_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "expectSessionTicket_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "keyExchange_", "LLibOrgBouncycastleCryptoTlsTlsKeyExchange;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "authentication_", "LLibOrgBouncycastleCryptoTlsTlsAuthentication;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "certificateStatus_", "LLibOrgBouncycastleCryptoTlsCertificateStatus;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "certificateRequest_", "LLibOrgBouncycastleCryptoTlsCertificateRequest;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "clientCredentials_", "LLibOrgBouncycastleCryptoTlsTlsCredentials;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsDTLSClientProtocol;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState = { "ClientHandshakeState", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0xc, 1, 18, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState_init(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *self) {
  NSObject_init(self);
  self->client_ = nil;
  self->clientContext_ = nil;
  self->tlsSession_ = nil;
  self->sessionParameters_ = nil;
  self->sessionParametersBuilder_ = nil;
  self->offeredCipherSuites_ = nil;
  self->clientExtensions_ = nil;
  self->serverExtensions_ = nil;
  self->selectedSessionID_ = nil;
  self->resumedSession_ = false;
  self->secure_renegotiation_ = false;
  self->allowCertificateStatus_ = false;
  self->expectSessionTicket_ = false;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
  self->clientCredentials_ = nil;
}

LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *new_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState, init)
}

LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState *create_LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSClientProtocol_ClientHandshakeState)

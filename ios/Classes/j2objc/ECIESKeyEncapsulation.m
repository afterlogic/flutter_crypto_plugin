//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/kems/ECIESKeyEncapsulation.java
//

#include "Arrays.h"
#include "BigIntegers.h"
#include "CipherParameters.h"
#include "DerivationFunction.h"
#include "ECCurve.h"
#include "ECDomainParameters.h"
#include "ECFieldElement.h"
#include "ECIESKeyEncapsulation.h"
#include "ECKeyParameters.h"
#include "ECMultiplier.h"
#include "ECPoint.h"
#include "ECPrivateKeyParameters.h"
#include "ECPublicKeyParameters.h"
#include "FixedPointCombMultiplier.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KDFParameters.h"
#include "KeyParameter.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/security/SecureRandom.h"

@interface LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation () {
 @public
  id<LibOrgBouncycastleCryptoDerivationFunction> kdf_;
  JavaSecuritySecureRandom *rnd_;
  LibOrgBouncycastleCryptoParamsECKeyParameters *key_;
  jboolean CofactorMode_;
  jboolean OldCofactorMode_;
  jboolean SingleHashMode_;
}

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, kdf_, id<LibOrgBouncycastleCryptoDerivationFunction>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, rnd_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, key_, LibOrgBouncycastleCryptoParamsECKeyParameters *)

inline JavaMathBigInteger *LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_get_ONE(void);
static JavaMathBigInteger *LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, ONE, JavaMathBigInteger *)

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation)

@implementation LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation

- (instancetype)initWithLibOrgBouncycastleCryptoDerivationFunction:(id<LibOrgBouncycastleCryptoDerivationFunction>)kdf
                                      withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)rnd {
  LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_(self, kdf, rnd);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoDerivationFunction:(id<LibOrgBouncycastleCryptoDerivationFunction>)kdf
                                      withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)rnd
                                                       withBoolean:(jboolean)cofactorMode
                                                       withBoolean:(jboolean)oldCofactorMode
                                                       withBoolean:(jboolean)singleHashMode {
  LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_(self, kdf, rnd, cofactorMode, oldCofactorMode, singleHashMode);
  return self;
}

- (void)init__WithLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)key {
  if (!([key isKindOfClass:[LibOrgBouncycastleCryptoParamsECKeyParameters class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"EC key required");
  }
  else {
    self->key_ = (LibOrgBouncycastleCryptoParamsECKeyParameters *) cast_chk(key, [LibOrgBouncycastleCryptoParamsECKeyParameters class]);
  }
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)encryptWithByteArray:(IOSByteArray *)outArg
                                                             withInt:(jint)outOff
                                                             withInt:(jint)keyLen {
  if (!([key_ isKindOfClass:[LibOrgBouncycastleCryptoParamsECPublicKeyParameters class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Public key required for encryption");
  }
  LibOrgBouncycastleCryptoParamsECPublicKeyParameters *ecPubKey = (LibOrgBouncycastleCryptoParamsECPublicKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsECPublicKeyParameters class]);
  LibOrgBouncycastleCryptoParamsECDomainParameters *ecParams = [((LibOrgBouncycastleCryptoParamsECPublicKeyParameters *) nil_chk(ecPubKey)) getParameters];
  LibOrgBouncycastleMathEcECCurve *curve = [((LibOrgBouncycastleCryptoParamsECDomainParameters *) nil_chk(ecParams)) getCurve];
  JavaMathBigInteger *n = [ecParams getN];
  JavaMathBigInteger *h = [ecParams getH];
  JavaMathBigInteger *r = LibOrgBouncycastleUtilBigIntegers_createRandomInRangeWithJavaMathBigInteger_withJavaMathBigInteger_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_ONE, n, rnd_);
  JavaMathBigInteger *rPrime = OldCofactorMode_ ? [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(r)) multiplyWithJavaMathBigInteger:h])) modWithJavaMathBigInteger:n] : r;
  id<LibOrgBouncycastleMathEcECMultiplier> basePointMultiplier = [self createBasePointMultiplier];
  IOSObjectArray *ghTilde = [IOSObjectArray newArrayWithObjects:(id[]){ [((id<LibOrgBouncycastleMathEcECMultiplier>) nil_chk(basePointMultiplier)) multiplyWithLibOrgBouncycastleMathEcECPoint:[ecParams getG] withJavaMathBigInteger:r], [((LibOrgBouncycastleMathEcECPoint *) nil_chk([ecPubKey getQ])) multiplyWithJavaMathBigInteger:rPrime] } count:2 type:LibOrgBouncycastleMathEcECPoint_class_()];
  [((LibOrgBouncycastleMathEcECCurve *) nil_chk(curve)) normalizeAllWithLibOrgBouncycastleMathEcECPointArray:ghTilde];
  LibOrgBouncycastleMathEcECPoint *gTilde = IOSObjectArray_Get(ghTilde, 0);
  LibOrgBouncycastleMathEcECPoint *hTilde = IOSObjectArray_Get(ghTilde, 1);
  IOSByteArray *C = [((LibOrgBouncycastleMathEcECPoint *) nil_chk(gTilde)) getEncodedWithBoolean:false];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(C, 0, outArg, outOff, ((IOSByteArray *) nil_chk(C))->size_);
  IOSByteArray *PEH = [((LibOrgBouncycastleMathEcECFieldElement *) nil_chk([((LibOrgBouncycastleMathEcECPoint *) nil_chk(hTilde)) getAffineXCoord])) getEncoded];
  return [self deriveKeyWithInt:keyLen withByteArray:C withByteArray:PEH];
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)encryptWithByteArray:(IOSByteArray *)outArg
                                                             withInt:(jint)keyLen {
  return [self encryptWithByteArray:outArg withInt:0 withInt:keyLen];
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)decryptWithByteArray:(IOSByteArray *)inArg
                                                             withInt:(jint)inOff
                                                             withInt:(jint)inLen
                                                             withInt:(jint)keyLen {
  if (!([key_ isKindOfClass:[LibOrgBouncycastleCryptoParamsECPrivateKeyParameters class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Private key required for encryption");
  }
  LibOrgBouncycastleCryptoParamsECPrivateKeyParameters *ecPrivKey = (LibOrgBouncycastleCryptoParamsECPrivateKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsECPrivateKeyParameters class]);
  LibOrgBouncycastleCryptoParamsECDomainParameters *ecParams = [((LibOrgBouncycastleCryptoParamsECPrivateKeyParameters *) nil_chk(ecPrivKey)) getParameters];
  LibOrgBouncycastleMathEcECCurve *curve = [((LibOrgBouncycastleCryptoParamsECDomainParameters *) nil_chk(ecParams)) getCurve];
  JavaMathBigInteger *n = [ecParams getN];
  JavaMathBigInteger *h = [ecParams getH];
  IOSByteArray *C = [IOSByteArray newArrayWithLength:inLen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff, C, 0, inLen);
  LibOrgBouncycastleMathEcECPoint *gTilde = [((LibOrgBouncycastleMathEcECCurve *) nil_chk(curve)) decodePointWithByteArray:C];
  LibOrgBouncycastleMathEcECPoint *gHat = gTilde;
  if ((CofactorMode_) || (OldCofactorMode_)) {
    gHat = [((LibOrgBouncycastleMathEcECPoint *) nil_chk(gHat)) multiplyWithJavaMathBigInteger:h];
  }
  JavaMathBigInteger *xHat = [ecPrivKey getD];
  if (CofactorMode_) {
    xHat = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(xHat)) multiplyWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk(h)) modInverseWithJavaMathBigInteger:n]])) modWithJavaMathBigInteger:n];
  }
  LibOrgBouncycastleMathEcECPoint *hTilde = [((LibOrgBouncycastleMathEcECPoint *) nil_chk([((LibOrgBouncycastleMathEcECPoint *) nil_chk(gHat)) multiplyWithJavaMathBigInteger:xHat])) normalize];
  IOSByteArray *PEH = [((LibOrgBouncycastleMathEcECFieldElement *) nil_chk([((LibOrgBouncycastleMathEcECPoint *) nil_chk(hTilde)) getAffineXCoord])) getEncoded];
  return [self deriveKeyWithInt:keyLen withByteArray:C withByteArray:PEH];
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)decryptWithByteArray:(IOSByteArray *)inArg
                                                             withInt:(jint)keyLen {
  return [self decryptWithByteArray:inArg withInt:0 withInt:((IOSByteArray *) nil_chk(inArg))->size_ withInt:keyLen];
}

- (id<LibOrgBouncycastleMathEcECMultiplier>)createBasePointMultiplier {
  return new_LibOrgBouncycastleMathEcFixedPointCombMultiplier_init();
}

- (LibOrgBouncycastleCryptoParamsKeyParameter *)deriveKeyWithInt:(jint)keyLen
                                                   withByteArray:(IOSByteArray *)C
                                                   withByteArray:(IOSByteArray *)PEH {
  IOSByteArray *kdfInput = PEH;
  if (!SingleHashMode_) {
    kdfInput = LibOrgBouncycastleUtilArrays_concatenateWithByteArray_withByteArray_(C, PEH);
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(PEH, (jbyte) 0);
  }
  @try {
    [((id<LibOrgBouncycastleCryptoDerivationFunction>) nil_chk(kdf_)) init__WithLibOrgBouncycastleCryptoDerivationParameters:new_LibOrgBouncycastleCryptoParamsKDFParameters_initWithByteArray_withByteArray_(kdfInput, nil)];
    IOSByteArray *K = [IOSByteArray newArrayWithLength:keyLen];
    [((id<LibOrgBouncycastleCryptoDerivationFunction>) nil_chk(kdf_)) generateBytesWithByteArray:K withInt:0 withInt:K->size_];
    return new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_(K);
  }
  @finally {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(kdfInput, (jbyte) 0);
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoCipherParameters;", 0x1, 5, 6, 4, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoCipherParameters;", 0x1, 5, 7, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoCipherParameters;", 0x1, 8, 9, 4, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoCipherParameters;", 0x1, 8, 7, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleMathEcECMultiplier;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoParamsKeyParameter;", 0x4, 10, 11, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoDerivationFunction:withJavaSecuritySecureRandom:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoDerivationFunction:withJavaSecuritySecureRandom:withBoolean:withBoolean:withBoolean:);
  methods[2].selector = @selector(init__WithLibOrgBouncycastleCryptoCipherParameters:);
  methods[3].selector = @selector(encryptWithByteArray:withInt:withInt:);
  methods[4].selector = @selector(encryptWithByteArray:withInt:);
  methods[5].selector = @selector(decryptWithByteArray:withInt:withInt:withInt:);
  methods[6].selector = @selector(decryptWithByteArray:withInt:);
  methods[7].selector = @selector(createBasePointMultiplier);
  methods[8].selector = @selector(deriveKeyWithInt:withByteArray:withByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ONE", "LJavaMathBigInteger;", .constantValue.asLong = 0, 0x1a, -1, 12, -1, -1 },
    { "kdf_", "LLibOrgBouncycastleCryptoDerivationFunction;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rnd_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "key_", "LLibOrgBouncycastleCryptoParamsECKeyParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "CofactorMode_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "OldCofactorMode_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "SingleHashMode_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoDerivationFunction;LJavaSecuritySecureRandom;", "LLibOrgBouncycastleCryptoDerivationFunction;LJavaSecuritySecureRandom;ZZZ", "init", "LLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "encrypt", "[BII", "[BI", "decrypt", "[BIII", "deriveKey", "I[B[B", &LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_ONE };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation = { "ECIESKeyEncapsulation", "lib.org.bouncycastle.crypto.kems", ptrTable, methods, fields, 7, 0x1, 9, 7, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation class]) {
    LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_ONE = JavaMathBigInteger_valueOfWithLong_(1);
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation)
  }
}

@end

void LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *self, id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd) {
  NSObject_init(self);
  self->kdf_ = kdf;
  self->rnd_ = rnd;
  self->CofactorMode_ = false;
  self->OldCofactorMode_ = false;
  self->SingleHashMode_ = false;
}

LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *new_LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_(id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_, kdf, rnd)
}

LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *create_LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_(id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_, kdf, rnd)
}

void LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *self, id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd, jboolean cofactorMode, jboolean oldCofactorMode, jboolean singleHashMode) {
  NSObject_init(self);
  self->kdf_ = kdf;
  self->rnd_ = rnd;
  self->CofactorMode_ = cofactorMode;
  if (cofactorMode) {
    self->OldCofactorMode_ = false;
  }
  else {
    self->OldCofactorMode_ = oldCofactorMode;
  }
  self->SingleHashMode_ = singleHashMode;
}

LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *new_LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_(id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd, jboolean cofactorMode, jboolean oldCofactorMode, jboolean singleHashMode) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_, kdf, rnd, cofactorMode, oldCofactorMode, singleHashMode)
}

LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation *create_LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation_initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_(id<LibOrgBouncycastleCryptoDerivationFunction> kdf, JavaSecuritySecureRandom *rnd, jboolean cofactorMode, jboolean oldCofactorMode, jboolean singleHashMode) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation, initWithLibOrgBouncycastleCryptoDerivationFunction_withJavaSecuritySecureRandom_withBoolean_withBoolean_withBoolean_, kdf, rnd, cofactorMode, oldCofactorMode, singleHashMode)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoKemsECIESKeyEncapsulation)

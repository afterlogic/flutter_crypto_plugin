//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/util/MultiMap.java
//

#include "J2ObjC_source.h"
#include "MultiMap.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

@interface LibComAfterlogicPgpUtilMultiMap () {
 @public
  id<JavaUtilMap> map_;
}

@end

J2OBJC_FIELD_SETTER(LibComAfterlogicPgpUtilMultiMap, map_, id<JavaUtilMap>)

@implementation LibComAfterlogicPgpUtilMultiMap

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibComAfterlogicPgpUtilMultiMap_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithLibComAfterlogicPgpUtilMultiMap:(LibComAfterlogicPgpUtilMultiMap *)other {
  LibComAfterlogicPgpUtilMultiMap_initWithLibComAfterlogicPgpUtilMultiMap_(self, other);
  return self;
}

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)content {
  LibComAfterlogicPgpUtilMultiMap_initWithJavaUtilMap_(self, content);
  return self;
}

- (jint)size {
  return [((id<JavaUtilMap>) nil_chk(map_)) size];
}

- (jboolean)isEmpty {
  return [((id<JavaUtilMap>) nil_chk(map_)) isEmpty];
}

- (jboolean)containsKeyWithId:(id)o {
  return [((id<JavaUtilMap>) nil_chk(map_)) containsKeyWithId:o];
}

- (jboolean)containsValueWithId:(id)o {
  for (id<JavaUtilSet> __strong values in nil_chk([((id<JavaUtilMap>) nil_chk(map_)) values])) {
    if ([((id<JavaUtilSet>) nil_chk(values)) containsWithId:o]) return true;
  }
  return false;
}

- (id<JavaUtilSet>)getWithId:(id)o {
  return [((id<JavaUtilMap>) nil_chk(map_)) getWithId:o];
}

- (void)putWithId:(id)k
           withId:(id)v {
  id<JavaUtilSet> values = [((id<JavaUtilMap>) nil_chk(map_)) getWithId:k];
  if (values == nil) {
    values = new_JavaUtilHashSet_init();
    (void) [map_ putWithId:k withId:values];
  }
  [values addWithId:v];
}

- (void)putWithId:(id)k
  withJavaUtilSet:(id<JavaUtilSet>)vs {
  for (id __strong v in nil_chk(vs)) {
    [self putWithId:k withId:v];
  }
}

- (void)removeAllWithId:(id)o {
  (void) [((id<JavaUtilMap>) nil_chk(map_)) removeWithId:o];
}

- (void)removeWithId:(id)o
              withId:(id)v {
  id<JavaUtilSet> vs = [((id<JavaUtilMap>) nil_chk(map_)) getWithId:o];
  if (vs == nil) return;
  [vs removeWithId:v];
}

- (void)putAllWithLibComAfterlogicPgpUtilMultiMap:(LibComAfterlogicPgpUtilMultiMap *)other {
  for (id __strong key in nil_chk([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(other)) keySet])) {
    [self putWithId:key withJavaUtilSet:[other getWithId:key]];
  }
}

- (void)clear {
  [((id<JavaUtilMap>) nil_chk(map_)) clear];
}

- (id<JavaUtilSet>)keySet {
  return [((id<JavaUtilMap>) nil_chk(map_)) keySet];
}

- (id<JavaUtilCollection>)values {
  return [((id<JavaUtilMap>) nil_chk(map_)) values];
}

- (id<JavaUtilSet>)entrySet {
  return [((id<JavaUtilMap>) nil_chk(map_)) entrySet];
}

- (jboolean)isEqual:(id)o {
  if (o == nil) {
    return false;
  }
  if (!([o isKindOfClass:[LibComAfterlogicPgpUtilMultiMap class]])) {
    return false;
  }
  if (self == o) {
    return true;
  }
  return [((id<JavaUtilMap>) nil_chk(map_)) isEqual:((LibComAfterlogicPgpUtilMultiMap *) cast_chk(o, [LibComAfterlogicPgpUtilMultiMap class]))->map_];
}

- (NSUInteger)hash {
  return ((jint) [((id<JavaUtilMap>) nil_chk(map_)) hash]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, 3, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 5, -1, 6, -1, -1 },
    { NULL, "Z", 0x1, 7, 5, -1, 8, -1, -1 },
    { NULL, "LJavaUtilSet;", 0x1, 9, 5, -1, 10, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, 13, -1, -1 },
    { NULL, "V", 0x1, 11, 14, -1, 15, -1, -1 },
    { NULL, "V", 0x1, 16, 5, -1, 17, -1, -1 },
    { NULL, "V", 0x1, 18, 12, -1, 13, -1, -1 },
    { NULL, "V", 0x1, 19, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilSet;", 0x1, -1, -1, -1, 20, -1, -1 },
    { NULL, "LJavaUtilCollection;", 0x1, -1, -1, -1, 21, -1, -1 },
    { NULL, "LJavaUtilSet;", 0x1, -1, -1, -1, 22, -1, -1 },
    { NULL, "Z", 0x1, 23, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 24, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithLibComAfterlogicPgpUtilMultiMap:);
  methods[2].selector = @selector(initWithJavaUtilMap:);
  methods[3].selector = @selector(size);
  methods[4].selector = @selector(isEmpty);
  methods[5].selector = @selector(containsKeyWithId:);
  methods[6].selector = @selector(containsValueWithId:);
  methods[7].selector = @selector(getWithId:);
  methods[8].selector = @selector(putWithId:withId:);
  methods[9].selector = @selector(putWithId:withJavaUtilSet:);
  methods[10].selector = @selector(removeAllWithId:);
  methods[11].selector = @selector(removeWithId:withId:);
  methods[12].selector = @selector(putAllWithLibComAfterlogicPgpUtilMultiMap:);
  methods[13].selector = @selector(clear);
  methods[14].selector = @selector(keySet);
  methods[15].selector = @selector(values);
  methods[16].selector = @selector(entrySet);
  methods[17].selector = @selector(isEqual:);
  methods[18].selector = @selector(hash);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "map_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 25, -1 },
  };
  static const void *ptrTable[] = { "LLibComAfterlogicPgpUtilMultiMap;", "(Llib/com/afterlogic/pgp/util/MultiMap<TK;TV;>;)V", "LJavaUtilMap;", "(Ljava/util/Map<TK;Ljava/util/Set<TV;>;>;)V", "containsKey", "LNSObject;", "(TK;)Z", "containsValue", "(TV;)Z", "get", "(TK;)Ljava/util/Set<TV;>;", "put", "LNSObject;LNSObject;", "(TK;TV;)V", "LNSObject;LJavaUtilSet;", "(TK;Ljava/util/Set<TV;>;)V", "removeAll", "(TK;)V", "remove", "putAll", "()Ljava/util/Set<TK;>;", "()Ljava/util/Collection<Ljava/util/Set<TV;>;>;", "()Ljava/util/Set<Ljava/util/Map$Entry<TK;Ljava/util/Set<TV;>;>;>;", "equals", "hashCode", "Ljava/util/Map<TK;Ljava/util/Set<TV;>;>;", "<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpUtilMultiMap = { "MultiMap", "lib.com.afterlogic.pgp.util", ptrTable, methods, fields, 7, 0x1, 19, 1, -1, -1, -1, 26, -1 };
  return &_LibComAfterlogicPgpUtilMultiMap;
}

@end

void LibComAfterlogicPgpUtilMultiMap_init(LibComAfterlogicPgpUtilMultiMap *self) {
  NSObject_init(self);
  self->map_ = new_JavaUtilHashMap_init();
}

LibComAfterlogicPgpUtilMultiMap *new_LibComAfterlogicPgpUtilMultiMap_init() {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpUtilMultiMap, init)
}

LibComAfterlogicPgpUtilMultiMap *create_LibComAfterlogicPgpUtilMultiMap_init() {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpUtilMultiMap, init)
}

void LibComAfterlogicPgpUtilMultiMap_initWithLibComAfterlogicPgpUtilMultiMap_(LibComAfterlogicPgpUtilMultiMap *self, LibComAfterlogicPgpUtilMultiMap *other) {
  NSObject_init(self);
  self->map_ = new_JavaUtilHashMap_init();
  for (id __strong k in nil_chk([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(other))->map_ keySet])) {
    (void) [self->map_ putWithId:k withId:new_JavaUtilHashSet_initWithJavaUtilCollection_([other->map_ getWithId:k])];
  }
}

LibComAfterlogicPgpUtilMultiMap *new_LibComAfterlogicPgpUtilMultiMap_initWithLibComAfterlogicPgpUtilMultiMap_(LibComAfterlogicPgpUtilMultiMap *other) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpUtilMultiMap, initWithLibComAfterlogicPgpUtilMultiMap_, other)
}

LibComAfterlogicPgpUtilMultiMap *create_LibComAfterlogicPgpUtilMultiMap_initWithLibComAfterlogicPgpUtilMultiMap_(LibComAfterlogicPgpUtilMultiMap *other) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpUtilMultiMap, initWithLibComAfterlogicPgpUtilMultiMap_, other)
}

void LibComAfterlogicPgpUtilMultiMap_initWithJavaUtilMap_(LibComAfterlogicPgpUtilMultiMap *self, id<JavaUtilMap> content) {
  NSObject_init(self);
  self->map_ = new_JavaUtilHashMap_initWithJavaUtilMap_(content);
}

LibComAfterlogicPgpUtilMultiMap *new_LibComAfterlogicPgpUtilMultiMap_initWithJavaUtilMap_(id<JavaUtilMap> content) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpUtilMultiMap, initWithJavaUtilMap_, content)
}

LibComAfterlogicPgpUtilMultiMap *create_LibComAfterlogicPgpUtilMultiMap_initWithJavaUtilMap_(id<JavaUtilMap> content) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpUtilMultiMap, initWithJavaUtilMap_, content)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpUtilMultiMap)

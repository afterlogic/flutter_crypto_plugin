//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/TlsServerProtocol.java
//

#include "AbstractTlsContext.h"
#include "AlertDescription.h"
#include "Arrays.h"
#include "AsymmetricKeyParameter.h"
#include "Certificate.h"
#include "CertificateRequest.h"
#include "CertificateStatus.h"
#include "CipherSuite.h"
#include "ConnectionEnd.h"
#include "DigitallySigned.h"
#include "HandshakeType.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "NewSessionTicket.h"
#include "ProtocolVersion.h"
#include "PublicKeyFactory.h"
#include "RandomGenerator.h"
#include "RecordStream.h"
#include "SecurityParameters.h"
#include "SignatureAndHashAlgorithm.h"
#include "SubjectPublicKeyInfo.h"
#include "TlsCipher.h"
#include "TlsCompression.h"
#include "TlsContext.h"
#include "TlsCredentials.h"
#include "TlsExtensionsUtils.h"
#include "TlsFatalAlert.h"
#include "TlsHandshakeHash.h"
#include "TlsKeyExchange.h"
#include "TlsPeer.h"
#include "TlsProtocol.h"
#include "TlsServer.h"
#include "TlsServerContextImpl.h"
#include "TlsServerProtocol.h"
#include "TlsSigner.h"
#include "TlsUtils.h"
#include "X509Certificate.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/security/SecureRandom.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"

@implementation LibOrgBouncycastleCryptoTlsTlsServerProtocol

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)input
                   withJavaIoOutputStream:(JavaIoOutputStream *)output
             withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  return self;
}

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (void)acceptWithLibOrgBouncycastleCryptoTlsTlsServer:(id<LibOrgBouncycastleCryptoTlsTlsServer>)tlsServer {
  if (tlsServer == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'tlsServer' cannot be null");
  }
  if (self->tlsServer_ != nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"'accept' can only be called once");
  }
  self->tlsServer_ = tlsServer;
  self->securityParameters_ = new_LibOrgBouncycastleCryptoTlsSecurityParameters_init();
  self->securityParameters_->entity_ = LibOrgBouncycastleCryptoTlsConnectionEnd_server;
  self->tlsServerContext_ = new_LibOrgBouncycastleCryptoTlsTlsServerContextImpl_initWithJavaSecuritySecureRandom_withLibOrgBouncycastleCryptoTlsSecurityParameters_(secureRandom_, securityParameters_);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->serverRandom_ = LibOrgBouncycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withLibOrgBouncycastleCryptoPrngRandomGenerator_([tlsServer shouldUseGMTUnixTime], [((LibOrgBouncycastleCryptoTlsTlsServerContextImpl *) nil_chk(tlsServerContext_)) getNonceRandomGenerator]);
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(self->tlsServer_)) init__WithLibOrgBouncycastleCryptoTlsTlsServerContext:tlsServerContext_];
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:tlsServerContext_];
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setRestrictReadVersionWithBoolean:false];
  [self blockForHandshake];
}

- (void)cleanupHandshake {
  [super cleanupHandshake];
  self->keyExchange_ = nil;
  self->serverCredentials_ = nil;
  self->certificateRequest_ = nil;
  self->prepareFinishHash_ = nil;
}

- (id<LibOrgBouncycastleCryptoTlsTlsContext>)getContext {
  return tlsServerContext_;
}

- (LibOrgBouncycastleCryptoTlsAbstractTlsContext *)getContextAdmin {
  return tlsServerContext_;
}

- (id<LibOrgBouncycastleCryptoTlsTlsPeer>)getPeer {
  return tlsServer_;
}

- (void)handleHandshakeMessageWithShort:(jshort)type
         withJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  switch (type) {
    case LibOrgBouncycastleCryptoTlsHandshakeType_client_hello:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_START:
        {
          [self receiveClientHelloMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO;
          [self sendServerHelloMessage];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO;
          [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) notifyHelloComplete];
          JavaUtilVector *serverSupplementalData = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getServerSupplementalData];
          if (serverSupplementalData != nil) {
            [self sendSupplementalDataMessageWithJavaUtilVector:serverSupplementalData];
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA;
          self->keyExchange_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getKeyExchange];
          [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:[self getContext]];
          self->serverCredentials_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getCredentials];
          LibOrgBouncycastleCryptoTlsCertificate *serverCertificate = nil;
          if (self->serverCredentials_ == nil) {
            [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerCredentials];
          }
          else {
            [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processServerCredentialsWithLibOrgBouncycastleCryptoTlsTlsCredentials:self->serverCredentials_];
            serverCertificate = [((id<LibOrgBouncycastleCryptoTlsTlsCredentials>) nil_chk(self->serverCredentials_)) getCertificate];
            [self sendCertificateMessageWithLibOrgBouncycastleCryptoTlsCertificate:serverCertificate];
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE;
          if (serverCertificate == nil || [serverCertificate isEmpty]) {
            self->allowCertificateStatus_ = false;
          }
          if (self->allowCertificateStatus_) {
            LibOrgBouncycastleCryptoTlsCertificateStatus *certificateStatus = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getCertificateStatus];
            if (certificateStatus != nil) {
              [self sendCertificateStatusMessageWithLibOrgBouncycastleCryptoTlsCertificateStatus:certificateStatus];
            }
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS;
          IOSByteArray *serverKeyExchange = [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) generateServerKeyExchange];
          if (serverKeyExchange != nil) {
            [self sendServerKeyExchangeMessageWithByteArray:serverKeyExchange];
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE;
          if (self->serverCredentials_ != nil) {
            self->certificateRequest_ = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getCertificateRequest];
            if (self->certificateRequest_ != nil) {
              if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext]) != ([((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(certificateRequest_)) getSupportedSignatureAlgorithms] != nil)) {
                @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
              }
              [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) validateCertificateRequestWithLibOrgBouncycastleCryptoTlsCertificateRequest:certificateRequest_];
              [self sendCertificateRequestMessageWithLibOrgBouncycastleCryptoTlsCertificateRequest:certificateRequest_];
              LibOrgBouncycastleCryptoTlsTlsUtils_trackHashAlgorithmsWithLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withJavaUtilVector_([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash], [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(self->certificateRequest_)) getSupportedSignatureAlgorithms]);
            }
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST;
          [self sendServerHelloDoneMessage];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE;
          [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk([((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash])) sealHashAlgorithms];
          break;
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_END:
        {
          [self refuseRenegotiation];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_supplemental_data:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) processClientSupplementalDataWithJavaUtilVector:LibOrgBouncycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(buf)];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA;
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) processClientSupplementalDataWithJavaUtilVector:nil];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA:
        {
          if (self->certificateRequest_ == nil) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
          [self receiveCertificateMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE;
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_client_key_exchange:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE:
        {
          [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) processClientSupplementalDataWithJavaUtilVector:nil];
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA:
        {
          if (self->certificateRequest_ == nil) {
            [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
          }
          else {
            if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
              @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
            }
            else if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
              if (self->peerCertificate_ == nil) {
                @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
              }
            }
            else {
              [self notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN)];
            }
          }
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE:
        {
          [self receiveClientKeyExchangeMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE;
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate_verify:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE:
        {
          if (![self expectCertificateVerifyMessage]) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
          [self receiveCertificateVerifyMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY;
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_finished:
    {
      switch (self->connection_state_) {
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE:
        {
          if ([self expectCertificateVerifyMessage]) {
            @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
          }
        }
        case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY:
        {
          [self processFinishedMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
          if (self->expectSessionTicket_) {
            [self sendNewSessionTicketMessageWithLibOrgBouncycastleCryptoTlsNewSessionTicket:[((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getNewSessionTicket]];
          }
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET;
          [self sendChangeCipherSpecMessage];
          [self sendFinishedMessage];
          self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
          [self completeHandshake];
          break;
        }
        default:
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case LibOrgBouncycastleCryptoTlsHandshakeType_hello_request:
    case LibOrgBouncycastleCryptoTlsHandshakeType_hello_verify_request:
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_hello:
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_key_exchange:
    case LibOrgBouncycastleCryptoTlsHandshakeType_certificate_request:
    case LibOrgBouncycastleCryptoTlsHandshakeType_server_hello_done:
    case LibOrgBouncycastleCryptoTlsHandshakeType_session_ticket:
    default:
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
}

- (void)handleAlertWarningMessageWithShort:(jshort)alertDescription {
  [super handleAlertWarningMessageWithShort:alertDescription];
  switch (alertDescription) {
    case LibOrgBouncycastleCryptoTlsAlertDescription_no_certificate:
    {
      if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext]) && self->certificateRequest_ != nil) {
        switch (self->connection_state_) {
          case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE:
          {
            [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) processClientSupplementalDataWithJavaUtilVector:nil];
          }
          case LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA:
          {
            [self notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:JreLoadStatic(LibOrgBouncycastleCryptoTlsCertificate, EMPTY_CHAIN)];
            self->connection_state_ = LibOrgBouncycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE;
            return;
          }
        }
      }
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
    }
  }
}

- (void)notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:(LibOrgBouncycastleCryptoTlsCertificate *)clientCertificate {
  if (certificateRequest_ == nil) {
    @throw new_JavaLangIllegalStateException_init();
  }
  if (peerCertificate_ != nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_unexpected_message);
  }
  self->peerCertificate_ = clientCertificate;
  if ([((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(clientCertificate)) isEmpty]) {
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
  }
  else {
    self->clientCertificateType_ = LibOrgBouncycastleCryptoTlsTlsUtils_getClientCertificateTypeWithLibOrgBouncycastleCryptoTlsCertificate_withLibOrgBouncycastleCryptoTlsCertificate_(clientCertificate, [((id<LibOrgBouncycastleCryptoTlsTlsCredentials>) nil_chk(self->serverCredentials_)) getCertificate]);
    [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(self->tlsServer_)) notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
}

- (void)receiveCertificateMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  LibOrgBouncycastleCryptoTlsCertificate *clientCertificate = LibOrgBouncycastleCryptoTlsCertificate_parseWithJavaIoInputStream_(buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [self notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:clientCertificate];
}

- (void)receiveCertificateVerifyMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  if (certificateRequest_ == nil) {
    @throw new_JavaLangIllegalStateException_init();
  }
  LibOrgBouncycastleCryptoTlsDigitallySigned *clientCertificateVerify = LibOrgBouncycastleCryptoTlsDigitallySigned_parseWithLibOrgBouncycastleCryptoTlsTlsContext_withJavaIoInputStream_([self getContext], buf);
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  @try {
    LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *signatureAlgorithm = [((LibOrgBouncycastleCryptoTlsDigitallySigned *) nil_chk(clientCertificateVerify)) getAlgorithm];
    IOSByteArray *hash_;
    if (LibOrgBouncycastleCryptoTlsTlsUtils_isTLSv12WithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
      LibOrgBouncycastleCryptoTlsTlsUtils_verifySupportedSignatureAlgorithmWithJavaUtilVector_withLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm_([((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(certificateRequest_)) getSupportedSignatureAlgorithms], signatureAlgorithm);
      hash_ = [((id<LibOrgBouncycastleCryptoTlsTlsHandshakeHash>) nil_chk(prepareFinishHash_)) getFinalHashWithShort:[((LibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm *) nil_chk(signatureAlgorithm)) getHash]];
    }
    else {
      hash_ = [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) getSessionHash];
    }
    LibOrgBouncycastleAsn1X509X509Certificate *x509Cert = [((LibOrgBouncycastleCryptoTlsCertificate *) nil_chk(peerCertificate_)) getCertificateAtWithInt:0];
    LibOrgBouncycastleAsn1X509SubjectPublicKeyInfo *keyInfo = [((LibOrgBouncycastleAsn1X509X509Certificate *) nil_chk(x509Cert)) getSubjectPublicKeyInfo];
    LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *publicKey = LibOrgBouncycastleCryptoUtilPublicKeyFactory_createKeyWithLibOrgBouncycastleAsn1X509SubjectPublicKeyInfo_(keyInfo);
    id<LibOrgBouncycastleCryptoTlsTlsSigner> tlsSigner = LibOrgBouncycastleCryptoTlsTlsUtils_createTlsSignerWithShort_(clientCertificateType_);
    [((id<LibOrgBouncycastleCryptoTlsTlsSigner>) nil_chk(tlsSigner)) init__WithLibOrgBouncycastleCryptoTlsTlsContext:[self getContext]];
    if (![tlsSigner verifyRawSignatureWithLibOrgBouncycastleCryptoTlsSignatureAndHashAlgorithm:signatureAlgorithm withByteArray:[clientCertificateVerify getSignature] withLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:publicKey withByteArray:hash_]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decrypt_error);
    }
  }
  @catch (LibOrgBouncycastleCryptoTlsTlsFatalAlert *e) {
    @throw e;
  }
  @catch (JavaLangException *e) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsAlertDescription_decrypt_error, e);
  }
}

- (void)receiveClientHelloMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  LibOrgBouncycastleCryptoTlsProtocolVersion *client_version = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  if ([((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(client_version)) isDTLS]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  IOSByteArray *client_random = LibOrgBouncycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(32, buf);
  IOSByteArray *sessionID = LibOrgBouncycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  if (((IOSByteArray *) nil_chk(sessionID))->size_ > 32) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  jint cipher_suites_length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
  if (cipher_suites_length < 2 || (cipher_suites_length & 1) != 0) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_decode_error);
  }
  self->offeredCipherSuites_ = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16ArrayWithInt_withJavaIoInputStream_(cipher_suites_length / 2, buf);
  jint compression_methods_length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithJavaIoInputStream_(buf);
  if (compression_methods_length < 1) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  self->offeredCompressionMethods_ = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8ArrayWithInt_withJavaIoInputStream_(compression_methods_length, buf);
  self->clientExtensions_ = LibOrgBouncycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(buf);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->extendedMasterSecret_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasExtendedMasterSecretExtensionWithJavaUtilHashtable_(clientExtensions_);
  if (![((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) isExtendedMasterSecret] && [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) requiresExtendedMasterSecret]) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
  }
  [((LibOrgBouncycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) notifyClientVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:client_version];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) notifyFallbackWithBoolean:LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV)];
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->clientRandom_ = client_random;
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) notifyOfferedCipherSuitesWithIntArray:offeredCipherSuites_];
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) notifyOfferedCompressionMethodsWithShortArray:offeredCompressionMethods_];
  {
    if (LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, LibOrgBouncycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) {
      self->secure_renegotiation_ = true;
    }
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(clientExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    if (renegExtData != nil) {
      self->secure_renegotiation_ = true;
      if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(renegExtData, LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES)))) {
        @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_handshake_failure);
      }
    }
  }
  [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) notifySecureRenegotiationWithBoolean:self->secure_renegotiation_];
  if (clientExtensions_ != nil) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_getPaddingExtensionWithJavaUtilHashtable_(clientExtensions_);
    [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) processClientExtensionsWithJavaUtilHashtable:clientExtensions_];
  }
}

- (void)receiveClientKeyExchangeMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  [((id<LibOrgBouncycastleCryptoTlsTlsKeyExchange>) nil_chk(keyExchange_)) processClientKeyExchangeWithJavaIoInputStream:buf];
  LibOrgBouncycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
    LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
  }
  self->prepareFinishHash_ = [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) prepareToFinish];
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->sessionHash_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsHandshakeHash_withByteArray_([self getContext], prepareFinishHash_, nil);
  if (!LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_([self getContext])) {
    LibOrgBouncycastleCryptoTlsTlsProtocol_establishMasterSecretWithLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
  }
  [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setPendingConnectionStateWithLibOrgBouncycastleCryptoTlsTlsCompression:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCompression] withLibOrgBouncycastleCryptoTlsTlsCipher:[((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCipher]];
}

- (void)sendCertificateRequestMessageWithLibOrgBouncycastleCryptoTlsCertificateRequest:(LibOrgBouncycastleCryptoTlsCertificateRequest *)certificateRequest {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_certificate_request);
  [((LibOrgBouncycastleCryptoTlsCertificateRequest *) nil_chk(certificateRequest)) encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendCertificateStatusMessageWithLibOrgBouncycastleCryptoTlsCertificateStatus:(LibOrgBouncycastleCryptoTlsCertificateStatus *)certificateStatus {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_certificate_status);
  [((LibOrgBouncycastleCryptoTlsCertificateStatus *) nil_chk(certificateStatus)) encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendNewSessionTicketMessageWithLibOrgBouncycastleCryptoTlsNewSessionTicket:(LibOrgBouncycastleCryptoTlsNewSessionTicket *)newSessionTicket {
  if (newSessionTicket == nil) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_session_ticket);
  [newSessionTicket encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendServerHelloMessage {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_(self, LibOrgBouncycastleCryptoTlsHandshakeType_server_hello);
  {
    LibOrgBouncycastleCryptoTlsProtocolVersion *server_version = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getServerVersion];
    if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(server_version)) isEqualOrEarlierVersionOfWithLibOrgBouncycastleCryptoTlsProtocolVersion:[((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getClientVersion]]) {
      @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
    }
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setReadVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    [((LibOrgBouncycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setRestrictReadVersionWithBoolean:true];
    [((LibOrgBouncycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setServerVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:server_version];
    LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withJavaIoOutputStream_(server_version, message);
  }
  [message writeWithByteArray:((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->serverRandom_];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES), message);
  jint selectedCipherSuite = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getSelectedCipherSuite];
  if (!LibOrgBouncycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, selectedCipherSuite) || selectedCipherSuite == LibOrgBouncycastleCryptoTlsCipherSuite_TLS_NULL_WITH_NULL_NULL || LibOrgBouncycastleCryptoTlsCipherSuite_isSCSVWithInt_(selectedCipherSuite) || !LibOrgBouncycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withLibOrgBouncycastleCryptoTlsProtocolVersion_(selectedCipherSuite, [((id<LibOrgBouncycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getServerVersion])) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->cipherSuite_ = selectedCipherSuite;
  jshort selectedCompressionMethod = [((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getSelectedCompressionMethod];
  if (!LibOrgBouncycastleUtilArrays_containsWithShortArray_withShort_(offeredCompressionMethods_, selectedCompressionMethod)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->compressionAlgorithm_ = selectedCompressionMethod;
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withJavaIoOutputStream_(selectedCipherSuite, message);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withJavaIoOutputStream_(selectedCompressionMethod, message);
  self->serverExtensions_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_ensureExtensionsInitialisedWithJavaUtilHashtable_([((id<LibOrgBouncycastleCryptoTlsTlsServer>) nil_chk(tlsServer_)) getServerExtensions]);
  if (self->secure_renegotiation_) {
    IOSByteArray *renegExtData = LibOrgBouncycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(self->serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    jboolean noRenegExt = nil == renegExtData;
    if (noRenegExt) {
      (void) [((JavaUtilHashtable *) nil_chk(self->serverExtensions_)) putWithId:JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo) withId:LibOrgBouncycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsUtils, EMPTY_BYTES))];
    }
  }
  if (LibOrgBouncycastleCryptoTlsTlsUtils_isSSLWithLibOrgBouncycastleCryptoTlsTlsContext_(tlsServerContext_)) {
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->extendedMasterSecret_ = false;
  }
  else if ([((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) isExtendedMasterSecret]) {
    LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_addExtendedMasterSecretExtensionWithJavaUtilHashtable_(serverExtensions_);
  }
  if (![((JavaUtilHashtable *) nil_chk(self->serverExtensions_)) isEmpty]) {
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->encryptThenMAC_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(serverExtensions_);
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->maxFragmentLength_ = [self processMaxFragmentLengthExtensionWithJavaUtilHashtable:clientExtensions_ withJavaUtilHashtable:serverExtensions_ withShort:LibOrgBouncycastleCryptoTlsAlertDescription_internal_error];
    ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->truncatedHMac_ = LibOrgBouncycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(serverExtensions_);
    self->allowCertificateStatus_ = (!resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsExtensionsUtils, EXT_status_request), LibOrgBouncycastleCryptoTlsAlertDescription_internal_error));
    self->expectSessionTicket_ = (!resumedSession_ && LibOrgBouncycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(serverExtensions_, JreLoadStatic(LibOrgBouncycastleCryptoTlsTlsProtocol, EXT_SessionTicket), LibOrgBouncycastleCryptoTlsAlertDescription_internal_error));
    LibOrgBouncycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(message, serverExtensions_);
  }
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->prfAlgorithm_ = LibOrgBouncycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithLibOrgBouncycastleCryptoTlsTlsContext_withInt_([self getContext], [((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) getCipherSuite]);
  ((LibOrgBouncycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_))->verifyDataLength_ = 12;
  [self applyMaxFragmentLengthExtension];
  [message writeToRecordStream];
}

- (void)sendServerHelloDoneMessage {
  IOSByteArray *message = [IOSByteArray newArrayWithLength:4];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withByteArray_withInt_(LibOrgBouncycastleCryptoTlsHandshakeType_server_hello_done, message, 0);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint24WithInt_withByteArray_withInt_(0, message, 1);
  [self writeHandshakeMessageWithByteArray:message withInt:0 withInt:message->size_];
}

- (void)sendServerKeyExchangeMessageWithByteArray:(IOSByteArray *)serverKeyExchange {
  LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_LibOrgBouncycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithLibOrgBouncycastleCryptoTlsTlsProtocol_withShort_withInt_(self, LibOrgBouncycastleCryptoTlsHandshakeType_server_key_exchange, ((IOSByteArray *) nil_chk(serverKeyExchange))->size_);
  [message writeWithByteArray:serverKeyExchange];
  [message writeToRecordStream];
}

- (jboolean)expectCertificateVerifyMessage {
  return clientCertificateType_ >= 0 && LibOrgBouncycastleCryptoTlsTlsUtils_hasSigningCapabilityWithShort_(clientCertificateType_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsContext;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsAbstractTlsContext;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsTlsPeer;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 6, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 7, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 11, 12, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 12, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 14, 12, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 15, 12, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 16, 17, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 19, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 20, 21, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 22, 23, 4, -1, -1, -1 },
    { NULL, "Z", 0x4, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoInputStream:withJavaIoOutputStream:withJavaSecuritySecureRandom:);
  methods[1].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[2].selector = @selector(acceptWithLibOrgBouncycastleCryptoTlsTlsServer:);
  methods[3].selector = @selector(cleanupHandshake);
  methods[4].selector = @selector(getContext);
  methods[5].selector = @selector(getContextAdmin);
  methods[6].selector = @selector(getPeer);
  methods[7].selector = @selector(handleHandshakeMessageWithShort:withJavaIoByteArrayInputStream:);
  methods[8].selector = @selector(handleAlertWarningMessageWithShort:);
  methods[9].selector = @selector(notifyClientCertificateWithLibOrgBouncycastleCryptoTlsCertificate:);
  methods[10].selector = @selector(receiveCertificateMessageWithJavaIoByteArrayInputStream:);
  methods[11].selector = @selector(receiveCertificateVerifyMessageWithJavaIoByteArrayInputStream:);
  methods[12].selector = @selector(receiveClientHelloMessageWithJavaIoByteArrayInputStream:);
  methods[13].selector = @selector(receiveClientKeyExchangeMessageWithJavaIoByteArrayInputStream:);
  methods[14].selector = @selector(sendCertificateRequestMessageWithLibOrgBouncycastleCryptoTlsCertificateRequest:);
  methods[15].selector = @selector(sendCertificateStatusMessageWithLibOrgBouncycastleCryptoTlsCertificateStatus:);
  methods[16].selector = @selector(sendNewSessionTicketMessageWithLibOrgBouncycastleCryptoTlsNewSessionTicket:);
  methods[17].selector = @selector(sendServerHelloMessage);
  methods[18].selector = @selector(sendServerHelloDoneMessage);
  methods[19].selector = @selector(sendServerKeyExchangeMessageWithByteArray:);
  methods[20].selector = @selector(expectCertificateVerifyMessage);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tlsServer_", "LLibOrgBouncycastleCryptoTlsTlsServer;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "tlsServerContext_", "LLibOrgBouncycastleCryptoTlsTlsServerContextImpl;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "keyExchange_", "LLibOrgBouncycastleCryptoTlsTlsKeyExchange;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "serverCredentials_", "LLibOrgBouncycastleCryptoTlsTlsCredentials;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "certificateRequest_", "LLibOrgBouncycastleCryptoTlsCertificateRequest;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "clientCertificateType_", "S", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "prepareFinishHash_", "LLibOrgBouncycastleCryptoTlsTlsHandshakeHash;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoInputStream;LJavaIoOutputStream;LJavaSecuritySecureRandom;", "LJavaSecuritySecureRandom;", "accept", "LLibOrgBouncycastleCryptoTlsTlsServer;", "LJavaIoIOException;", "handleHandshakeMessage", "SLJavaIoByteArrayInputStream;", "handleAlertWarningMessage", "S", "notifyClientCertificate", "LLibOrgBouncycastleCryptoTlsCertificate;", "receiveCertificateMessage", "LJavaIoByteArrayInputStream;", "receiveCertificateVerifyMessage", "receiveClientHelloMessage", "receiveClientKeyExchangeMessage", "sendCertificateRequestMessage", "LLibOrgBouncycastleCryptoTlsCertificateRequest;", "sendCertificateStatusMessage", "LLibOrgBouncycastleCryptoTlsCertificateStatus;", "sendNewSessionTicketMessage", "LLibOrgBouncycastleCryptoTlsNewSessionTicket;", "sendServerKeyExchangeMessage", "[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsTlsServerProtocol = { "TlsServerProtocol", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 21, 7, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsTlsServerProtocol;
}

@end

void LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsServerProtocol *self, JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  self->tlsServer_ = nil;
  self->tlsServerContext_ = nil;
  self->keyExchange_ = nil;
  self->serverCredentials_ = nil;
  self->certificateRequest_ = nil;
  self->clientCertificateType_ = -1;
  self->prepareFinishHash_ = nil;
}

LibOrgBouncycastleCryptoTlsTlsServerProtocol *new_LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsServerProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

LibOrgBouncycastleCryptoTlsTlsServerProtocol *create_LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsServerProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

void LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaSecuritySecureRandom_(LibOrgBouncycastleCryptoTlsTlsServerProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  LibOrgBouncycastleCryptoTlsTlsProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  self->tlsServer_ = nil;
  self->tlsServerContext_ = nil;
  self->keyExchange_ = nil;
  self->serverCredentials_ = nil;
  self->certificateRequest_ = nil;
  self->clientCertificateType_ = -1;
  self->prepareFinishHash_ = nil;
}

LibOrgBouncycastleCryptoTlsTlsServerProtocol *new_LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsTlsServerProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

LibOrgBouncycastleCryptoTlsTlsServerProtocol *create_LibOrgBouncycastleCryptoTlsTlsServerProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsTlsServerProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsTlsServerProtocol)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/modes/GCMBlockCipher.java
//

#include "AEADParameters.h"
#include "Arrays.h"
#include "BasicGCMExponentiator.h"
#include "BlockCipher.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "GCMBlockCipher.h"
#include "GCMExponentiator.h"
#include "GCMMultiplier.h"
#include "GCMUtil.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "Pack.h"
#include "ParametersWithIV.h"
#include "Tables4kGCMMultiplier.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoModesGCMBlockCipher () {
 @public
  id<LibOrgBouncycastleCryptoBlockCipher> cipher_;
  id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier> multiplier_;
  id<LibOrgBouncycastleCryptoModesGcmGCMExponentiator> exp_;
  jboolean forEncryption_;
  jboolean initialised_;
  jint macSize_;
  IOSByteArray *lastKey_;
  IOSByteArray *nonce_;
  IOSByteArray *initialAssociatedText_;
  IOSByteArray *H_;
  IOSByteArray *J0_;
  IOSByteArray *bufBlock_;
  IOSByteArray *macBlock_;
  IOSByteArray *S_;
  IOSByteArray *S_at_;
  IOSByteArray *S_atPre_;
  IOSByteArray *counter_;
  jint blocksRemaining_;
  jint bufOff_;
  jlong totalLength_;
  IOSByteArray *atBlock_;
  jint atBlockPos_;
  jlong atLength_;
  jlong atLengthPre_;
}

- (void)initCipher OBJC_METHOD_FAMILY_NONE;

- (void)resetWithBoolean:(jboolean)clearMac;

- (void)processBlockWithByteArray:(IOSByteArray *)buf
                          withInt:(jint)bufOff
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff;

- (void)processPartialWithByteArray:(IOSByteArray *)buf
                            withInt:(jint)off
                            withInt:(jint)len
                      withByteArray:(IOSByteArray *)outArg
                            withInt:(jint)outOff;

- (void)gHASHWithByteArray:(IOSByteArray *)Y
             withByteArray:(IOSByteArray *)b
                   withInt:(jint)len;

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b;

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b
                        withInt:(jint)off;

- (void)gHASHPartialWithByteArray:(IOSByteArray *)Y
                    withByteArray:(IOSByteArray *)b
                          withInt:(jint)off
                          withInt:(jint)len;

- (void)getNextCTRBlockWithByteArray:(IOSByteArray *)block;

- (void)checkStatus;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, cipher_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, multiplier_, id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, exp_, id<LibOrgBouncycastleCryptoModesGcmGCMExponentiator>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, lastKey_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, H_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, J0_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, bufBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, S_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, S_at_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, S_atPre_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, counter_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesGCMBlockCipher, atBlock_, IOSByteArray *)

inline jint LibOrgBouncycastleCryptoModesGCMBlockCipher_get_BLOCK_SIZE(void);
#define LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE 16
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesGCMBlockCipher, BLOCK_SIZE, jint)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_initCipher(LibOrgBouncycastleCryptoModesGCMBlockCipher *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_resetWithBoolean_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, jboolean clearMac);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint bufOff, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_processPartialWithByteArray_withInt_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint off, jint len, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint len);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off, jint len);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_getNextCTRBlockWithByteArray_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *block);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(LibOrgBouncycastleCryptoModesGCMBlockCipher *self);

@implementation LibOrgBouncycastleCryptoModesGCMBlockCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)c {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, c);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)c
          withLibOrgBouncycastleCryptoModesGcmGCMMultiplier:(id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>)m {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_(self, c, m);
  return self;
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return cipher_;
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) getAlgorithmName], @"/GCM");
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  self->macBlock_ = nil;
  self->initialised_ = true;
  LibOrgBouncycastleCryptoParamsKeyParameter *keyParam;
  IOSByteArray *newNonce = nil;
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]]) {
    LibOrgBouncycastleCryptoParamsAEADParameters *param = (LibOrgBouncycastleCryptoParamsAEADParameters *) params;
    newNonce = [((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    initialAssociatedText_ = [param getAssociatedText];
    jint macSizeBits = [param getMacSize];
    if (macSizeBits < 32 || macSizeBits > 128 || macSizeBits % 8 != 0) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Invalid value for MAC size: ", macSizeBits));
    }
    macSize_ = macSizeBits / 8;
    keyParam = [param getKey];
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithIV *param = (LibOrgBouncycastleCryptoParamsParametersWithIV *) params;
    newNonce = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    initialAssociatedText_ = nil;
    macSize_ = 16;
    keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([param getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"invalid parameters passed to GCM");
  }
  jint bufLength = forEncryption ? LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE : (LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE + macSize_);
  self->bufBlock_ = [IOSByteArray newArrayWithLength:bufLength];
  if (newNonce == nil || newNonce->size_ < 1) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"IV must be at least 1 byte");
  }
  if (forEncryption) {
    if (nonce_ != nil && LibOrgBouncycastleUtilArrays_areEqualWithByteArray_withByteArray_(nonce_, newNonce)) {
      if (keyParam == nil) {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cannot reuse nonce for GCM encryption");
      }
      if (lastKey_ != nil && LibOrgBouncycastleUtilArrays_areEqualWithByteArray_withByteArray_(lastKey_, [keyParam getKey])) {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cannot reuse nonce for GCM encryption");
      }
    }
  }
  nonce_ = newNonce;
  if (keyParam != nil) {
    lastKey_ = [keyParam getKey];
  }
  if (keyParam != nil) {
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:keyParam];
    self->H_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) processBlockWithByteArray:H_ withInt:0 withByteArray:H_ withInt:0];
    [((id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>) nil_chk(multiplier_)) init__WithByteArray:H_];
    exp_ = nil;
  }
  else if (self->H_ == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Key must be specified in initial init");
  }
  self->J0_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  if (((IOSByteArray *) nil_chk(nonce_))->size_ == 12) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(nonce_, 0, J0_, 0, nonce_->size_);
    *IOSByteArray_GetRef(nil_chk(self->J0_), LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE - 1) = (jint) 0x01;
  }
  else {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(self, J0_, nonce_, nonce_->size_);
    IOSByteArray *X = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
    LibOrgBouncycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_((jlong) ((IOSByteArray *) nil_chk(nonce_))->size_ * 8, X, 8);
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, J0_, X);
  }
  self->S_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_at_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_atPre_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlock_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlockPos_ = 0;
  self->atLength_ = 0;
  self->atLengthPre_ = 0;
  self->counter_ = LibOrgBouncycastleUtilArrays_cloneWithByteArray_(J0_);
  self->blocksRemaining_ = -2;
  self->bufOff_ = 0;
  self->totalLength_ = 0;
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (IOSByteArray *)getMac {
  if (macBlock_ == nil) {
    return [IOSByteArray newArrayWithLength:macSize_];
  }
  return LibOrgBouncycastleUtilArrays_cloneWithByteArray_(macBlock_);
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (!forEncryption_) {
    if (totalData < macSize_) {
      return 0;
    }
    totalData -= macSize_;
  }
  return totalData - totalData % LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
}

- (void)processAADByteWithByte:(jbyte)inArg {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
  *IOSByteArray_GetRef(nil_chk(atBlock_), atBlockPos_) = inArg;
  if (++atBlockPos_ == LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_at_, atBlock_);
    atBlockPos_ = 0;
    atLength_ += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
  }
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
  for (jint i = 0; i < len; ++i) {
    *IOSByteArray_GetRef(nil_chk(atBlock_), atBlockPos_) = IOSByteArray_Get(nil_chk(inArg), inOff + i);
    if (++atBlockPos_ == LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
      LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_at_, atBlock_);
      atBlockPos_ = 0;
      atLength_ += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
    }
  }
}

- (void)initCipher {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_initCipher(self);
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
  *IOSByteArray_GetRef(nil_chk(bufBlock_), bufOff_) = inArg;
  if (++bufOff_ == bufBlock_->size_) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(self, bufBlock_, 0, outArg, outOff);
    if (forEncryption_) {
      bufOff_ = 0;
    }
    else {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bufBlock_, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, bufBlock_, 0, macSize_);
      bufOff_ = macSize_;
    }
    return LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
  }
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
  if ((((IOSByteArray *) nil_chk(inArg))->size_ - inOff) < len) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  jint resultLen = 0;
  if (forEncryption_) {
    if (bufOff_ != 0) {
      while (len > 0) {
        --len;
        *IOSByteArray_GetRef(nil_chk(bufBlock_), bufOff_) = IOSByteArray_Get(inArg, inOff++);
        if (++bufOff_ == LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
          LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(self, bufBlock_, 0, outArg, outOff);
          bufOff_ = 0;
          resultLen += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
          break;
        }
      }
    }
    while (len >= LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
      LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(self, inArg, inOff, outArg, outOff + resultLen);
      inOff += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
      len -= LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
      resultLen += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
    }
    if (len > 0) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff, bufBlock_, 0, len);
      bufOff_ = len;
    }
  }
  else {
    for (jint i = 0; i < len; ++i) {
      *IOSByteArray_GetRef(nil_chk(bufBlock_), bufOff_) = IOSByteArray_Get(inArg, inOff + i);
      if (++bufOff_ == bufBlock_->size_) {
        LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(self, bufBlock_, 0, outArg, outOff + resultLen);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bufBlock_, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, bufBlock_, 0, macSize_);
        bufOff_ = macSize_;
        resultLen += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
      }
    }
  }
  return resultLen;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
  if (totalLength_ == 0) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_initCipher(self);
  }
  jint extra = bufOff_;
  if (forEncryption_) {
    if ((((IOSByteArray *) nil_chk(outArg))->size_ - outOff) < (extra + macSize_)) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
  }
  else {
    if (extra < macSize_) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    extra -= macSize_;
    if ((((IOSByteArray *) nil_chk(outArg))->size_ - outOff) < extra) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
  }
  if (extra > 0) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_processPartialWithByteArray_withInt_withInt_withByteArray_withInt_(self, bufBlock_, 0, extra, outArg, outOff);
  }
  atLength_ += atBlockPos_;
  if (atLength_ > atLengthPre_) {
    if (atBlockPos_ > 0) {
      LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, S_at_, atBlock_, 0, atBlockPos_);
    }
    if (atLengthPre_ > 0) {
      LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(S_at_, S_atPre_);
    }
    jlong c = JreURShift64(((totalLength_ * 8) + 127), 7);
    IOSByteArray *H_c = [IOSByteArray newArrayWithLength:16];
    if (exp_ == nil) {
      exp_ = new_LibOrgBouncycastleCryptoModesGcmBasicGCMExponentiator_init();
      [exp_ init__WithByteArray:H_];
    }
    [((id<LibOrgBouncycastleCryptoModesGcmGCMExponentiator>) nil_chk(exp_)) exponentiateXWithLong:c withByteArray:H_c];
    LibOrgBouncycastleCryptoModesGcmGCMUtil_multiplyWithByteArray_withByteArray_(S_at_, H_c);
    LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(S_, S_at_);
  }
  IOSByteArray *X = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  LibOrgBouncycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_(atLength_ * 8, X, 0);
  LibOrgBouncycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_(totalLength_ * 8, X, 8);
  LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_, X);
  IOSByteArray *tag = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher_)) processBlockWithByteArray:J0_ withInt:0 withByteArray:tag withInt:0];
  LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(tag, S_);
  jint resultLen = extra;
  self->macBlock_ = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tag, 0, macBlock_, 0, macSize_);
  if (forEncryption_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, outArg, outOff + bufOff_, macSize_);
    resultLen += macSize_;
  }
  else {
    IOSByteArray *msgMac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bufBlock_, extra, msgMac, 0, macSize_);
    if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(self->macBlock_, msgMac)) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check in GCM failed");
    }
  }
  LibOrgBouncycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, false);
  return resultLen;
}

- (void)reset {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, true);
}

- (void)resetWithBoolean:(jboolean)clearMac {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, clearMac);
}

- (void)processBlockWithByteArray:(IOSByteArray *)buf
                          withInt:(jint)bufOff
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(self, buf, bufOff, outArg, outOff);
}

- (void)processPartialWithByteArray:(IOSByteArray *)buf
                            withInt:(jint)off
                            withInt:(jint)len
                      withByteArray:(IOSByteArray *)outArg
                            withInt:(jint)outOff {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_processPartialWithByteArray_withInt_withInt_withByteArray_withInt_(self, buf, off, len, outArg, outOff);
}

- (void)gHASHWithByteArray:(IOSByteArray *)Y
             withByteArray:(IOSByteArray *)b
                   withInt:(jint)len {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(self, Y, b, len);
}

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, Y, b);
}

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b
                        withInt:(jint)off {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_withInt_(self, Y, b, off);
}

- (void)gHASHPartialWithByteArray:(IOSByteArray *)Y
                    withByteArray:(IOSByteArray *)b
                          withInt:(jint)off
                          withInt:(jint)len {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, Y, b, off, len);
}

- (void)getNextCTRBlockWithByteArray:(IOSByteArray *)block {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_getNextCTRBlockWithByteArray_(self, block);
}

- (void)checkStatus {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 7, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 12, 13, 14, -1, -1, -1 },
    { NULL, "I", 0x1, 15, 16, 14, -1, -1, -1 },
    { NULL, "I", 0x1, 17, 18, 19, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 21, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 22, 23, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 24, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 28, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 29, 30, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withLibOrgBouncycastleCryptoModesGcmGCMMultiplier:);
  methods[2].selector = @selector(getUnderlyingCipher);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[5].selector = @selector(getMac);
  methods[6].selector = @selector(getOutputSizeWithInt:);
  methods[7].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[8].selector = @selector(processAADByteWithByte:);
  methods[9].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[10].selector = @selector(initCipher);
  methods[11].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[12].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(doFinalWithByteArray:withInt:);
  methods[14].selector = @selector(reset);
  methods[15].selector = @selector(resetWithBoolean:);
  methods[16].selector = @selector(processBlockWithByteArray:withInt:withByteArray:withInt:);
  methods[17].selector = @selector(processPartialWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[18].selector = @selector(gHASHWithByteArray:withByteArray:withInt:);
  methods[19].selector = @selector(gHASHBlockWithByteArray:withByteArray:);
  methods[20].selector = @selector(gHASHBlockWithByteArray:withByteArray:withInt:);
  methods[21].selector = @selector(gHASHPartialWithByteArray:withByteArray:withInt:withInt:);
  methods[22].selector = @selector(getNextCTRBlockWithByteArray:);
  methods[23].selector = @selector(checkStatus);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BLOCK_SIZE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, 0x1a, -1, -1, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "multiplier_", "LLibOrgBouncycastleCryptoModesGcmGCMMultiplier;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "exp_", "LLibOrgBouncycastleCryptoModesGcmGCMExponentiator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialised_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lastKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "H_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "J0_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_at_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_atPre_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "counter_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blocksRemaining_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufOff_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "totalLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atBlockPos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atLengthPre_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;", "LLibOrgBouncycastleCryptoBlockCipher;LLibOrgBouncycastleCryptoModesGcmGCMMultiplier;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "getOutputSize", "I", "getUpdateOutputSize", "processAADByte", "B", "processAADBytes", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;", "reset", "Z", "processBlock", "[BI[BI", "processPartial", "gHASH", "[B[BI", "gHASHBlock", "[B[B", "gHASHPartial", "[B[BII", "getNextCTRBlock", "[B" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesGCMBlockCipher = { "GCMBlockCipher", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 24, 25, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesGCMBlockCipher;
}

@end

void LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> c) {
  LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_(self, c, nil);
}

LibOrgBouncycastleCryptoModesGCMBlockCipher *new_LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> c) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, c)
}

LibOrgBouncycastleCryptoModesGCMBlockCipher *create_LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> c) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, c)
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> c, id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier> m) {
  NSObject_init(self);
  if ([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(c)) getBlockSize] != LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$IC", @"cipher required with a block size of ", LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, '.'));
  }
  if (m == nil) {
    m = new_LibOrgBouncycastleCryptoModesGcmTables4kGCMMultiplier_init();
  }
  self->cipher_ = c;
  self->multiplier_ = m;
}

LibOrgBouncycastleCryptoModesGCMBlockCipher *new_LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_(id<LibOrgBouncycastleCryptoBlockCipher> c, id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier> m) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_, c, m)
}

LibOrgBouncycastleCryptoModesGCMBlockCipher *create_LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_(id<LibOrgBouncycastleCryptoBlockCipher> c, id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier> m) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoModesGcmGCMMultiplier_, c, m)
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_initCipher(LibOrgBouncycastleCryptoModesGCMBlockCipher *self) {
  if (self->atLength_ > 0) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->S_at_, 0, self->S_atPre_, 0, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
    self->atLengthPre_ = self->atLength_;
  }
  if (self->atBlockPos_ > 0) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, self->S_atPre_, self->atBlock_, 0, self->atBlockPos_);
    self->atLengthPre_ += self->atBlockPos_;
  }
  if (self->atLengthPre_ > 0) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->S_atPre_, 0, self->S_, 0, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
  }
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_resetWithBoolean_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, jboolean clearMac) {
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->cipher_)) reset];
  self->S_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_at_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_atPre_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlock_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlockPos_ = 0;
  self->atLength_ = 0;
  self->atLengthPre_ = 0;
  self->counter_ = LibOrgBouncycastleUtilArrays_cloneWithByteArray_(self->J0_);
  self->blocksRemaining_ = -2;
  self->bufOff_ = 0;
  self->totalLength_ = 0;
  if (self->bufBlock_ != nil) {
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->bufBlock_, (jbyte) 0);
  }
  if (clearMac) {
    self->macBlock_ = nil;
  }
  if (self->forEncryption_) {
    self->initialised_ = false;
  }
  else {
    if (self->initialAssociatedText_ != nil) {
      [self processAADBytesWithByteArray:self->initialAssociatedText_ withInt:0 withInt:self->initialAssociatedText_->size_];
    }
  }
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_processBlockWithByteArray_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint bufOff, IOSByteArray *outArg, jint outOff) {
  if ((((IOSByteArray *) nil_chk(outArg))->size_ - outOff) < LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
  }
  if (self->totalLength_ == 0) {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_initCipher(self);
  }
  IOSByteArray *ctrBlock = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  LibOrgBouncycastleCryptoModesGCMBlockCipher_getNextCTRBlockWithByteArray_(self, ctrBlock);
  if (self->forEncryption_) {
    LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_withInt_(ctrBlock, buf, bufOff);
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, self->S_, ctrBlock);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ctrBlock, 0, outArg, outOff, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
  }
  else {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_withInt_(self, self->S_, buf, bufOff);
    LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withInt_withByteArray_withInt_withByteArray_withInt_(ctrBlock, 0, buf, bufOff, outArg, outOff);
  }
  self->totalLength_ += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_processPartialWithByteArray_withInt_withInt_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint off, jint len, IOSByteArray *outArg, jint outOff) {
  IOSByteArray *ctrBlock = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  LibOrgBouncycastleCryptoModesGCMBlockCipher_getNextCTRBlockWithByteArray_(self, ctrBlock);
  if (self->forEncryption_) {
    LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withInt_withByteArray_withInt_withInt_(buf, off, ctrBlock, 0, len);
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, self->S_, buf, off, len);
  }
  else {
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, self->S_, buf, off, len);
    LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withInt_withByteArray_withInt_withInt_(buf, off, ctrBlock, 0, len);
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buf, off, outArg, outOff, len);
  self->totalLength_ += len;
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint len) {
  for (jint pos = 0; pos < len; pos += LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    jint num = JavaLangMath_minWithInt_withInt_(len - pos, LibOrgBouncycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
    LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, Y, b, pos, num);
  }
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b) {
  LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(Y, b);
  [((id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithByteArray:Y];
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off) {
  LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_withInt_(Y, b, off);
  [((id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithByteArray:Y];
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off, jint len) {
  LibOrgBouncycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_withInt_withInt_(Y, b, off, len);
  [((id<LibOrgBouncycastleCryptoModesGcmGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithByteArray:Y];
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_getNextCTRBlockWithByteArray_(LibOrgBouncycastleCryptoModesGCMBlockCipher *self, IOSByteArray *block) {
  if (self->blocksRemaining_ == 0) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Attempt to process too many blocks");
  }
  self->blocksRemaining_--;
  jint c = 1;
  c += IOSByteArray_Get(nil_chk(self->counter_), 15) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 15) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 14) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 14) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 13) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 13) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 12) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 12) = (jbyte) c;
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->cipher_)) processBlockWithByteArray:self->counter_ withInt:0 withByteArray:block withInt:0];
}

void LibOrgBouncycastleCryptoModesGCMBlockCipher_checkStatus(LibOrgBouncycastleCryptoModesGCMBlockCipher *self) {
  if (!self->initialised_) {
    if (self->forEncryption_) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"GCM cipher cannot be reused for encryption");
    }
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"GCM cipher needs to be initialised");
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesGCMBlockCipher)

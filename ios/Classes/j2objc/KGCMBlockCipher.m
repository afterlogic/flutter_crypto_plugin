//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/modes/KGCMBlockCipher.java
//

#include "AEADParameters.h"
#include "Arrays.h"
#include "BlockCipher.h"
#include "BufferedBlockCipher.h"
#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "KCTRBlockCipher.h"
#include "KGCMBlockCipher.h"
#include "KGCMMultiplier.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "Pack.h"
#include "ParametersWithIV.h"
#include "Tables16kKGCMMultiplier_512.h"
#include "Tables4kKGCMMultiplier_128.h"
#include "Tables8kKGCMMultiplier_256.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@class LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream;

@interface LibOrgBouncycastleCryptoModesKGCMBlockCipher () {
 @public
  id<LibOrgBouncycastleCryptoBlockCipher> engine_;
  LibOrgBouncycastleCryptoBufferedBlockCipher *ctrEngine_;
  jint macSize_;
  jboolean forEncryption_;
  IOSByteArray *initialAssociatedText_;
  IOSByteArray *macBlock_;
  IOSByteArray *iv_;
  id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier> multiplier_;
  IOSLongArray *b_;
  jint blockSize_;
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *associatedText_;
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *data_;
}

+ (id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>)createDefaultMultiplierWithInt:(jint)blockSize;

- (void)processAADWithByteArray:(IOSByteArray *)authText
                        withInt:(jint)authOff
                        withInt:(jint)len;

- (void)calculateMacWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                          withInt:(jint)lenAAD;

+ (void)xorWithInputWithLongArray:(IOSLongArray *)z
                    withByteArray:(IOSByteArray *)buf
                          withInt:(jint)off;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, engine_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, ctrEngine_, LibOrgBouncycastleCryptoBufferedBlockCipher *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, iv_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, multiplier_, id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, b_, IOSLongArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, associatedText_, LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoModesKGCMBlockCipher, data_, LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *)

inline jint LibOrgBouncycastleCryptoModesKGCMBlockCipher_get_MIN_MAC_BITS(void);
#define LibOrgBouncycastleCryptoModesKGCMBlockCipher_MIN_MAC_BITS 64
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoModesKGCMBlockCipher, MIN_MAC_BITS, jint)

__attribute__((unused)) static id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier> LibOrgBouncycastleCryptoModesKGCMBlockCipher_createDefaultMultiplierWithInt_(jint blockSize);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKGCMBlockCipher_processAADWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKGCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, jint lenAAD);

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKGCMBlockCipher_xorWithInputWithLongArray_withByteArray_withInt_(IOSLongArray *z, IOSByteArray *buf, jint off);

@interface LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream : JavaIoByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher:(LibOrgBouncycastleCryptoModesKGCMBlockCipher *)outer$;

- (IOSByteArray *)getBuffer;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream)

__attribute__((unused)) static void LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$);

__attribute__((unused)) static LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$);

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream)

@implementation LibOrgBouncycastleCryptoModesKGCMBlockCipher

+ (id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>)createDefaultMultiplierWithInt:(jint)blockSize {
  return LibOrgBouncycastleCryptoModesKGCMBlockCipher_createDefaultMultiplierWithInt_(blockSize);
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)dstu7624Engine {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, dstu7624Engine);
  return self;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  LibOrgBouncycastleCryptoParamsKeyParameter *engineParam;
  if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]]) {
    LibOrgBouncycastleCryptoParamsAEADParameters *param = (LibOrgBouncycastleCryptoParamsAEADParameters *) params;
    IOSByteArray *iv = [((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    jint diff = ((IOSByteArray *) nil_chk(self->iv_))->size_ - ((IOSByteArray *) nil_chk(iv))->size_;
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->iv_, (jbyte) 0);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(iv, 0, self->iv_, diff, iv->size_);
    initialAssociatedText_ = [param getAssociatedText];
    jint macSizeBits = [param getMacSize];
    if (macSizeBits < LibOrgBouncycastleCryptoModesKGCMBlockCipher_MIN_MAC_BITS || macSizeBits > (JreLShift32(blockSize_, 3)) || (macSizeBits & 7) != 0) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Invalid value for MAC size: ", macSizeBits));
    }
    macSize_ = JreURShift32(macSizeBits, 3);
    engineParam = [param getKey];
    if (initialAssociatedText_ != nil) {
      [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
    }
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    LibOrgBouncycastleCryptoParamsParametersWithIV *param = (LibOrgBouncycastleCryptoParamsParametersWithIV *) params;
    IOSByteArray *iv = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    jint diff = ((IOSByteArray *) nil_chk(self->iv_))->size_ - ((IOSByteArray *) nil_chk(iv))->size_;
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(self->iv_, (jbyte) 0);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(iv, 0, self->iv_, diff, iv->size_);
    initialAssociatedText_ = nil;
    macSize_ = blockSize_;
    engineParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([param getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid parameter passed");
  }
  self->macBlock_ = [IOSByteArray newArrayWithLength:blockSize_];
  [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(ctrEngine_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(engineParam, self->iv_)];
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:engineParam];
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) getAlgorithmName], @"/KGCM");
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return engine_;
}

- (void)processAADByteWithByte:(jbyte)inArg {
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithInt:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithByteArray:inArg withInt:inOff withInt:len];
}

- (void)processAADWithByteArray:(IOSByteArray *)authText
                        withInt:(jint)authOff
                        withInt:(jint)len {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_processAADWithByteArray_withInt_withInt_(self, authText, authOff, len);
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithInt:inArg];
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)inLen
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + inLen)) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithByteArray:inArg withInt:inOff withInt:inLen];
  return 0;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  jint len = [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size];
  if (!forEncryption_ && len < macSize_) {
    @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
  }
  {
    IOSByteArray *temp = [IOSByteArray newArrayWithLength:blockSize_];
    [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:temp withInt:0 withByteArray:temp withInt:0];
    IOSLongArray *H = [IOSLongArray newArrayWithLength:JreURShift32(blockSize_, 3)];
    LibOrgBouncycastleUtilPack_littleEndianToLongWithByteArray_withInt_withLongArray_(temp, 0, H);
    [((id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>) nil_chk(multiplier_)) init__WithLongArray:H];
    LibOrgBouncycastleUtilArrays_fillWithByteArray_withByte_(temp, (jbyte) 0);
    LibOrgBouncycastleUtilArrays_fillWithLongArray_withLong_(H, 0LL);
  }
  jint lenAAD = [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size];
  if (lenAAD > 0) {
    LibOrgBouncycastleCryptoModesKGCMBlockCipher_processAADWithByteArray_withInt_withInt_(self, [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) getBuffer], 0, lenAAD);
  }
  jint resultLen;
  if (forEncryption_) {
    if (((IOSByteArray *) nil_chk(outArg))->size_ - outOff - macSize_ < len) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
    resultLen = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(ctrEngine_)) processBytesWithByteArray:[((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:len withByteArray:outArg withInt:outOff];
    resultLen += [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(ctrEngine_)) doFinalWithByteArray:outArg withInt:outOff + resultLen];
    LibOrgBouncycastleCryptoModesKGCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withInt_(self, outArg, outOff, len, lenAAD);
  }
  else {
    jint ctLen = len - macSize_;
    if (((IOSByteArray *) nil_chk(outArg))->size_ - outOff < ctLen) {
      @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
    LibOrgBouncycastleCryptoModesKGCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withInt_(self, [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer], 0, ctLen, lenAAD);
    resultLen = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(ctrEngine_)) processBytesWithByteArray:[((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:ctLen withByteArray:outArg withInt:outOff];
    resultLen += [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(ctrEngine_)) doFinalWithByteArray:outArg withInt:outOff + resultLen];
  }
  if (macBlock_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"mac is not calculated");
  }
  if (forEncryption_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, outArg, outOff + resultLen, macSize_);
    [self reset];
    return resultLen + macSize_;
  }
  else {
    IOSByteArray *mac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer], len - macSize_, mac, 0, macSize_);
    IOSByteArray *calculatedMac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, calculatedMac, 0, macSize_);
    if (!LibOrgBouncycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(mac, calculatedMac)) {
      @throw new_LibOrgBouncycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac verification failed");
    }
    [self reset];
    return resultLen;
  }
}

- (IOSByteArray *)getMac {
  IOSByteArray *mac = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac, 0, macSize_);
  return mac;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return 0;
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size];
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (void)reset {
  LibOrgBouncycastleUtilArrays_fillWithLongArray_withLong_(b_, 0LL);
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(engine_)) reset];
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) reset];
  [((LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) reset];
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (void)calculateMacWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                          withInt:(jint)lenAAD {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withInt_(self, input, inOff, len, lenAAD);
}

+ (void)xorWithInputWithLongArray:(IOSLongArray *)z
                    withByteArray:(IOSByteArray *)buf
                          withInt:(jint)off {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_xorWithInputWithLongArray_withByteArray_withInt_(z, buf, off);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LLibOrgBouncycastleCryptoModesKgcmKGCMMultiplier;", 0xa, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 10, 9, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 14, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, 18, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 19, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 20, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 23, 24, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(createDefaultMultiplierWithInt:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[2].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(getUnderlyingCipher);
  methods[5].selector = @selector(processAADByteWithByte:);
  methods[6].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[7].selector = @selector(processAADWithByteArray:withInt:withInt:);
  methods[8].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[9].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[10].selector = @selector(doFinalWithByteArray:withInt:);
  methods[11].selector = @selector(getMac);
  methods[12].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[13].selector = @selector(getOutputSizeWithInt:);
  methods[14].selector = @selector(reset);
  methods[15].selector = @selector(calculateMacWithByteArray:withInt:withInt:withInt:);
  methods[16].selector = @selector(xorWithInputWithLongArray:withByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "MIN_MAC_BITS", "I", .constantValue.asInt = LibOrgBouncycastleCryptoModesKGCMBlockCipher_MIN_MAC_BITS, 0x1a, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ctrEngine_", "LLibOrgBouncycastleCryptoBufferedBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "iv_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "multiplier_", "LLibOrgBouncycastleCryptoModesKgcmKGCMMultiplier;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "b_", "[J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blockSize_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "associatedText_", "LLibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "data_", "LLibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "createDefaultMultiplier", "I", "LLibOrgBouncycastleCryptoBlockCipher;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "processAADByte", "B", "processAADBytes", "[BII", "processAAD", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LLibOrgBouncycastleCryptoInvalidCipherTextException;", "getUpdateOutputSize", "getOutputSize", "calculateMac", "[BIII", "xorWithInput", "[J[BI", "LLibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesKGCMBlockCipher = { "KGCMBlockCipher", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 17, 13, -1, 25, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesKGCMBlockCipher;
}

@end

id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier> LibOrgBouncycastleCryptoModesKGCMBlockCipher_createDefaultMultiplierWithInt_(jint blockSize) {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_initialize();
  switch (blockSize) {
    case 16:
    return new_LibOrgBouncycastleCryptoModesKgcmTables4kKGCMMultiplier_128_init();
    case 32:
    return new_LibOrgBouncycastleCryptoModesKgcmTables8kKGCMMultiplier_256_init();
    case 64:
    return new_LibOrgBouncycastleCryptoModesKgcmTables16kKGCMMultiplier_512_init();
    default:
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Only 128, 256, and 512 -bit block sizes supported");
  }
}

void LibOrgBouncycastleCryptoModesKGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> dstu7624Engine) {
  NSObject_init(self);
  self->associatedText_ = new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(self);
  self->data_ = new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(self);
  self->engine_ = dstu7624Engine;
  self->ctrEngine_ = new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesKCTRBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self->engine_));
  self->macSize_ = -1;
  self->blockSize_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
  self->initialAssociatedText_ = [IOSByteArray newArrayWithLength:self->blockSize_];
  self->iv_ = [IOSByteArray newArrayWithLength:self->blockSize_];
  self->multiplier_ = LibOrgBouncycastleCryptoModesKGCMBlockCipher_createDefaultMultiplierWithInt_(self->blockSize_);
  self->b_ = [IOSLongArray newArrayWithLength:JreURShift32(self->blockSize_, 3)];
  self->macBlock_ = nil;
}

LibOrgBouncycastleCryptoModesKGCMBlockCipher *new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> dstu7624Engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesKGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, dstu7624Engine)
}

LibOrgBouncycastleCryptoModesKGCMBlockCipher *create_LibOrgBouncycastleCryptoModesKGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> dstu7624Engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesKGCMBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, dstu7624Engine)
}

void LibOrgBouncycastleCryptoModesKGCMBlockCipher_processAADWithByteArray_withInt_withInt_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len) {
  jint pos = authOff;
  jint end = authOff + len;
  while (pos < end) {
    LibOrgBouncycastleCryptoModesKGCMBlockCipher_xorWithInputWithLongArray_withByteArray_withInt_(self->b_, authText, pos);
    [((id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithLongArray:self->b_];
    pos += self->blockSize_;
  }
}

void LibOrgBouncycastleCryptoModesKGCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, jint lenAAD) {
  jint pos = inOff;
  jint end = inOff + len;
  while (pos < end) {
    LibOrgBouncycastleCryptoModesKGCMBlockCipher_xorWithInputWithLongArray_withByteArray_withInt_(self->b_, input, pos);
    [((id<LibOrgBouncycastleCryptoModesKgcmKGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithLongArray:self->b_];
    pos += self->blockSize_;
  }
  jlong lambda_o = JreLShift64((lenAAD & (jlong) 0xFFFFFFFFLL), 3);
  jlong lambda_c = JreLShift64((len & (jlong) 0xFFFFFFFFLL), 3);
  *IOSLongArray_GetRef(nil_chk(self->b_), 0) ^= lambda_o;
  *IOSLongArray_GetRef(self->b_, JreURShift32(self->blockSize_, 4)) ^= lambda_c;
  self->macBlock_ = LibOrgBouncycastleUtilPack_longToLittleEndianWithLongArray_(self->b_);
  [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
}

void LibOrgBouncycastleCryptoModesKGCMBlockCipher_xorWithInputWithLongArray_withByteArray_withInt_(IOSLongArray *z, IOSByteArray *buf, jint off) {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_initialize();
  for (jint i = 0; i < ((IOSLongArray *) nil_chk(z))->size_; ++i) {
    *IOSLongArray_GetRef(z, i) ^= LibOrgBouncycastleUtilPack_littleEndianToLongWithByteArray_withInt_(buf, off);
    off += 8;
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesKGCMBlockCipher)

@implementation LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream

- (instancetype)initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher:(LibOrgBouncycastleCryptoModesKGCMBlockCipher *)outer$ {
  LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(self, outer$);
  return self;
}

- (IOSByteArray *)getBuffer {
  return self->buf_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher:);
  methods[1].selector = @selector(getBuffer);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoModesKGCMBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream = { "ExposedByteArrayOutputStream", "lib.org.bouncycastle.crypto.modes", ptrTable, methods, NULL, 7, 0x2, 2, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream;
}

@end

void LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *self, LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$) {
  JavaIoByteArrayOutputStream_init(self);
}

LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_, outer$)
}

LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream *create_LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream_initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_(LibOrgBouncycastleCryptoModesKGCMBlockCipher *outer$) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream, initWithLibOrgBouncycastleCryptoModesKGCMBlockCipher_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoModesKGCMBlockCipher_ExposedByteArrayOutputStream)

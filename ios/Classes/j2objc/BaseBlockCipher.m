//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/symmetric/util/BaseBlockCipher.java
//

#include "AEADBlockCipher.h"
#include "AEADParameterSpec.h"
#include "AEADParameters.h"
#include "ASN1ObjectIdentifier.h"
#include "BCPBEKey.h"
#include "BaseBlockCipher.h"
#include "BaseWrapCipher.h"
#include "BlockCipher.h"
#include "BlockCipherPadding.h"
#include "BlockCipherProvider.h"
#include "BufferedBlockCipher.h"
#include "CBCBlockCipher.h"
#include "CCMBlockCipher.h"
#include "CFBBlockCipher.h"
#include "CTSBlockCipher.h"
#include "CipherParameters.h"
#include "ClassUtil.h"
#include "CryptoServicesRegistrar.h"
#include "DSTU7624Engine.h"
#include "DataLengthException.h"
#include "EAXBlockCipher.h"
#include "GCFBBlockCipher.h"
#include "GCMBlockCipher.h"
#include "GCMParameters.h"
#include "GOFBBlockCipher.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "ISO10126d2Padding.h"
#include "ISO7816d4Padding.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "JcajceGOST28147ParameterSpec.h"
#include "JcajceRepeatedSecretKeySpec.h"
#include "KCCMBlockCipher.h"
#include "KCTRBlockCipher.h"
#include "KGCMBlockCipher.h"
#include "KeyParameter.h"
#include "OCBBlockCipher.h"
#include "OFBBlockCipher.h"
#include "OpenPGPCFBBlockCipher.h"
#include "OutputLengthException.h"
#include "PBE.h"
#include "PBKDF1Key.h"
#include "PBKDF1KeyWithParameters.h"
#include "PGPCFBBlockCipher.h"
#include "PKCS12Key.h"
#include "PKCS12KeyWithParameters.h"
#include "PaddedBufferedBlockCipher.h"
#include "ParametersWithIV.h"
#include "ParametersWithRandom.h"
#include "ParametersWithSBox.h"
#include "RC2Parameters.h"
#include "RC5Parameters.h"
#include "SICBlockCipher.h"
#include "Strings.h"
#include "TBCPadding.h"
#include "X923Padding.h"
#include "ZeroBytePadding.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/lang/reflect/Constructor.h"
#include "java/lang/reflect/Method.h"
#include "java/nio/ByteBuffer.h"
#include "java/security/AlgorithmParameters.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/InvalidParameterException.h"
#include "java/security/Key.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/security/SecureRandom.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "javax/crypto/BadPaddingException.h"
#include "javax/crypto/Cipher.h"
#include "javax/crypto/IllegalBlockSizeException.h"
#include "javax/crypto/NoSuchPaddingException.h"
#include "javax/crypto/SecretKey.h"
#include "javax/crypto/ShortBufferException.h"
#include "javax/crypto/interfaces/PBEKey.h"
#include "javax/crypto/spec/IvParameterSpec.h"
#include "javax/crypto/spec/PBEParameterSpec.h"
#include "javax/crypto/spec/RC2ParameterSpec.h"
#include "javax/crypto/spec/RC5ParameterSpec.h"

@protocol LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher;

@interface LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher () {
 @public
  IOSObjectArray *availableSpecs_BaseBlockCipher_;
  id<LibOrgBouncycastleCryptoBlockCipher> baseEngine_;
  id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider> engineProvider_;
  id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher> cipher_;
  LibOrgBouncycastleCryptoParamsParametersWithIV *ivParam_;
  LibOrgBouncycastleCryptoParamsAEADParameters *aeadParams_;
  jint keySizeInBits_;
  jint scheme_;
  jint digest_;
  jint ivLength_;
  jboolean padded_;
  jboolean fixedIv_;
  JavaxCryptoSpecPBEParameterSpec *pbeSpec_;
  NSString *pbeAlgorithm_;
  NSString *modeName_;
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
                                                              withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)param;

- (jboolean)isAEADModeNameWithNSString:(NSString *)modeName;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, availableSpecs_BaseBlockCipher_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, baseEngine_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, engineProvider_, id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, cipher_, id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, ivParam_, LibOrgBouncycastleCryptoParamsParametersWithIV *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, aeadParams_, LibOrgBouncycastleCryptoParamsAEADParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, pbeSpec_, JavaxCryptoSpecPBEParameterSpec *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, pbeAlgorithm_, NSString *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, modeName_, NSString *)

inline IOSClass *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_get_gcmSpecClass(void);
static IOSClass *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, gcmSpecClass, IOSClass *)

__attribute__((unused)) static id<LibOrgBouncycastleCryptoCipherParameters> LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec_withLibOrgBouncycastleCryptoCipherParameters_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<JavaSecuritySpecAlgorithmParameterSpec> params, id<LibOrgBouncycastleCryptoCipherParameters> param);

__attribute__((unused)) static jboolean LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, NSString *modeName);

@protocol LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher < JavaObject >

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params OBJC_METHOD_FAMILY_NONE;

- (jboolean)wrapOnNoPadding;

- (NSString *)getAlgorithmName;

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher;

- (jint)getOutputSizeWithInt:(jint)len;

- (jint)getUpdateOutputSizeWithInt:(jint)len;

- (void)updateAADWithByteArray:(IOSByteArray *)input
                       withInt:(jint)offset
                       withInt:(jint)length;

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff;

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff;

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff;

@end

@interface LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher : NSObject

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher)

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher)

@interface LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher : NSObject < LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher > {
 @public
  LibOrgBouncycastleCryptoBufferedBlockCipher *cipher_;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBufferedBlockCipher:(LibOrgBouncycastleCryptoBufferedBlockCipher *)cipher;

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher;

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher
     withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding:(id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding>)padding;

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params OBJC_METHOD_FAMILY_NONE;

- (jboolean)wrapOnNoPadding;

- (NSString *)getAlgorithmName;

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher;

- (jint)getOutputSizeWithInt:(jint)len;

- (jint)getUpdateOutputSizeWithInt:(jint)len;

- (void)updateAADWithByteArray:(IOSByteArray *)input
                       withInt:(jint)offset
                       withInt:(jint)length;

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff;

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff;

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher)

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, cipher_, LibOrgBouncycastleCryptoBufferedBlockCipher *)

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, LibOrgBouncycastleCryptoBufferedBlockCipher *cipher);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleCryptoBufferedBlockCipher *cipher) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleCryptoBufferedBlockCipher *cipher);

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher);

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding);

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher)

@interface LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher : NSObject < LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher > {
 @public
  id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher_;
}

+ (JavaLangReflectConstructor *)findExceptionConstructorWithIOSClass:(IOSClass *)clazz;

- (instancetype)initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)cipher;

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params OBJC_METHOD_FAMILY_NONE;

- (NSString *)getAlgorithmName;

- (jboolean)wrapOnNoPadding;

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher;

- (jint)getOutputSizeWithInt:(jint)len;

- (jint)getUpdateOutputSizeWithInt:(jint)len;

- (void)updateAADWithByteArray:(IOSByteArray *)input
                       withInt:(jint)offset
                       withInt:(jint)length;

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff;

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff;

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff;

@end

J2OBJC_STATIC_INIT(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher)

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher, cipher_, id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)

inline JavaLangReflectConstructor *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_get_aeadBadTagConstructor(void);
static JavaLangReflectConstructor *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor;
J2OBJC_STATIC_FIELD_OBJ_FINAL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher, aeadBadTagConstructor, JavaLangReflectConstructor *)

__attribute__((unused)) static JavaLangReflectConstructor *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_findExceptionConstructorWithIOSClass_(IOSClass *clazz);

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *self, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher);

J2OBJC_TYPE_LITERAL_HEADER(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher)

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher)

@implementation LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, engine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine
                                                    withInt:(jint)scheme
                                                    withInt:(jint)digest
                                                    withInt:(jint)keySizeInBits
                                                    withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_(self, engine, scheme, digest, keySizeInBits, ivLength);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider:(id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider>)provider {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_(self, provider);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)engine {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(self, engine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)engine
                                                         withBoolean:(jboolean)fixedIv
                                                             withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_(self, engine, fixedIv, ivLength);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine
                                                    withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(self, engine, ivLength);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)engine
                                                withBoolean:(jboolean)fixedIv
                                                    withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_(self, engine, fixedIv, ivLength);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBufferedBlockCipher:(LibOrgBouncycastleCryptoBufferedBlockCipher *)engine
                                                            withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_(self, engine, ivLength);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBufferedBlockCipher:(LibOrgBouncycastleCryptoBufferedBlockCipher *)engine
                                                        withBoolean:(jboolean)fixedIv
                                                            withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_(self, engine, fixedIv, ivLength);
  return self;
}

- (jint)engineGetBlockSize {
  return [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
}

- (IOSByteArray *)engineGetIV {
  if (aeadParams_ != nil) {
    return [aeadParams_ getNonce];
  }
  return (ivParam_ != nil) ? [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParam_)) getIV] : nil;
}

- (jint)engineGetKeySizeWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  return ((IOSByteArray *) nil_chk([((id<JavaSecurityKey>) nil_chk(key)) getEncoded]))->size_ * 8;
}

- (jint)engineGetOutputSizeWithInt:(jint)inputLen {
  return [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getOutputSizeWithInt:inputLen];
}

- (JavaSecurityAlgorithmParameters *)engineGetParameters {
  if (engineParams_ == nil) {
    if (pbeSpec_ != nil) {
      @try {
        engineParams_ = [self createParametersInstanceWithNSString:pbeAlgorithm_];
        [((JavaSecurityAlgorithmParameters *) nil_chk(engineParams_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:pbeSpec_];
      }
      @catch (JavaLangException *e) {
        return nil;
      }
    }
    else if (aeadParams_ != nil) {
      @try {
        engineParams_ = [self createParametersInstanceWithNSString:@"GCM"];
        [((JavaSecurityAlgorithmParameters *) nil_chk(engineParams_)) init__WithByteArray:[new_LibOrgBouncycastleAsn1CmsGCMParameters_initWithByteArray_withInt_([((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(aeadParams_)) getNonce], [((LibOrgBouncycastleCryptoParamsAEADParameters *) nil_chk(aeadParams_)) getMacSize] / 8) getEncoded]];
      }
      @catch (JavaLangException *e) {
        @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
      }
    }
    else if (ivParam_ != nil) {
      NSString *name = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName];
      if ([((NSString *) nil_chk(name)) java_indexOf:'/'] >= 0) {
        name = [name java_substring:0 endIndex:[name java_indexOf:'/']];
      }
      @try {
        engineParams_ = [self createParametersInstanceWithNSString:name];
        [((JavaSecurityAlgorithmParameters *) nil_chk(engineParams_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:new_JavaxCryptoSpecIvParameterSpec_initWithByteArray_([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParam_)) getIV])];
      }
      @catch (JavaLangException *e) {
        @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
      }
    }
  }
  return engineParams_;
}

- (void)engineSetModeWithNSString:(NSString *)mode {
  modeName_ = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(mode);
  if ([((NSString *) nil_chk(modeName_)) isEqual:@"ECB"]) {
    ivLength_ = 0;
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_);
  }
  else if ([((NSString *) nil_chk(modeName_)) isEqual:@"CBC"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"OFB"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    if ([((NSString *) nil_chk(modeName_)) java_length] != 3) {
      jint wordSize = JavaLangInteger_parseIntWithNSString_([((NSString *) nil_chk(modeName_)) java_substring:3]);
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesOFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(baseEngine_, wordSize));
    }
    else {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesOFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(baseEngine_, 8 * [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize]));
    }
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"CFB"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    if ([((NSString *) nil_chk(modeName_)) java_length] != 3) {
      jint wordSize = JavaLangInteger_parseIntWithNSString_([((NSString *) nil_chk(modeName_)) java_substring:3]);
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(baseEngine_, wordSize));
    }
    else {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(baseEngine_, 8 * [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize]));
    }
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"PGP"]) {
    jboolean inlineIV = [((NSString *) nil_chk(modeName_)) java_equalsIgnoreCase:@"PGPCFBwithIV"];
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesPGPCFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_(baseEngine_, inlineIV));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_equalsIgnoreCase:@"OpenPGPCFB"]) {
    ivLength_ = 0;
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesOpenPGPCFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"SIC"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    if (ivLength_ < 16) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Warning: SIC-Mode can become a twotime-pad if the blocksize of the cipher is too small. Use a cipher with a block size of at least 128 bits (e.g. AES)");
    }
    fixedIv_ = false;
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesSICBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"CTR"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    fixedIv_ = false;
    if ([baseEngine_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesDSTU7624Engine class]]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesKCTRBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
    }
    else {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesSICBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
    }
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"GOFB"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesGOFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"GCFB"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesGCFBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"CTS"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoModesCTSBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_)));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"CCM"]) {
    ivLength_ = 12;
    if ([baseEngine_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesDSTU7624Engine class]]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesKCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
    }
    else {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesCCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
    }
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"OCB"]) {
    if (engineProvider_ != nil) {
      ivLength_ = 15;
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesOCBBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoBlockCipher_(baseEngine_, [engineProvider_ get]));
    }
    else {
      @throw new_JavaSecurityNoSuchAlgorithmException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
    }
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"EAX"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesEAXBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
  }
  else if ([((NSString *) nil_chk(modeName_)) java_hasPrefix:@"GCM"]) {
    ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getBlockSize];
    if ([baseEngine_ isKindOfClass:[LibOrgBouncycastleCryptoEnginesDSTU7624Engine class]]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesKGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
    }
    else {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(new_LibOrgBouncycastleCryptoModesGCMBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(baseEngine_));
    }
  }
  else {
    @throw new_JavaSecurityNoSuchAlgorithmException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
  }
}

- (void)engineSetPaddingWithNSString:(NSString *)padding {
  NSString *paddingName = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(padding);
  if ([((NSString *) nil_chk(paddingName)) isEqual:@"NOPADDING"]) {
    if ([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) wrapOnNoPadding]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher]));
    }
  }
  else if ([paddingName isEqual:@"WITHCTS"] || [paddingName isEqual:@"CTSPADDING"] || [paddingName isEqual:@"CS3PADDING"]) {
    cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoModesCTSBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher]));
  }
  else {
    padded_ = true;
    if (LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(self, modeName_)) {
      @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(@"Only NoPadding can be used with AEAD modes.");
    }
    else if ([paddingName isEqual:@"PKCS5PADDING"] || [paddingName isEqual:@"PKCS7PADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher]);
    }
    else if ([paddingName isEqual:@"ZEROBYTEPADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher], new_LibOrgBouncycastleCryptoPaddingsZeroBytePadding_init());
    }
    else if ([paddingName isEqual:@"ISO10126PADDING"] || [paddingName isEqual:@"ISO10126-2PADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher], new_LibOrgBouncycastleCryptoPaddingsISO10126d2Padding_init());
    }
    else if ([paddingName isEqual:@"X9.23PADDING"] || [paddingName isEqual:@"X923PADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher], new_LibOrgBouncycastleCryptoPaddingsX923Padding_init());
    }
    else if ([paddingName isEqual:@"ISO7816-4PADDING"] || [paddingName isEqual:@"ISO9797-1PADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher], new_LibOrgBouncycastleCryptoPaddingsISO7816d4Padding_init());
    }
    else if ([paddingName isEqual:@"TBCPADDING"]) {
      cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher], new_LibOrgBouncycastleCryptoPaddingsTBCPadding_init());
    }
    else {
      @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(JreStrcat("$$$", @"Padding ", padding, @" unknown."));
    }
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<LibOrgBouncycastleCryptoCipherParameters> param;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->engineParams_ = nil;
  self->aeadParams_ = nil;
  if (!([JavaxCryptoSecretKey_class_() isInstance:key])) {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_(JreStrcat("$$$", @"Key for algorithm ", ((key != nil) ? [((id<JavaSecurityKey>) nil_chk(key)) getAlgorithm] : nil), @" not suitable for symmetric enryption."));
  }
  if (params == nil && [((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getAlgorithmName])) java_hasPrefix:@"RC5-64"]) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"RC5 requires an RC5ParametersSpec to be passed in.");
  }
  if (scheme_ == LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12 || [key isKindOfClass:[LibOrgBouncycastleJcajcePKCS12Key class]]) {
    id<JavaxCryptoSecretKey> k;
    @try {
      k = (id<JavaxCryptoSecretKey>) cast_check(key, JavaxCryptoSecretKey_class_());
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"PKCS12 requires a SecretKey/PBEKey");
    }
    if ([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]]) {
      pbeSpec_ = (JavaxCryptoSpecPBEParameterSpec *) params;
    }
    if ([JavaxCryptoInterfacesPBEKey_class_() isInstance:k] && pbeSpec_ == nil) {
      id<JavaxCryptoInterfacesPBEKey> pbeKey = (id<JavaxCryptoInterfacesPBEKey>) cast_check(k, JavaxCryptoInterfacesPBEKey_class_());
      if ([((id<JavaxCryptoInterfacesPBEKey>) nil_chk(pbeKey)) getSalt] == nil) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"PBEKey requires parameters to specify salt");
      }
      pbeSpec_ = new_JavaxCryptoSpecPBEParameterSpec_initWithByteArray_withInt_([pbeKey getSalt], [pbeKey getIterationCount]);
    }
    if (pbeSpec_ == nil && !([JavaxCryptoInterfacesPBEKey_class_() isInstance:k])) {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"Algorithm requires a PBE key");
    }
    if ([key isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey class]]) {
      id<LibOrgBouncycastleCryptoCipherParameters> pbeKeyParam = [((LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *) nil_chk(((LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *) key))) getParam];
      if ([pbeKeyParam isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        param = pbeKeyParam;
      }
      else if (pbeKeyParam == nil) {
        param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEParametersWithByteArray_withInt_withInt_withInt_withInt_withJavaSecuritySpecAlgorithmParameterSpec_withNSString_([((id<JavaxCryptoSecretKey>) nil_chk(k)) getEncoded], LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12, digest_, keySizeInBits_, ivLength_ * 8, pbeSpec_, [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getAlgorithmName]);
      }
      else {
        @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"Algorithm requires a PBE key suitable for PKCS12");
      }
    }
    else {
      param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEParametersWithByteArray_withInt_withInt_withInt_withInt_withJavaSecuritySpecAlgorithmParameterSpec_withNSString_([((id<JavaxCryptoSecretKey>) nil_chk(k)) getEncoded], LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS12, digest_, keySizeInBits_, ivLength_ * 8, pbeSpec_, [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getAlgorithmName]);
    }
    if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) param;
    }
  }
  else if ([key isKindOfClass:[LibOrgBouncycastleJcajcePBKDF1Key class]]) {
    LibOrgBouncycastleJcajcePBKDF1Key *k = (LibOrgBouncycastleJcajcePBKDF1Key *) key;
    if ([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]]) {
      pbeSpec_ = (JavaxCryptoSpecPBEParameterSpec *) params;
    }
    if ([k isKindOfClass:[LibOrgBouncycastleJcajcePBKDF1KeyWithParameters class]] && pbeSpec_ == nil) {
      pbeSpec_ = new_JavaxCryptoSpecPBEParameterSpec_initWithByteArray_withInt_([((LibOrgBouncycastleJcajcePBKDF1KeyWithParameters *) nil_chk(((LibOrgBouncycastleJcajcePBKDF1KeyWithParameters *) cast_chk(k, [LibOrgBouncycastleJcajcePBKDF1KeyWithParameters class])))) getSalt], [((LibOrgBouncycastleJcajcePBKDF1KeyWithParameters *) nil_chk(((LibOrgBouncycastleJcajcePBKDF1KeyWithParameters *) cast_chk(k, [LibOrgBouncycastleJcajcePBKDF1KeyWithParameters class])))) getIterationCount]);
    }
    param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEParametersWithByteArray_withInt_withInt_withInt_withInt_withJavaSecuritySpecAlgorithmParameterSpec_withNSString_([((LibOrgBouncycastleJcajcePBKDF1Key *) nil_chk(k)) getEncoded], LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS5S1, digest_, keySizeInBits_, ivLength_ * 8, pbeSpec_, [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getAlgorithmName]);
    if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) param;
    }
  }
  else if ([key isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey class]]) {
    LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *k = (LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *) key;
    if ([((LibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey *) nil_chk(k)) getOID] != nil) {
      pbeAlgorithm_ = [((LibOrgBouncycastleAsn1ASN1ObjectIdentifier *) nil_chk([k getOID])) getId];
    }
    else {
      pbeAlgorithm_ = [k getAlgorithm];
    }
    if ([k getParam] != nil) {
      param = LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec_withLibOrgBouncycastleCryptoCipherParameters_(self, params, [k getParam]);
    }
    else if ([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]]) {
      pbeSpec_ = (JavaxCryptoSpecPBEParameterSpec *) params;
      param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEParametersWithLibOrgBouncycastleJcajceProviderSymmetricUtilBCPBEKey_withJavaSecuritySpecAlgorithmParameterSpec_withNSString_(k, params, [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName]);
    }
    else {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"PBE requires PBE parameters to be set.");
    }
    if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) param;
    }
  }
  else if ([JavaxCryptoInterfacesPBEKey_class_() isInstance:key]) {
    id<JavaxCryptoInterfacesPBEKey> k = (id<JavaxCryptoInterfacesPBEKey>) cast_check(key, JavaxCryptoInterfacesPBEKey_class_());
    pbeSpec_ = (JavaxCryptoSpecPBEParameterSpec *) cast_chk(params, [JavaxCryptoSpecPBEParameterSpec class]);
    if ([k isKindOfClass:[LibOrgBouncycastleJcajcePKCS12KeyWithParameters class]] && pbeSpec_ == nil) {
      pbeSpec_ = new_JavaxCryptoSpecPBEParameterSpec_initWithByteArray_withInt_([((id<JavaxCryptoInterfacesPBEKey>) nil_chk(k)) getSalt], [k getIterationCount]);
    }
    param = LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_Util_makePBEParametersWithByteArray_withInt_withInt_withInt_withInt_withJavaSecuritySpecAlgorithmParameterSpec_withNSString_([((id<JavaxCryptoInterfacesPBEKey>) nil_chk(k)) getEncoded], scheme_, digest_, keySizeInBits_, ivLength_ * 8, pbeSpec_, [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getAlgorithmName]);
    if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) param;
    }
  }
  else if (!([key isKindOfClass:[LibOrgBouncycastleJcajceSpecJcajceRepeatedSecretKeySpec class]])) {
    if (scheme_ == LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS5S1 || scheme_ == LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS5S1_UTF8 || scheme_ == LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS5S2 || scheme_ == LibOrgBouncycastleJcajceProviderSymmetricUtilPBE_PKCS5S2_UTF8) {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"Algorithm requires a PBE key");
    }
    param = new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_([((id<JavaSecurityKey>) nil_chk(key)) getEncoded]);
  }
  else {
    param = nil;
  }
  if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecAEADParameterSpec class]]) {
    if (!LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(self, modeName_) && !([cipher_ isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]])) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"AEADParameterSpec can only be used with AEAD modes.");
    }
    LibOrgBouncycastleJcajceSpecAEADParameterSpec *aeadSpec = (LibOrgBouncycastleJcajceSpecAEADParameterSpec *) params;
    LibOrgBouncycastleCryptoParamsKeyParameter *keyParam;
    if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
      keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) param))) getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]);
    }
    else {
      keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk(param, [LibOrgBouncycastleCryptoParamsKeyParameter class]);
    }
    param = aeadParams_ = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_withByteArray_(keyParam, [((LibOrgBouncycastleJcajceSpecAEADParameterSpec *) nil_chk(aeadSpec)) getMacSizeInBits], [aeadSpec getNonce], [aeadSpec getAssociatedData]);
  }
  else if ([params isKindOfClass:[JavaxCryptoSpecIvParameterSpec class]]) {
    if (ivLength_ != 0) {
      JavaxCryptoSpecIvParameterSpec *p = (JavaxCryptoSpecIvParameterSpec *) params;
      if (((IOSByteArray *) nil_chk([((JavaxCryptoSpecIvParameterSpec *) nil_chk(p)) getIV]))->size_ != ivLength_ && !([cipher_ isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]]) && fixedIv_) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$I$", @"IV must be ", ivLength_, @" bytes long."));
      }
      if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) param))) getParameters], [p getIV]);
      }
      else {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [p getIV]);
      }
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(param, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    }
    else {
      if (modeName_ != nil && [modeName_ isEqual:@"ECB"]) {
        @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"ECB mode does not use an IV");
      }
    }
  }
  else if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec class]]) {
    LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *gost28147Param = (LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) params;
    param = new_LibOrgBouncycastleCryptoParamsParametersWithSBox_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_([((id<JavaSecurityKey>) nil_chk(key)) getEncoded]), [((LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) nil_chk(((LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) params))) getSbox]);
    if ([((LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) nil_chk(gost28147Param)) getIV] != nil && ivLength_ != 0) {
      if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_([((LibOrgBouncycastleCryptoParamsParametersWithIV *) param) getParameters], [gost28147Param getIV]);
      }
      else {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [gost28147Param getIV]);
      }
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(param, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    }
  }
  else if ([params isKindOfClass:[JavaxCryptoSpecRC2ParameterSpec class]]) {
    JavaxCryptoSpecRC2ParameterSpec *rc2Param = (JavaxCryptoSpecRC2ParameterSpec *) params;
    param = new_LibOrgBouncycastleCryptoParamsRC2Parameters_initWithByteArray_withInt_([((id<JavaSecurityKey>) nil_chk(key)) getEncoded], [((JavaxCryptoSpecRC2ParameterSpec *) nil_chk(((JavaxCryptoSpecRC2ParameterSpec *) params))) getEffectiveKeyBits]);
    if ([((JavaxCryptoSpecRC2ParameterSpec *) nil_chk(rc2Param)) getIV] != nil && ivLength_ != 0) {
      if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_([((LibOrgBouncycastleCryptoParamsParametersWithIV *) param) getParameters], [rc2Param getIV]);
      }
      else {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [rc2Param getIV]);
      }
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(param, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    }
  }
  else if ([params isKindOfClass:[JavaxCryptoSpecRC5ParameterSpec class]]) {
    JavaxCryptoSpecRC5ParameterSpec *rc5Param = (JavaxCryptoSpecRC5ParameterSpec *) params;
    param = new_LibOrgBouncycastleCryptoParamsRC5Parameters_initWithByteArray_withInt_([((id<JavaSecurityKey>) nil_chk(key)) getEncoded], [((JavaxCryptoSpecRC5ParameterSpec *) nil_chk(((JavaxCryptoSpecRC5ParameterSpec *) params))) getRounds]);
    if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getAlgorithmName])) java_hasPrefix:@"RC5"]) {
      if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getAlgorithmName])) isEqual:@"RC5-32"]) {
        if ([((JavaxCryptoSpecRC5ParameterSpec *) nil_chk(rc5Param)) getWordSize] != 32) {
          @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$IC", @"RC5 already set up for a word size of 32 not ", [rc5Param getWordSize], '.'));
        }
      }
      else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(baseEngine_)) getAlgorithmName])) isEqual:@"RC5-64"]) {
        if ([((JavaxCryptoSpecRC5ParameterSpec *) nil_chk(rc5Param)) getWordSize] != 64) {
          @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$IC", @"RC5 already set up for a word size of 64 not ", [rc5Param getWordSize], '.'));
        }
      }
    }
    else {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"RC5 parameters passed to a cipher that is not RC5.");
    }
    if (([((JavaxCryptoSpecRC5ParameterSpec *) nil_chk(rc5Param)) getIV] != nil) && (ivLength_ != 0)) {
      if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_([((LibOrgBouncycastleCryptoParamsParametersWithIV *) param) getParameters], [rc5Param getIV]);
      }
      else {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [rc5Param getIV]);
      }
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(param, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    }
  }
  else if (LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass != nil && [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass isInstance:params]) {
    if (!LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(self, modeName_) && !([cipher_ isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]])) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"GCMParameterSpec can only be used with AEAD modes.");
    }
    @try {
      JavaLangReflectMethod *tLen = [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass getDeclaredMethod:@"getTLen" parameterTypes:[IOSObjectArray newArrayWithLength:0 type:IOSClass_class_()]];
      JavaLangReflectMethod *iv = [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass getDeclaredMethod:@"getIV" parameterTypes:[IOSObjectArray newArrayWithLength:0 type:IOSClass_class_()]];
      LibOrgBouncycastleCryptoParamsKeyParameter *keyParam;
      if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
        keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) param))) getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]);
      }
      else {
        keyParam = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk(param, [LibOrgBouncycastleCryptoParamsKeyParameter class]);
      }
      param = aeadParams_ = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_(keyParam, [((JavaLangInteger *) nil_chk(((JavaLangInteger *) cast_chk([((JavaLangReflectMethod *) nil_chk(tLen)) invokeWithId:params withNSObjectArray:[IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]], [JavaLangInteger class])))) intValue], (IOSByteArray *) cast_chk([((JavaLangReflectMethod *) nil_chk(iv)) invokeWithId:params withNSObjectArray:[IOSObjectArray newArrayWithLength:0 type:NSObject_class_()]], [IOSByteArray class]));
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"Cannot process GCMParameterSpec.");
    }
  }
  else if (params != nil && !([params isKindOfClass:[JavaxCryptoSpecPBEParameterSpec class]])) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"unknown parameter type.");
  }
  if ((ivLength_ != 0) && !([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) && !([param isKindOfClass:[LibOrgBouncycastleCryptoParamsAEADParameters class]])) {
    JavaSecuritySecureRandom *ivRandom = random;
    if (ivRandom == nil) {
      ivRandom = LibOrgBouncycastleCryptoCryptoServicesRegistrar_getSecureRandom();
    }
    if ((opmode == JavaxCryptoCipher_ENCRYPT_MODE) || (opmode == JavaxCryptoCipher_WRAP_MODE)) {
      IOSByteArray *iv = [IOSByteArray newArrayWithLength:ivLength_];
      [((JavaSecuritySecureRandom *) nil_chk(ivRandom)) nextBytesWithByteArray:iv];
      param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, iv);
      ivParam_ = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(param, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    }
    else if ([((NSString *) nil_chk([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName])) java_indexOfString:@"PGPCFB"] < 0) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"no IV set when one expected");
    }
  }
  if (random != nil && padded_) {
    param = new_LibOrgBouncycastleCryptoParamsParametersWithRandom_initWithLibOrgBouncycastleCryptoCipherParameters_withJavaSecuritySecureRandom_(param, random);
  }
  @try {
    switch (opmode) {
      case JavaxCryptoCipher_ENCRYPT_MODE:
      case JavaxCryptoCipher_WRAP_MODE:
      [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:param];
      break;
      case JavaxCryptoCipher_DECRYPT_MODE:
      case JavaxCryptoCipher_UNWRAP_MODE:
      [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:param];
      break;
      default:
      @throw new_JavaSecurityInvalidParameterException_initWithNSString_(JreStrcat("$I$", @"unknown opmode ", opmode, @" passed"));
    }
    if ([cipher_ isKindOfClass:[LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]] && aeadParams_ == nil) {
      id<LibOrgBouncycastleCryptoModesAEADBlockCipher> aeadCipher = ((LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *) nil_chk(((LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *) cast_chk(cipher_, [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]))))->cipher_;
      aeadParams_ = new_LibOrgBouncycastleCryptoParamsAEADParameters_initWithLibOrgBouncycastleCryptoParamsKeyParameter_withInt_withByteArray_((LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk([((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParam_)) getParameters], [LibOrgBouncycastleCryptoParamsKeyParameter class]), ((IOSByteArray *) nil_chk([((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(aeadCipher)) getMac]))->size_ * 8, [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParam_)) getIV]);
    }
  }
  @catch (JavaLangException *e) {
    @throw new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_InvalidKeyOrParametersException_initWithNSString_withJavaLangThrowable_([e getMessage], e);
  }
}

- (id<LibOrgBouncycastleCryptoCipherParameters>)adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
                                                              withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)param {
  return LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec_withLibOrgBouncycastleCryptoCipherParameters_(self, params, param);
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec = nil;
  if (params != nil) {
    for (jint i = 0; i != ((IOSObjectArray *) nil_chk(availableSpecs_BaseBlockCipher_))->size_; i++) {
      if (IOSObjectArray_Get(availableSpecs_BaseBlockCipher_, i) == nil) {
        continue;
      }
      @try {
        paramSpec = [params getParameterSpecWithIOSClass:IOSObjectArray_Get(availableSpecs_BaseBlockCipher_, i)];
        break;
      }
      @catch (JavaLangException *e) {
      }
    }
    if (paramSpec == nil) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"can't handle parameter ", [params description]));
    }
  }
  [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:paramSpec withJavaSecuritySecureRandom:random];
  engineParams_ = params;
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @try {
    [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:nil withJavaSecuritySecureRandom:random];
  }
  @catch (JavaSecurityInvalidAlgorithmParameterException *e) {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_([e getMessage]);
  }
}

- (void)engineUpdateAADWithByteArray:(IOSByteArray *)input
                             withInt:(jint)offset
                             withInt:(jint)length {
  [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) updateAADWithByteArray:input withInt:offset withInt:length];
}

- (void)engineUpdateAADWithJavaNioByteBuffer:(JavaNioByteBuffer *)bytebuffer {
  jint offset = [((JavaNioByteBuffer *) nil_chk(bytebuffer)) arrayOffset] + [bytebuffer position];
  jint length = [bytebuffer limit] - [bytebuffer position];
  [self engineUpdateAADWithByteArray:[bytebuffer array] withInt:offset withInt:length];
}

- (IOSByteArray *)engineUpdateWithByteArray:(IOSByteArray *)input
                                    withInt:(jint)inputOffset
                                    withInt:(jint)inputLen {
  jint length = [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUpdateOutputSizeWithInt:inputLen];
  if (length > 0) {
    IOSByteArray *out = [IOSByteArray newArrayWithLength:length];
    jint len = [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:input withInt:inputOffset withInt:inputLen withByteArray:out withInt:0];
    if (len == 0) {
      return nil;
    }
    else if (len != out->size_) {
      IOSByteArray *tmp = [IOSByteArray newArrayWithLength:len];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(out, 0, tmp, 0, len);
      return tmp;
    }
    return out;
  }
  [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:input withInt:inputOffset withInt:inputLen withByteArray:nil withInt:0];
  return nil;
}

- (jint)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inputOffset
                          withInt:(jint)inputLen
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outputOffset {
  if (outputOffset + [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) getUpdateOutputSizeWithInt:inputLen] > ((IOSByteArray *) nil_chk(output))->size_) {
    @throw new_JavaxCryptoShortBufferException_initWithNSString_(@"output buffer too short for input.");
  }
  @try {
    return [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:input withInt:inputOffset withInt:inputLen withByteArray:output withInt:outputOffset];
  }
  @catch (LibOrgBouncycastleCryptoDataLengthException *e) {
    @throw new_JavaLangIllegalStateException_initWithNSString_([e description]);
  }
}

- (IOSByteArray *)engineDoFinalWithByteArray:(IOSByteArray *)input
                                     withInt:(jint)inputOffset
                                     withInt:(jint)inputLen {
  jint len = 0;
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:[self engineGetOutputSizeWithInt:inputLen]];
  if (inputLen != 0) {
    len = [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:input withInt:inputOffset withInt:inputLen withByteArray:tmp withInt:0];
  }
  @try {
    len += [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) doFinalWithByteArray:tmp withInt:len];
  }
  @catch (LibOrgBouncycastleCryptoDataLengthException *e) {
    @throw new_JavaxCryptoIllegalBlockSizeException_initWithNSString_([e getMessage]);
  }
  if (len == tmp->size_) {
    return tmp;
  }
  IOSByteArray *out = [IOSByteArray newArrayWithLength:len];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, out, 0, len);
  return out;
}

- (jint)engineDoFinalWithByteArray:(IOSByteArray *)input
                           withInt:(jint)inputOffset
                           withInt:(jint)inputLen
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outputOffset {
  jint len = 0;
  if (outputOffset + [self engineGetOutputSizeWithInt:inputLen] > ((IOSByteArray *) nil_chk(output))->size_) {
    @throw new_JavaxCryptoShortBufferException_initWithNSString_(@"output buffer too short for input.");
  }
  @try {
    if (inputLen != 0) {
      len = [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:input withInt:inputOffset withInt:inputLen withByteArray:output withInt:outputOffset];
    }
    return (len + [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher>) nil_chk(cipher_)) doFinalWithByteArray:output withInt:outputOffset + len]);
  }
  @catch (LibOrgBouncycastleCryptoOutputLengthException *e) {
    @throw new_JavaxCryptoIllegalBlockSizeException_initWithNSString_([e getMessage]);
  }
  @catch (LibOrgBouncycastleCryptoDataLengthException *e) {
    @throw new_JavaxCryptoIllegalBlockSizeException_initWithNSString_([e getMessage]);
  }
}

- (jboolean)isAEADModeNameWithNSString:(NSString *)modeName {
  return LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(self, modeName);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 3, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 4, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 5, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 6, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 7, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 8, -1, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 9, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 11, 12, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityAlgorithmParameters;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 13, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x4, 16, 14, 17, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 19, 20, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoCipherParameters;", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 23, 20, -1, -1, -1 },
    { NULL, "V", 0x4, 18, 24, 25, -1, -1, -1 },
    { NULL, "V", 0x4, 26, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 26, 28, -1, -1, -1, -1 },
    { NULL, "[B", 0x4, 29, 27, -1, -1, -1, -1 },
    { NULL, "I", 0x4, 29, 30, 31, -1, -1, -1 },
    { NULL, "[B", 0x4, 32, 27, 33, -1, -1, -1 },
    { NULL, "I", 0x4, 32, 30, 34, -1, -1, -1 },
    { NULL, "Z", 0x2, 35, 14, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withInt:withInt:withInt:withInt:);
  methods[2].selector = @selector(initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider:);
  methods[3].selector = @selector(initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:);
  methods[4].selector = @selector(initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:withBoolean:withInt:);
  methods[5].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withInt:);
  methods[6].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withBoolean:withInt:);
  methods[7].selector = @selector(initWithLibOrgBouncycastleCryptoBufferedBlockCipher:withInt:);
  methods[8].selector = @selector(initWithLibOrgBouncycastleCryptoBufferedBlockCipher:withBoolean:withInt:);
  methods[9].selector = @selector(engineGetBlockSize);
  methods[10].selector = @selector(engineGetIV);
  methods[11].selector = @selector(engineGetKeySizeWithJavaSecurityKey:);
  methods[12].selector = @selector(engineGetOutputSizeWithInt:);
  methods[13].selector = @selector(engineGetParameters);
  methods[14].selector = @selector(engineSetModeWithNSString:);
  methods[15].selector = @selector(engineSetPaddingWithNSString:);
  methods[16].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:withJavaSecuritySecureRandom:);
  methods[17].selector = @selector(adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[18].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecurityAlgorithmParameters:withJavaSecuritySecureRandom:);
  methods[19].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySecureRandom:);
  methods[20].selector = @selector(engineUpdateAADWithByteArray:withInt:withInt:);
  methods[21].selector = @selector(engineUpdateAADWithJavaNioByteBuffer:);
  methods[22].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[23].selector = @selector(engineUpdateWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[24].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:);
  methods[25].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[26].selector = @selector(isAEADModeNameWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "gcmSpecClass", "LIOSClass;", .constantValue.asLong = 0, 0x1a, -1, 36, -1, -1 },
    { "availableSpecs_BaseBlockCipher_", "[LIOSClass;", .constantValue.asLong = 0, 0x2, 37, -1, -1, -1 },
    { "baseEngine_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineProvider_", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ivParam_", "LLibOrgBouncycastleCryptoParamsParametersWithIV;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "aeadParams_", "LLibOrgBouncycastleCryptoParamsAEADParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "keySizeInBits_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scheme_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "digest_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ivLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "padded_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "fixedIv_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pbeSpec_", "LJavaxCryptoSpecPBEParameterSpec;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pbeAlgorithm_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "modeName_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;", "LLibOrgBouncycastleCryptoBlockCipher;IIII", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider;", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;ZI", "LLibOrgBouncycastleCryptoBlockCipher;I", "LLibOrgBouncycastleCryptoBlockCipher;ZI", "LLibOrgBouncycastleCryptoBufferedBlockCipher;I", "LLibOrgBouncycastleCryptoBufferedBlockCipher;ZI", "engineGetKeySize", "LJavaSecurityKey;", "engineGetOutputSize", "I", "engineSetMode", "LNSString;", "LJavaSecurityNoSuchAlgorithmException;", "engineSetPadding", "LJavaxCryptoNoSuchPaddingException;", "engineInit", "ILJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "adjustParameters", "LJavaSecuritySpecAlgorithmParameterSpec;LLibOrgBouncycastleCryptoCipherParameters;", "ILJavaSecurityKey;LJavaSecurityAlgorithmParameters;LJavaSecuritySecureRandom;", "ILJavaSecurityKey;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;", "engineUpdateAAD", "[BII", "LJavaNioByteBuffer;", "engineUpdate", "[BII[BI", "LJavaxCryptoShortBufferException;", "engineDoFinal", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;LJavaxCryptoShortBufferException;", "isAEADModeName", &LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, "availableSpecs", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher;LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher;LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher = { "BaseBlockCipher", "lib.org.bouncycastle.jcajce.provider.symmetric.util", ptrTable, methods, fields, 7, 0x1, 27, 16, -1, 38, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher class]) {
    LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass = LibOrgBouncycastleJcajceProviderSymmetricUtilClassUtil_loadClassWithIOSClass_withNSString_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_class_(), @"javax.crypto.spec.GCMParameterSpec");
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher)
  }
}

@end

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = engine;
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(engine);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, engine)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, engine)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine, jint scheme, jint digest, jint keySizeInBits, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = engine;
  self->scheme_ = scheme;
  self->digest_ = digest;
  self->keySizeInBits_ = keySizeInBits;
  self->ivLength_ = ivLength;
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(engine);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint scheme, jint digest, jint keySizeInBits, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_, engine, scheme, digest, keySizeInBits, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint scheme, jint digest, jint keySizeInBits, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_withInt_withInt_withInt_, engine, scheme, digest, keySizeInBits, ivLength)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider> provider) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = [((id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider>) nil_chk(provider)) get];
  self->engineProvider_ = provider;
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_([provider get]);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_(id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider> provider) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_, provider)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_(id<LibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider> provider) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleJcajceProviderSymmetricUtilBlockCipherProvider_, provider)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(engine)) getUnderlyingCipher];
  self->ivLength_ = [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(self->baseEngine_)) getBlockSize];
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(engine);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_, engine)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_, engine)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(engine)) getUnderlyingCipher];
  self->fixedIv_ = fixedIv;
  self->ivLength_ = ivLength;
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(engine);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_(self, engine, true, ivLength);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, engine, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withInt_, engine, ivLength)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = engine;
  self->fixedIv_ = fixedIv;
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(engine);
  self->ivLength_ = ivLength / 8;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_(id<LibOrgBouncycastleCryptoBlockCipher> engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_(self, engine, true, ivLength);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_(LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_, engine, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_(LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withInt_, engine, ivLength)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jboolean fixedIv, jint ivLength) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseWrapCipher_init(self);
  self->availableSpecs_BaseBlockCipher_ = [IOSObjectArray newArrayWithObjects:(id[]){ JavaxCryptoSpecRC2ParameterSpec_class_(), JavaxCryptoSpecRC5ParameterSpec_class_(), LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_gcmSpecClass, LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec_class_(), JavaxCryptoSpecIvParameterSpec_class_(), JavaxCryptoSpecPBEParameterSpec_class_() } count:6 type:IOSClass_class_()];
  self->scheme_ = -1;
  self->ivLength_ = 0;
  self->fixedIv_ = true;
  self->pbeSpec_ = nil;
  self->pbeAlgorithm_ = nil;
  self->modeName_ = nil;
  self->baseEngine_ = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(engine)) getUnderlyingCipher];
  self->cipher_ = new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(engine);
  self->fixedIv_ = fixedIv;
  self->ivLength_ = ivLength / 8;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_(LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_(LibOrgBouncycastleCryptoBufferedBlockCipher *engine, jboolean fixedIv, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_withBoolean_withInt_, engine, fixedIv, ivLength)
}

id<LibOrgBouncycastleCryptoCipherParameters> LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_adjustParametersWithJavaSecuritySpecAlgorithmParameterSpec_withLibOrgBouncycastleCryptoCipherParameters_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, id<JavaSecuritySpecAlgorithmParameterSpec> params, id<LibOrgBouncycastleCryptoCipherParameters> param) {
  id<LibOrgBouncycastleCryptoCipherParameters> key;
  if ([param isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]]) {
    key = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(((LibOrgBouncycastleCryptoParamsParametersWithIV *) param))) getParameters];
    if ([params isKindOfClass:[JavaxCryptoSpecIvParameterSpec class]]) {
      JavaxCryptoSpecIvParameterSpec *iv = (JavaxCryptoSpecIvParameterSpec *) params;
      self->ivParam_ = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(key, [((JavaxCryptoSpecIvParameterSpec *) nil_chk(iv)) getIV]);
      param = self->ivParam_;
    }
    else if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec class]]) {
      LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *gost28147Param = (LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) params;
      param = new_LibOrgBouncycastleCryptoParamsParametersWithSBox_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [((LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) nil_chk(gost28147Param)) getSbox]);
      if ([gost28147Param getIV] != nil && self->ivLength_ != 0) {
        self->ivParam_ = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(key, [gost28147Param getIV]);
        param = self->ivParam_;
      }
    }
  }
  else {
    if ([params isKindOfClass:[JavaxCryptoSpecIvParameterSpec class]]) {
      JavaxCryptoSpecIvParameterSpec *iv = (JavaxCryptoSpecIvParameterSpec *) params;
      self->ivParam_ = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [((JavaxCryptoSpecIvParameterSpec *) nil_chk(iv)) getIV]);
      param = self->ivParam_;
    }
    else if ([params isKindOfClass:[LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec class]]) {
      LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *gost28147Param = (LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) params;
      param = new_LibOrgBouncycastleCryptoParamsParametersWithSBox_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [((LibOrgBouncycastleJcajceSpecJcajceGOST28147ParameterSpec *) nil_chk(gost28147Param)) getSbox]);
      if ([gost28147Param getIV] != nil && self->ivLength_ != 0) {
        param = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(param, [gost28147Param getIV]);
      }
    }
  }
  return param;
}

jboolean LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_isAEADModeNameWithNSString_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher *self, NSString *modeName) {
  return [@"CCM" isEqual:modeName] || [@"EAX" isEqual:modeName] || [@"GCM" isEqual:modeName] || [@"OCB" isEqual:modeName];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher)

@implementation LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x401, 0, 1, 2, -1, -1, -1 },
    { NULL, "Z", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x401, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x401, 5, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x401, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x401, 8, 9, 10, -1, -1, -1 },
    { NULL, "I", 0x401, 11, 12, 10, -1, -1, -1 },
    { NULL, "I", 0x401, 13, 14, 15, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[1].selector = @selector(wrapOnNoPadding);
  methods[2].selector = @selector(getAlgorithmName);
  methods[3].selector = @selector(getUnderlyingCipher);
  methods[4].selector = @selector(getOutputSizeWithInt:);
  methods[5].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[6].selector = @selector(updateAADWithByteArray:withInt:withInt:);
  methods[7].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[8].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[9].selector = @selector(doFinalWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "getOutputSize", "I", "getUpdateOutputSize", "updateAAD", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LJavaxCryptoBadPaddingException;", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher = { "GenericBlockCipher", "lib.org.bouncycastle.jcajce.provider.symmetric.util", ptrTable, methods, NULL, 7, 0x60a, 10, 0, 16, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_GenericBlockCipher)

@implementation LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher

- (instancetype)initWithLibOrgBouncycastleCryptoBufferedBlockCipher:(LibOrgBouncycastleCryptoBufferedBlockCipher *)cipher {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(self, cipher);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(self, cipher);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher
     withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding:(id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding>)padding {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(self, cipher, padding);
  return self;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) init__WithBoolean:forEncryption withLibOrgBouncycastleCryptoCipherParameters:params];
}

- (jboolean)wrapOnNoPadding {
  return !([cipher_ isKindOfClass:[LibOrgBouncycastleCryptoModesCTSBlockCipher class]]);
}

- (NSString *)getAlgorithmName {
  return [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName];
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) getUnderlyingCipher];
}

- (jint)getOutputSizeWithInt:(jint)len {
  return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) getOutputSizeWithInt:len];
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) getUpdateOutputSizeWithInt:len];
}

- (void)updateAADWithByteArray:(IOSByteArray *)input
                       withInt:(jint)offset
                       withInt:(jint)length {
  @throw new_JavaLangUnsupportedOperationException_initWithNSString_(@"AAD is not supported in the current mode.");
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) processByteWithByte:inArg withByteArray:outArg withInt:outOff];
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) processBytesWithByteArray:inArg withInt:inOff withInt:len withByteArray:outArg withInt:outOff];
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  @try {
    return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk(cipher_)) doFinalWithByteArray:outArg withInt:outOff];
  }
  @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
    @throw new_JavaxCryptoBadPaddingException_initWithNSString_([e getMessage]);
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 14, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, 18, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoBufferedBlockCipher:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[2].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding:);
  methods[3].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[4].selector = @selector(wrapOnNoPadding);
  methods[5].selector = @selector(getAlgorithmName);
  methods[6].selector = @selector(getUnderlyingCipher);
  methods[7].selector = @selector(getOutputSizeWithInt:);
  methods[8].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[9].selector = @selector(updateAADWithByteArray:withInt:withInt:);
  methods[10].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[11].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[12].selector = @selector(doFinalWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cipher_", "LLibOrgBouncycastleCryptoBufferedBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBufferedBlockCipher;", "LLibOrgBouncycastleCryptoBlockCipher;", "LLibOrgBouncycastleCryptoBlockCipher;LLibOrgBouncycastleCryptoPaddingsBlockCipherPadding;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "getOutputSize", "I", "getUpdateOutputSize", "updateAAD", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LJavaxCryptoBadPaddingException;", "LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher = { "BufferedGenericBlockCipher", "lib.org.bouncycastle.jcajce.provider.symmetric.util", ptrTable, methods, fields, 7, 0xa, 13, 1, 19, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher;
}

@end

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, LibOrgBouncycastleCryptoBufferedBlockCipher *cipher) {
  NSObject_init(self);
  self->cipher_ = cipher;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleCryptoBufferedBlockCipher *cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_, cipher)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBufferedBlockCipher_(LibOrgBouncycastleCryptoBufferedBlockCipher *cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBufferedBlockCipher_, cipher)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  NSObject_init(self);
  self->cipher_ = new_LibOrgBouncycastleCryptoPaddingsPaddedBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(cipher);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding) {
  NSObject_init(self);
  self->cipher_ = new_LibOrgBouncycastleCryptoPaddingsPaddedBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(cipher, padding);
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_, cipher, padding)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_(id<LibOrgBouncycastleCryptoBlockCipher> cipher, id<LibOrgBouncycastleCryptoPaddingsBlockCipherPadding> padding) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher, initWithLibOrgBouncycastleCryptoBlockCipher_withLibOrgBouncycastleCryptoPaddingsBlockCipherPadding_, cipher, padding)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_BufferedGenericBlockCipher)

J2OBJC_INITIALIZED_DEFN(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher)

@implementation LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher

+ (JavaLangReflectConstructor *)findExceptionConstructorWithIOSClass:(IOSClass *)clazz {
  return LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_findExceptionConstructorWithIOSClass_(clazz);
}

- (instancetype)initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:(id<LibOrgBouncycastleCryptoModesAEADBlockCipher>)cipher {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(self, cipher);
  return self;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) init__WithBoolean:forEncryption withLibOrgBouncycastleCryptoCipherParameters:params];
}

- (NSString *)getAlgorithmName {
  return [((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk([((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher])) getAlgorithmName];
}

- (jboolean)wrapOnNoPadding {
  return false;
}

- (id<LibOrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher {
  return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) getUnderlyingCipher];
}

- (jint)getOutputSizeWithInt:(jint)len {
  return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) getOutputSizeWithInt:len];
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) getUpdateOutputSizeWithInt:len];
}

- (void)updateAADWithByteArray:(IOSByteArray *)input
                       withInt:(jint)offset
                       withInt:(jint)length {
  [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) processAADBytesWithByteArray:input withInt:offset withInt:length];
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) processByteWithByte:inArg withByteArray:outArg withInt:outOff];
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) processBytesWithByteArray:inArg withInt:inOff withInt:len withByteArray:outArg withInt:outOff];
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  @try {
    return [((id<LibOrgBouncycastleCryptoModesAEADBlockCipher>) nil_chk(cipher_)) doFinalWithByteArray:outArg withInt:outOff];
  }
  @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
    if (LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor != nil) {
      JavaxCryptoBadPaddingException *aeadBadTag = nil;
      @try {
        aeadBadTag = (JavaxCryptoBadPaddingException *) cast_chk([LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor newInstanceWithNSObjectArray:[IOSObjectArray newArrayWithObjects:(id[]){ [e getMessage] } count:1 type:NSObject_class_()]], [JavaxCryptoBadPaddingException class]);
      }
      @catch (JavaLangException *i) {
      }
      if (aeadBadTag != nil) {
        @throw aeadBadTag;
      }
    }
    @throw new_JavaxCryptoBadPaddingException_initWithNSString_([e getMessage]);
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LJavaLangReflectConstructor;", 0xa, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 14, 15, 13, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, 18, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(findExceptionConstructorWithIOSClass:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoModesAEADBlockCipher:);
  methods[2].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(wrapOnNoPadding);
  methods[5].selector = @selector(getUnderlyingCipher);
  methods[6].selector = @selector(getOutputSizeWithInt:);
  methods[7].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[8].selector = @selector(updateAADWithByteArray:withInt:withInt:);
  methods[9].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[10].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[11].selector = @selector(doFinalWithByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "aeadBadTagConstructor", "LJavaLangReflectConstructor;", .constantValue.asLong = 0, 0x1a, -1, 19, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "findExceptionConstructor", "LIOSClass;", "LLibOrgBouncycastleCryptoModesAEADBlockCipher;", "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "getOutputSize", "I", "getUpdateOutputSize", "updateAAD", "[BII", "processByte", "B[BI", "LLibOrgBouncycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LJavaxCryptoBadPaddingException;", &LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor, "LLibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher = { "AEADGenericBlockCipher", "lib.org.bouncycastle.jcajce.provider.symmetric.util", ptrTable, methods, fields, 7, 0xa, 12, 2, 20, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher;
}

+ (void)initialize {
  if (self == [LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher class]) {
    {
      IOSClass *aeadBadTagClass = LibOrgBouncycastleJcajceProviderSymmetricUtilClassUtil_loadClassWithIOSClass_withNSString_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_class_(), @"javax.crypto.AEADBadTagException");
      if (aeadBadTagClass != nil) {
        LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor = LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_findExceptionConstructorWithIOSClass_(aeadBadTagClass);
      }
      else {
        LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_aeadBadTagConstructor = nil;
      }
    }
    J2OBJC_SET_INITIALIZED(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher)
  }
}

@end

JavaLangReflectConstructor *LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_findExceptionConstructorWithIOSClass_(IOSClass *clazz) {
  LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initialize();
  @try {
    return [((IOSClass *) nil_chk(clazz)) getConstructor:[IOSObjectArray newArrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangException *e) {
    return nil;
  }
}

void LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *self, id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher) {
  NSObject_init(self);
  self->cipher_ = cipher;
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *new_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_, cipher)
}

LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher *create_LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher_initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_(id<LibOrgBouncycastleCryptoModesAEADBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher, initWithLibOrgBouncycastleCryptoModesAEADBlockCipher_, cipher)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderSymmetricUtilBaseBlockCipher_AEADGenericBlockCipher)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/jcajce/provider/asymmetric/dh/JcajceDhIESCipher.java
//

#include "AESEngine.h"
#include "AsymmetricKeyParameter.h"
#include "BCJcaJceHelper.h"
#include "BadBlockException.h"
#include "BigIntegers.h"
#include "BufferedBlockCipher.h"
#include "CBCBlockCipher.h"
#include "CipherParameters.h"
#include "DESedeEngine.h"
#include "DHBasicAgreement.h"
#include "DHIESPublicKeyParser.h"
#include "DHKeyGenerationParameters.h"
#include "DHKeyPairGenerator.h"
#include "DHKeyParameters.h"
#include "DHParameters.h"
#include "DHPublicKeyParameters.h"
#include "Digest.h"
#include "DigestFactory.h"
#include "EphemeralKeyPairGenerator.h"
#include "HMac.h"
#include "IESEngine.h"
#include "IESKey.h"
#include "IESParameterSpec.h"
#include "IESUtil.h"
#include "IESWithCipherParameters.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "InvalidCipherTextException.h"
#include "J2ObjC_source.h"
#include "JcaJceHelper.h"
#include "JcaJceUtilDHUtil.h"
#include "JcajceDhIESCipher.h"
#include "KDF2BytesGenerator.h"
#include "KeyEncoder.h"
#include "Mac.h"
#include "PaddedBufferedBlockCipher.h"
#include "ParametersWithIV.h"
#include "Strings.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/security/AlgorithmParameters.h"
#include "java/security/InvalidAlgorithmParameterException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/Key.h"
#include "java/security/PrivateKey.h"
#include "java/security/PublicKey.h"
#include "java/security/SecureRandom.h"
#include "java/security/spec/AlgorithmParameterSpec.h"
#include "javax/crypto/Cipher.h"
#include "javax/crypto/CipherSpi.h"
#include "javax/crypto/NoSuchPaddingException.h"
#include "javax/crypto/interfaces/DHKey.h"
#include "javax/crypto/interfaces/DHPrivateKey.h"
#include "javax/crypto/interfaces/DHPublicKey.h"
#include "javax/crypto/spec/DHParameterSpec.h"

@interface LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher () {
 @public
  id<LibOrgBouncycastleJcajceUtilJcaJceHelper> helper_;
  jint ivLength_;
  LibOrgBouncycastleCryptoEnginesIESEngine *engine_;
  jint state_;
  JavaIoByteArrayOutputStream *buffer_;
  JavaSecurityAlgorithmParameters *engineParam_;
  LibOrgBouncycastleJceSpecIESParameterSpec *engineSpec_;
  LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *key_;
  JavaSecuritySecureRandom *random_;
  jboolean dhaesMode_;
  LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *otherKeyParameter_;
}

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, helper_, id<LibOrgBouncycastleJcajceUtilJcaJceHelper>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, engine_, LibOrgBouncycastleCryptoEnginesIESEngine *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, buffer_, JavaIoByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, engineParam_, JavaSecurityAlgorithmParameters *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, engineSpec_, LibOrgBouncycastleJceSpecIESParameterSpec *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, key_, LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, random_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, otherKeyParameter_, LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)

@interface LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 : NSObject < LibOrgBouncycastleCryptoKeyEncoder >

- (instancetype)init;

- (IOSByteArray *)getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:(LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)keyParameter;

@end

J2OBJC_EMPTY_STATIC_INIT(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1)

__attribute__((unused)) static void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *self);

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init(void);

@implementation LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher

- (instancetype)initWithLibOrgBouncycastleCryptoEnginesIESEngine:(LibOrgBouncycastleCryptoEnginesIESEngine *)engine {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(self, engine);
  return self;
}

- (instancetype)initWithLibOrgBouncycastleCryptoEnginesIESEngine:(LibOrgBouncycastleCryptoEnginesIESEngine *)engine
                                                         withInt:(jint)ivLength {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(self, engine, ivLength);
  return self;
}

- (jint)engineGetBlockSize {
  if ([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher] != nil) {
    return [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getBlockSize];
  }
  else {
    return 0;
  }
}

- (jint)engineGetKeySizeWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if ([JavaxCryptoInterfacesDHKey_class_() isInstance:key]) {
    return [((JavaMathBigInteger *) nil_chk([((JavaxCryptoSpecDHParameterSpec *) nil_chk([((id<JavaxCryptoInterfacesDHKey>) nil_chk(((id<JavaxCryptoInterfacesDHKey>) cast_check(key, JavaxCryptoInterfacesDHKey_class_())))) getParams])) getP])) bitLength];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"not a DH key");
  }
}

- (IOSByteArray *)engineGetIV {
  if (engineSpec_ != nil) {
    return [engineSpec_ getNonce];
  }
  return nil;
}

- (JavaSecurityAlgorithmParameters *)engineGetParameters {
  if (engineParam_ == nil && engineSpec_ != nil) {
    @try {
      engineParam_ = [((id<LibOrgBouncycastleJcajceUtilJcaJceHelper>) nil_chk(helper_)) createAlgorithmParametersWithNSString:@"IES"];
      [((JavaSecurityAlgorithmParameters *) nil_chk(engineParam_)) init__WithJavaSecuritySpecAlgorithmParameterSpec:engineSpec_];
    }
    @catch (JavaLangException *e) {
      @throw new_JavaLangRuntimeException_initWithNSString_([e description]);
    }
  }
  return engineParam_;
}

- (void)engineSetModeWithNSString:(NSString *)mode {
  NSString *modeName = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(mode);
  if ([((NSString *) nil_chk(modeName)) isEqual:@"NONE"]) {
    dhaesMode_ = false;
  }
  else if ([modeName isEqual:@"DHAES"]) {
    dhaesMode_ = true;
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"can't support mode ", mode));
  }
}

- (jint)engineGetOutputSizeWithInt:(jint)inputLen {
  jint len1;
  jint len2;
  jint len3;
  if (key_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
  len1 = [((id<LibOrgBouncycastleCryptoMac>) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getMac])) getMacSize];
  if (otherKeyParameter_ == nil) {
    len2 = 1 + 2 * ([((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsDHParameters *) nil_chk([((LibOrgBouncycastleCryptoParamsDHKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsDHKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsDHKeyParameters class])))) getParameters])) getP])) bitLength] + 7) / 8;
  }
  else {
    len2 = 0;
  }
  if ([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher] == nil) {
    len3 = inputLen;
  }
  else if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    len3 = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getOutputSizeWithInt:inputLen];
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    len3 = [((LibOrgBouncycastleCryptoBufferedBlockCipher *) nil_chk([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher])) getOutputSizeWithInt:inputLen - len1 - len2];
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"cipher not initialised");
  }
  if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    return [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) size] + len1 + len2 + len3;
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    return [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) size] - len1 - len2 + len3;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"IESCipher not initialised");
  }
}

- (void)engineSetPaddingWithNSString:(NSString *)padding {
  NSString *paddingName = LibOrgBouncycastleUtilStrings_toUpperCaseWithNSString_(padding);
  if ([((NSString *) nil_chk(paddingName)) isEqual:@"NOPADDING"]) {
  }
  else if ([paddingName isEqual:@"PKCS5PADDING"] || [paddingName isEqual:@"PKCS7PADDING"]) {
  }
  else {
    @throw new_JavaxCryptoNoSuchPaddingException_initWithNSString_(@"padding not available with IESCipher");
  }
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  id<JavaSecuritySpecAlgorithmParameterSpec> paramSpec = nil;
  if (params != nil) {
    @try {
      paramSpec = [params getParameterSpecWithIOSClass:LibOrgBouncycastleJceSpecIESParameterSpec_class_()];
    }
    @catch (JavaLangException *e) {
      @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$$", @"cannot recognise parameters: ", [e description]));
    }
  }
  engineParam_ = params;
  [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:paramSpec withJavaSecuritySecureRandom:random];
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)engineSpec
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  if (engineSpec == nil) {
    IOSByteArray *nonce = nil;
    if (ivLength_ != 0 && opmode == JavaxCryptoCipher_ENCRYPT_MODE) {
      nonce = [IOSByteArray newArrayWithLength:ivLength_];
      [((JavaSecuritySecureRandom *) nil_chk(random)) nextBytesWithByteArray:nonce];
    }
    self->engineSpec_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilIESUtil_guessParameterSpecWithLibOrgBouncycastleCryptoBufferedBlockCipher_withByteArray_([((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) getCipher], nonce);
  }
  else if ([engineSpec isKindOfClass:[LibOrgBouncycastleJceSpecIESParameterSpec class]]) {
    self->engineSpec_ = (LibOrgBouncycastleJceSpecIESParameterSpec *) engineSpec;
  }
  else {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(@"must be passed IES parameters");
  }
  IOSByteArray *nonce = [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(self->engineSpec_)) getNonce];
  if (ivLength_ != 0 && (nonce == nil || nonce->size_ != ivLength_)) {
    @throw new_JavaSecurityInvalidAlgorithmParameterException_initWithNSString_(JreStrcat("$I$", @"NONCE in IES Parameters needs to be ", ivLength_, @" bytes long"));
  }
  if (opmode == JavaxCryptoCipher_ENCRYPT_MODE || opmode == JavaxCryptoCipher_WRAP_MODE) {
    if ([JavaxCryptoInterfacesDHPublicKey_class_() isInstance:key]) {
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePublicKeyParameterWithJavaSecurityPublicKey_((id<JavaSecurityPublicKey>) cast_check(key, JavaSecurityPublicKey_class_()));
    }
    else if ([LibOrgBouncycastleJceInterfacesIESKey_class_() isInstance:key]) {
      id<LibOrgBouncycastleJceInterfacesIESKey> ieKey = (id<LibOrgBouncycastleJceInterfacesIESKey>) cast_check(key, LibOrgBouncycastleJceInterfacesIESKey_class_());
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePublicKeyParameterWithJavaSecurityPublicKey_([((id<LibOrgBouncycastleJceInterfacesIESKey>) nil_chk(ieKey)) getPublic]);
      self->otherKeyParameter_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_([ieKey getPrivate]);
    }
    else {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed recipient's public DH key for encryption");
    }
  }
  else if (opmode == JavaxCryptoCipher_DECRYPT_MODE || opmode == JavaxCryptoCipher_UNWRAP_MODE) {
    if ([JavaxCryptoInterfacesDHPrivateKey_class_() isInstance:key]) {
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_((id<JavaSecurityPrivateKey>) cast_check(key, JavaSecurityPrivateKey_class_()));
    }
    else if ([LibOrgBouncycastleJceInterfacesIESKey_class_() isInstance:key]) {
      id<LibOrgBouncycastleJceInterfacesIESKey> ieKey = (id<LibOrgBouncycastleJceInterfacesIESKey>) cast_check(key, LibOrgBouncycastleJceInterfacesIESKey_class_());
      self->otherKeyParameter_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePublicKeyParameterWithJavaSecurityPublicKey_([((id<LibOrgBouncycastleJceInterfacesIESKey>) nil_chk(ieKey)) getPublic]);
      self->key_ = LibOrgBouncycastleJcajceProviderAsymmetricUtilJcaJceUtilDHUtil_generatePrivateKeyParameterWithJavaSecurityPrivateKey_([ieKey getPrivate]);
    }
    else {
      @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed recipient's private DH key for decryption");
    }
  }
  else {
    @throw new_JavaSecurityInvalidKeyException_initWithNSString_(@"must be passed EC key");
  }
  self->random_ = random;
  self->state_ = opmode;
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) reset];
}

- (void)engineInitWithInt:(jint)opmode
      withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random {
  @try {
    [self engineInitWithInt:opmode withJavaSecurityKey:key withJavaSecuritySpecAlgorithmParameterSpec:nil withJavaSecuritySecureRandom:random];
  }
  @catch (JavaSecurityInvalidAlgorithmParameterException *e) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"cannot handle supplied parameter spec: ", [e getMessage]));
  }
}

- (IOSByteArray *)engineUpdateWithByteArray:(IOSByteArray *)input
                                    withInt:(jint)inputOffset
                                    withInt:(jint)inputLen {
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return nil;
}

- (jint)engineUpdateWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inputOffset
                          withInt:(jint)inputLen
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outputOffset {
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  return 0;
}

- (IOSByteArray *)engineDoFinalWithByteArray:(IOSByteArray *)input
                                     withInt:(jint)inputOffset
                                     withInt:(jint)inputLen {
  if (inputLen != 0) {
    [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) writeWithByteArray:input withInt:inputOffset withInt:inputLen];
  }
  IOSByteArray *in = [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) toByteArray];
  [((JavaIoByteArrayOutputStream *) nil_chk(buffer_)) reset];
  id<LibOrgBouncycastleCryptoCipherParameters> params = new_LibOrgBouncycastleCryptoParamsIESWithCipherParameters_initWithByteArray_withByteArray_withInt_withInt_([((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getDerivationV], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getEncodingV], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getMacKeySize], [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getCipherKeySize]);
  if ([((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getNonce] != nil) {
    params = new_LibOrgBouncycastleCryptoParamsParametersWithIV_initWithLibOrgBouncycastleCryptoCipherParameters_withByteArray_(params, [((LibOrgBouncycastleJceSpecIESParameterSpec *) nil_chk(engineSpec_)) getNonce]);
  }
  LibOrgBouncycastleCryptoParamsDHParameters *dhParams = [((LibOrgBouncycastleCryptoParamsDHKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsDHKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsDHKeyParameters class])))) getParameters];
  IOSByteArray *V;
  if (otherKeyParameter_ != nil) {
    @try {
      if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
        [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:otherKeyParameter_ withLibOrgBouncycastleCryptoCipherParameters:key_ withLibOrgBouncycastleCryptoCipherParameters:params];
      }
      else {
        [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithBoolean:false withLibOrgBouncycastleCryptoCipherParameters:key_ withLibOrgBouncycastleCryptoCipherParameters:otherKeyParameter_ withLibOrgBouncycastleCryptoCipherParameters:params];
      }
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (JavaLangException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  if (state_ == JavaxCryptoCipher_ENCRYPT_MODE || state_ == JavaxCryptoCipher_WRAP_MODE) {
    LibOrgBouncycastleCryptoGeneratorsDHKeyPairGenerator *gen = new_LibOrgBouncycastleCryptoGeneratorsDHKeyPairGenerator_init();
    [gen init__WithLibOrgBouncycastleCryptoKeyGenerationParameters:new_LibOrgBouncycastleCryptoParamsDHKeyGenerationParameters_initWithJavaSecuritySecureRandom_withLibOrgBouncycastleCryptoParamsDHParameters_(random_, dhParams)];
    LibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator *kGen = new_LibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator_initWithLibOrgBouncycastleCryptoAsymmetricCipherKeyPairGenerator_withLibOrgBouncycastleCryptoKeyEncoder_(gen, new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init());
    @try {
      [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:key_ withLibOrgBouncycastleCryptoCipherParameters:params withLibOrgBouncycastleCryptoGeneratorsEphemeralKeyPairGenerator:kGen];
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (JavaLangException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  else if (state_ == JavaxCryptoCipher_DECRYPT_MODE || state_ == JavaxCryptoCipher_UNWRAP_MODE) {
    @try {
      [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) init__WithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:key_ withLibOrgBouncycastleCryptoCipherParameters:params withLibOrgBouncycastleCryptoKeyParser:new_LibOrgBouncycastleCryptoParsersDHIESPublicKeyParser_initWithLibOrgBouncycastleCryptoParamsDHParameters_([((LibOrgBouncycastleCryptoParamsDHKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsDHKeyParameters *) cast_chk(key_, [LibOrgBouncycastleCryptoParamsDHKeyParameters class])))) getParameters])];
      return [((LibOrgBouncycastleCryptoEnginesIESEngine *) nil_chk(engine_)) processBlockWithByteArray:in withInt:0 withInt:((IOSByteArray *) nil_chk(in))->size_];
    }
    @catch (LibOrgBouncycastleCryptoInvalidCipherTextException *e) {
      @throw new_LibOrgBouncycastleJcajceProviderUtilBadBlockException_initWithNSString_withJavaLangThrowable_(@"unable to process block", e);
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"IESCipher not initialised");
  }
}

- (jint)engineDoFinalWithByteArray:(IOSByteArray *)input
                           withInt:(jint)inputOffset
                           withInt:(jint)inputLength
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outputOffset {
  IOSByteArray *buf = [self engineDoFinalWithByteArray:input withInt:inputOffset withInt:inputLength];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buf, 0, output, outputOffset, ((IOSByteArray *) nil_chk(buf))->size_);
  return buf->size_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaSecurityAlgorithmParameters;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "I", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 5, 10, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 16, 17, -1, -1, -1 },
    { NULL, "[B", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 20, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 21, 19, 22, -1, -1, -1 },
    { NULL, "I", 0x1, 21, 20, 23, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoEnginesIESEngine:);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoEnginesIESEngine:withInt:);
  methods[2].selector = @selector(engineGetBlockSize);
  methods[3].selector = @selector(engineGetKeySizeWithJavaSecurityKey:);
  methods[4].selector = @selector(engineGetIV);
  methods[5].selector = @selector(engineGetParameters);
  methods[6].selector = @selector(engineSetModeWithNSString:);
  methods[7].selector = @selector(engineGetOutputSizeWithInt:);
  methods[8].selector = @selector(engineSetPaddingWithNSString:);
  methods[9].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecurityAlgorithmParameters:withJavaSecuritySecureRandom:);
  methods[10].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySpecAlgorithmParameterSpec:withJavaSecuritySecureRandom:);
  methods[11].selector = @selector(engineInitWithInt:withJavaSecurityKey:withJavaSecuritySecureRandom:);
  methods[12].selector = @selector(engineUpdateWithByteArray:withInt:withInt:);
  methods[13].selector = @selector(engineUpdateWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[14].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:);
  methods[15].selector = @selector(engineDoFinalWithByteArray:withInt:withInt:withByteArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "helper_", "LLibOrgBouncycastleJcajceUtilJcaJceHelper;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ivLength_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "engine_", "LLibOrgBouncycastleCryptoEnginesIESEngine;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "state_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "LJavaIoByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineParam_", "LJavaSecurityAlgorithmParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineSpec_", "LLibOrgBouncycastleJceSpecIESParameterSpec;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "key_", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "random_", "LJavaSecuritySecureRandom;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "dhaesMode_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "otherKeyParameter_", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoEnginesIESEngine;", "LLibOrgBouncycastleCryptoEnginesIESEngine;I", "engineGetKeySize", "LJavaSecurityKey;", "engineSetMode", "LNSString;", "LJavaSecurityNoSuchAlgorithmException;", "engineGetOutputSize", "I", "engineSetPadding", "LJavaxCryptoNoSuchPaddingException;", "engineInit", "ILJavaSecurityKey;LJavaSecurityAlgorithmParameters;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;LJavaSecurityInvalidAlgorithmParameterException;", "ILJavaSecurityKey;LJavaSecuritySpecAlgorithmParameterSpec;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidAlgorithmParameterException;LJavaSecurityInvalidKeyException;", "ILJavaSecurityKey;LJavaSecuritySecureRandom;", "LJavaSecurityInvalidKeyException;", "engineUpdate", "[BII", "[BII[BI", "engineDoFinal", "LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LJavaxCryptoShortBufferException;LJavaxCryptoIllegalBlockSizeException;LJavaxCryptoBadPaddingException;", "LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES;LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC;LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher = { "JcajceDhIESCipher", "lib.org.bouncycastle.jcajce.provider.asymmetric.dh", ptrTable, methods, fields, 7, 0x1, 16, 11, -1, 24, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *self, LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  JavaxCryptoCipherSpi_init(self);
  self->helper_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->state_ = -1;
  self->buffer_ = new_JavaIoByteArrayOutputStream_init();
  self->engineParam_ = nil;
  self->engineSpec_ = nil;
  self->dhaesMode_ = false;
  self->otherKeyParameter_ = nil;
  self->engine_ = engine;
  self->ivLength_ = 0;
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_, engine)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(LibOrgBouncycastleCryptoEnginesIESEngine *engine) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_, engine)
}

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *self, LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  JavaxCryptoCipherSpi_init(self);
  self->helper_ = new_LibOrgBouncycastleJcajceUtilBCJcaJceHelper_init();
  self->state_ = -1;
  self->buffer_ = new_JavaIoByteArrayOutputStream_init();
  self->engineParam_ = nil;
  self->engineSpec_ = nil;
  self->dhaesMode_ = false;
  self->otherKeyParameter_ = nil;
  self->engine_ = engine;
  self->ivLength_ = ivLength;
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_, engine, ivLength)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(LibOrgBouncycastleCryptoEnginesIESEngine *engine, jint ivLength) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher, initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_, engine, ivLength)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IOSByteArray *)getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:(LibOrgBouncycastleCryptoParamsAsymmetricKeyParameter *)keyParameter {
  IOSByteArray *Vloc = [IOSByteArray newArrayWithLength:([((JavaMathBigInteger *) nil_chk([((LibOrgBouncycastleCryptoParamsDHParameters *) nil_chk([((LibOrgBouncycastleCryptoParamsDHKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsDHKeyParameters *) cast_chk(keyParameter, [LibOrgBouncycastleCryptoParamsDHKeyParameters class])))) getParameters])) getP])) bitLength] + 7) / 8];
  IOSByteArray *Vtmp = LibOrgBouncycastleUtilBigIntegers_asUnsignedByteArrayWithJavaMathBigInteger_([((LibOrgBouncycastleCryptoParamsDHPublicKeyParameters *) nil_chk(((LibOrgBouncycastleCryptoParamsDHPublicKeyParameters *) cast_chk(keyParameter, [LibOrgBouncycastleCryptoParamsDHPublicKeyParameters class])))) getY]);
  if (((IOSByteArray *) nil_chk(Vtmp))->size_ > Vloc->size_) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Senders's public key longer than expected.");
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(Vtmp, 0, Vloc, Vloc->size_ - Vtmp->size_, Vtmp->size_);
  }
  return Vloc;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(getEncodedWithLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "getEncoded", "LLibOrgBouncycastleCryptoParamsAsymmetricKeyParameter;", "LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher;", "engineDoFinalWithByteArray:withInt:withInt:" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 = { "", "lib.org.bouncycastle.jcajce.provider.asymmetric.dh", ptrTable, methods, NULL, 7, 0x8010, 2, 0, 2, -1, 3, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *self) {
  NSObject_init(self);
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1 *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_1, init)
}

@implementation LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES = { "IES", "lib.org.bouncycastle.jcajce.provider.asymmetric.dh", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES_init(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_(self, new_LibOrgBouncycastleCryptoEnginesIESEngine_initWithLibOrgBouncycastleCryptoBasicAgreement_withLibOrgBouncycastleCryptoDerivationFunction_withLibOrgBouncycastleCryptoMac_(new_LibOrgBouncycastleCryptoAgreementDHBasicAgreement_init(), new_LibOrgBouncycastleCryptoGeneratorsKDF2BytesGenerator_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1())));
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IES)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC = { "IESwithDESedeCBC", "lib.org.bouncycastle.jcajce.provider.asymmetric.dh", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC_init(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(self, new_LibOrgBouncycastleCryptoEnginesIESEngine_initWithLibOrgBouncycastleCryptoBasicAgreement_withLibOrgBouncycastleCryptoDerivationFunction_withLibOrgBouncycastleCryptoMac_withLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoAgreementDHBasicAgreement_init(), new_LibOrgBouncycastleCryptoGeneratorsKDF2BytesGenerator_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoPaddingsPaddedBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoEnginesDESedeEngine_init()))), 8);
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithDESedeCBC)

@implementation LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LLibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher;" };
  static const J2ObjcClassInfo _LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC = { "IESwithAESCBC", "lib.org.bouncycastle.jcajce.provider.asymmetric.dh", ptrTable, methods, NULL, 7, 0x9, 1, 0, 0, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC;
}

@end

void LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC_init(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC *self) {
  LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_initWithLibOrgBouncycastleCryptoEnginesIESEngine_withInt_(self, new_LibOrgBouncycastleCryptoEnginesIESEngine_initWithLibOrgBouncycastleCryptoBasicAgreement_withLibOrgBouncycastleCryptoDerivationFunction_withLibOrgBouncycastleCryptoMac_withLibOrgBouncycastleCryptoBufferedBlockCipher_(new_LibOrgBouncycastleCryptoAgreementDHBasicAgreement_init(), new_LibOrgBouncycastleCryptoGeneratorsKDF2BytesGenerator_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoMacsHMac_initWithLibOrgBouncycastleCryptoDigest_(LibOrgBouncycastleCryptoUtilDigestFactory_createSHA1()), new_LibOrgBouncycastleCryptoPaddingsPaddedBufferedBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoModesCBCBlockCipher_initWithLibOrgBouncycastleCryptoBlockCipher_(new_LibOrgBouncycastleCryptoEnginesAESEngine_init()))), 16);
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC *new_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC, init)
}

LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC *create_LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleJcajceProviderAsymmetricDhJcajceDhIESCipher_IESwithAESCBC)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/tls/DTLSRecordLayer.java
//

#include "AlertDescription.h"
#include "AlertLevel.h"
#include "ByteQueue.h"
#include "ChangeCipherSpec.h"
#include "ContentType.h"
#include "DTLSEpoch.h"
#include "DTLSHandshakeRetransmit.h"
#include "DTLSRecordLayer.h"
#include "DTLSReplayWindow.h"
#include "DatagramTransport.h"
#include "HandshakeType.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "ProtocolVersion.h"
#include "TlsCipher.h"
#include "TlsContext.h"
#include "TlsFatalAlert.h"
#include "TlsNullCipher.h"
#include "TlsPeer.h"
#include "TlsUtils.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/lang/Throwable.h"

@interface LibOrgBouncycastleCryptoTlsDTLSRecordLayer () {
 @public
  id<LibOrgBouncycastleCryptoTlsDatagramTransport> transport_;
  id<LibOrgBouncycastleCryptoTlsTlsContext> context_;
  id<LibOrgBouncycastleCryptoTlsTlsPeer> peer_;
  LibOrgBouncycastleCryptoTlsByteQueue *recordQueue_;
  volatile_jboolean closed_;
  volatile_jboolean failed_;
  volatile_id readVersion_;
  volatile_id writeVersion_;
  volatile_jboolean inHandshake_;
  volatile_jint plaintextLimit_;
  LibOrgBouncycastleCryptoTlsDTLSEpoch *currentEpoch_;
  LibOrgBouncycastleCryptoTlsDTLSEpoch *pendingEpoch_;
  LibOrgBouncycastleCryptoTlsDTLSEpoch *readEpoch_;
  LibOrgBouncycastleCryptoTlsDTLSEpoch *writeEpoch_;
  id<LibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit> retransmit_;
  LibOrgBouncycastleCryptoTlsDTLSEpoch *retransmitEpoch_;
  jlong retransmitExpiry_;
}

- (void)closeTransport;

- (void)raiseAlertWithShort:(jshort)alertLevel
                  withShort:(jshort)alertDescription
               withNSString:(NSString *)message
      withJavaLangThrowable:(JavaLangThrowable *)cause;

- (jint)receiveRecordWithByteArray:(IOSByteArray *)buf
                           withInt:(jint)off
                           withInt:(jint)len
                           withInt:(jint)waitMillis;

- (void)sendRecordWithShort:(jshort)contentType
              withByteArray:(IOSByteArray *)buf
                    withInt:(jint)off
                    withInt:(jint)len;

+ (jlong)getMacSequenceNumberWithInt:(jint)epoch
                            withLong:(jlong)sequence_number;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, transport_, id<LibOrgBouncycastleCryptoTlsDatagramTransport>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, context_, id<LibOrgBouncycastleCryptoTlsTlsContext>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, peer_, id<LibOrgBouncycastleCryptoTlsTlsPeer>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, recordQueue_, LibOrgBouncycastleCryptoTlsByteQueue *)
J2OBJC_VOLATILE_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, readVersion_, LibOrgBouncycastleCryptoTlsProtocolVersion *)
J2OBJC_VOLATILE_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, writeVersion_, LibOrgBouncycastleCryptoTlsProtocolVersion *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, currentEpoch_, LibOrgBouncycastleCryptoTlsDTLSEpoch *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, pendingEpoch_, LibOrgBouncycastleCryptoTlsDTLSEpoch *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, readEpoch_, LibOrgBouncycastleCryptoTlsDTLSEpoch *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, writeEpoch_, LibOrgBouncycastleCryptoTlsDTLSEpoch *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, retransmit_, id<LibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, retransmitEpoch_, LibOrgBouncycastleCryptoTlsDTLSEpoch *)

inline jint LibOrgBouncycastleCryptoTlsDTLSRecordLayer_get_RECORD_HEADER_LENGTH(void);
#define LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH 13
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, RECORD_HEADER_LENGTH, jint)

inline jint LibOrgBouncycastleCryptoTlsDTLSRecordLayer_get_MAX_FRAGMENT_LENGTH(void);
#define LibOrgBouncycastleCryptoTlsDTLSRecordLayer_MAX_FRAGMENT_LENGTH 16384
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, MAX_FRAGMENT_LENGTH, jint)

inline jlong LibOrgBouncycastleCryptoTlsDTLSRecordLayer_get_TCP_MSL(void);
#define LibOrgBouncycastleCryptoTlsDTLSRecordLayer_TCP_MSL 120000LL
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, TCP_MSL, jlong)

inline jlong LibOrgBouncycastleCryptoTlsDTLSRecordLayer_get_RETRANSMIT_TIMEOUT(void);
#define LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RETRANSMIT_TIMEOUT 240000LL
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, RETRANSMIT_TIMEOUT, jlong)

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_raiseAlertWithShort_withShort_withNSString_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, jshort alertLevel, jshort alertDescription, NSString *message, JavaLangThrowable *cause);

__attribute__((unused)) static jint LibOrgBouncycastleCryptoTlsDTLSRecordLayer_receiveRecordWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, IOSByteArray *buf, jint off, jint len, jint waitMillis);

__attribute__((unused)) static void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, jshort contentType, IOSByteArray *buf, jint off, jint len);

__attribute__((unused)) static jlong LibOrgBouncycastleCryptoTlsDTLSRecordLayer_getMacSequenceNumberWithInt_withLong_(jint epoch, jlong sequence_number);

@implementation LibOrgBouncycastleCryptoTlsDTLSRecordLayer

- (instancetype)initWithLibOrgBouncycastleCryptoTlsDatagramTransport:(id<LibOrgBouncycastleCryptoTlsDatagramTransport>)transport
                           withLibOrgBouncycastleCryptoTlsTlsContext:(id<LibOrgBouncycastleCryptoTlsTlsContext>)context
                              withLibOrgBouncycastleCryptoTlsTlsPeer:(id<LibOrgBouncycastleCryptoTlsTlsPeer>)peer
                                                           withShort:(jshort)contentType {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(self, transport, context, peer, contentType);
  return self;
}

- (void)setPlaintextLimitWithInt:(jint)plaintextLimit {
  JreAssignVolatileInt(&self->plaintextLimit_, plaintextLimit);
}

- (jint)getReadEpoch {
  return [((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(readEpoch_)) getEpoch];
}

- (LibOrgBouncycastleCryptoTlsProtocolVersion *)getReadVersion {
  return JreLoadVolatileId(&readVersion_);
}

- (void)setReadVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:(LibOrgBouncycastleCryptoTlsProtocolVersion *)readVersion {
  (void) JreVolatileStrongAssign(&self->readVersion_, readVersion);
}

- (void)setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:(LibOrgBouncycastleCryptoTlsProtocolVersion *)writeVersion {
  (void) JreVolatileStrongAssign(&self->writeVersion_, writeVersion);
}

- (void)initPendingEpochWithLibOrgBouncycastleCryptoTlsTlsCipher:(id<LibOrgBouncycastleCryptoTlsTlsCipher>)pendingCipher {
  if (pendingEpoch_ != nil) {
    @throw new_JavaLangIllegalStateException_init();
  }
  self->pendingEpoch_ = new_LibOrgBouncycastleCryptoTlsDTLSEpoch_initWithInt_withLibOrgBouncycastleCryptoTlsTlsCipher_([((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(writeEpoch_)) getEpoch] + 1, pendingCipher);
}

- (void)handshakeSuccessfulWithLibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit:(id<LibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit>)retransmit {
  if (readEpoch_ == currentEpoch_ || writeEpoch_ == currentEpoch_) {
    @throw new_JavaLangIllegalStateException_init();
  }
  if (retransmit != nil) {
    self->retransmit_ = retransmit;
    self->retransmitEpoch_ = currentEpoch_;
    self->retransmitExpiry_ = JavaLangSystem_currentTimeMillis() + LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RETRANSMIT_TIMEOUT;
  }
  JreAssignVolatileBoolean(&self->inHandshake_, false);
  self->currentEpoch_ = pendingEpoch_;
  self->pendingEpoch_ = nil;
}

- (void)resetWriteEpoch {
  if (retransmitEpoch_ != nil) {
    self->writeEpoch_ = retransmitEpoch_;
  }
  else {
    self->writeEpoch_ = currentEpoch_;
  }
}

- (jint)getReceiveLimit {
  return JavaLangMath_minWithInt_withInt_(JreLoadVolatileInt(&self->plaintextLimit_), [((id<LibOrgBouncycastleCryptoTlsTlsCipher>) nil_chk([((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(readEpoch_)) getCipher])) getPlaintextLimitWithInt:[((id<LibOrgBouncycastleCryptoTlsDatagramTransport>) nil_chk(transport_)) getReceiveLimit] - LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH]);
}

- (jint)getSendLimit {
  return JavaLangMath_minWithInt_withInt_(JreLoadVolatileInt(&self->plaintextLimit_), [((id<LibOrgBouncycastleCryptoTlsTlsCipher>) nil_chk([((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(writeEpoch_)) getCipher])) getPlaintextLimitWithInt:[((id<LibOrgBouncycastleCryptoTlsDatagramTransport>) nil_chk(transport_)) getSendLimit] - LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH]);
}

- (jint)receiveWithByteArray:(IOSByteArray *)buf
                     withInt:(jint)off
                     withInt:(jint)len
                     withInt:(jint)waitMillis {
  IOSByteArray *record = nil;
  for (; ; ) {
    jint receiveLimit = JavaLangMath_minWithInt_withInt_(len, [self getReceiveLimit]) + LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH;
    if (record == nil || record->size_ < receiveLimit) {
      record = [IOSByteArray newArrayWithLength:receiveLimit];
    }
    @try {
      if (retransmit_ != nil && JavaLangSystem_currentTimeMillis() > retransmitExpiry_) {
        retransmit_ = nil;
        retransmitEpoch_ = nil;
      }
      jint received = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_receiveRecordWithByteArray_withInt_withInt_withInt_(self, record, 0, receiveLimit, waitMillis);
      if (received < 0) {
        return received;
      }
      if (received < LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH) {
        continue;
      }
      jint length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithByteArray_withInt_(record, 11);
      if (received != (length + LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH)) {
        continue;
      }
      jshort type = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(record, 0);
      switch (type) {
        case LibOrgBouncycastleCryptoTlsContentType_alert:
        case LibOrgBouncycastleCryptoTlsContentType_application_data:
        case LibOrgBouncycastleCryptoTlsContentType_change_cipher_spec:
        case LibOrgBouncycastleCryptoTlsContentType_handshake:
        case LibOrgBouncycastleCryptoTlsContentType_heartbeat:
        break;
        default:
        continue;
      }
      jint epoch = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithByteArray_withInt_(record, 3);
      LibOrgBouncycastleCryptoTlsDTLSEpoch *recordEpoch = nil;
      if (epoch == [((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(readEpoch_)) getEpoch]) {
        recordEpoch = readEpoch_;
      }
      else if (type == LibOrgBouncycastleCryptoTlsContentType_handshake && retransmitEpoch_ != nil && epoch == [retransmitEpoch_ getEpoch]) {
        recordEpoch = retransmitEpoch_;
      }
      if (recordEpoch == nil) {
        continue;
      }
      jlong seq = LibOrgBouncycastleCryptoTlsTlsUtils_readUint48WithByteArray_withInt_(record, 5);
      if ([((LibOrgBouncycastleCryptoTlsDTLSReplayWindow *) nil_chk([recordEpoch getReplayWindow])) shouldDiscardWithLong:seq]) {
        continue;
      }
      LibOrgBouncycastleCryptoTlsProtocolVersion *version_ = LibOrgBouncycastleCryptoTlsTlsUtils_readVersionWithByteArray_withInt_(record, 1);
      if (![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(version_)) isDTLS]) {
        continue;
      }
      if (JreLoadVolatileId(&readVersion_) != nil && ![((LibOrgBouncycastleCryptoTlsProtocolVersion *) nil_chk(JreLoadVolatileId(&readVersion_))) equalsWithLibOrgBouncycastleCryptoTlsProtocolVersion:version_]) {
        continue;
      }
      IOSByteArray *plaintext = [((id<LibOrgBouncycastleCryptoTlsTlsCipher>) nil_chk([recordEpoch getCipher])) decodeCiphertextWithLong:LibOrgBouncycastleCryptoTlsDTLSRecordLayer_getMacSequenceNumberWithInt_withLong_([recordEpoch getEpoch], seq) withShort:type withByteArray:record withInt:LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH withInt:received - LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH];
      [((LibOrgBouncycastleCryptoTlsDTLSReplayWindow *) nil_chk([recordEpoch getReplayWindow])) reportAuthenticatedWithLong:seq];
      if (((IOSByteArray *) nil_chk(plaintext))->size_ > JreLoadVolatileInt(&self->plaintextLimit_)) {
        continue;
      }
      if (JreLoadVolatileId(&readVersion_) == nil) {
        (void) JreVolatileStrongAssign(&readVersion_, version_);
      }
      switch (type) {
        case LibOrgBouncycastleCryptoTlsContentType_alert:
        {
          if (plaintext->size_ == 2) {
            jshort alertLevel = IOSByteArray_Get(plaintext, 0);
            jshort alertDescription = IOSByteArray_Get(plaintext, 1);
            [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk(peer_)) notifyAlertReceivedWithShort:alertLevel withShort:alertDescription];
            if (alertLevel == LibOrgBouncycastleCryptoTlsAlertLevel_fatal) {
              [self failed];
              @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(alertDescription);
            }
            if (alertDescription == LibOrgBouncycastleCryptoTlsAlertDescription_close_notify) {
              LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(self);
            }
          }
          continue;
        }
        case LibOrgBouncycastleCryptoTlsContentType_application_data:
        {
          if (JreLoadVolatileBoolean(&inHandshake_)) {
            continue;
          }
          break;
        }
        case LibOrgBouncycastleCryptoTlsContentType_change_cipher_spec:
        {
          for (jint i = 0; i < plaintext->size_; ++i) {
            jshort message = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(plaintext, i);
            if (message != LibOrgBouncycastleCryptoTlsChangeCipherSpec_change_cipher_spec) {
              continue;
            }
            if (pendingEpoch_ != nil) {
              readEpoch_ = pendingEpoch_;
            }
          }
          continue;
        }
        case LibOrgBouncycastleCryptoTlsContentType_handshake:
        {
          if (!JreLoadVolatileBoolean(&inHandshake_)) {
            if (retransmit_ != nil) {
              [retransmit_ receivedHandshakeRecordWithInt:epoch withByteArray:plaintext withInt:0 withInt:plaintext->size_];
            }
            continue;
          }
          break;
        }
        case LibOrgBouncycastleCryptoTlsContentType_heartbeat:
        {
          continue;
        }
      }
      if (!JreLoadVolatileBoolean(&inHandshake_) && retransmit_ != nil) {
        self->retransmit_ = nil;
        self->retransmitEpoch_ = nil;
      }
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(plaintext, 0, buf, off, plaintext->size_);
      return plaintext->size_;
    }
    @catch (JavaIoIOException *e) {
      @throw e;
    }
  }
}

- (void)sendWithByteArray:(IOSByteArray *)buf
                  withInt:(jint)off
                  withInt:(jint)len {
  jshort contentType = LibOrgBouncycastleCryptoTlsContentType_application_data;
  if (JreLoadVolatileBoolean(&self->inHandshake_) || self->writeEpoch_ == self->retransmitEpoch_) {
    contentType = LibOrgBouncycastleCryptoTlsContentType_handshake;
    jshort handshakeType = LibOrgBouncycastleCryptoTlsTlsUtils_readUint8WithByteArray_withInt_(buf, off);
    if (handshakeType == LibOrgBouncycastleCryptoTlsHandshakeType_finished) {
      LibOrgBouncycastleCryptoTlsDTLSEpoch *nextEpoch = nil;
      if (JreLoadVolatileBoolean(&self->inHandshake_)) {
        nextEpoch = pendingEpoch_;
      }
      else if (self->writeEpoch_ == self->retransmitEpoch_) {
        nextEpoch = currentEpoch_;
      }
      if (nextEpoch == nil) {
        @throw new_JavaLangIllegalStateException_init();
      }
      IOSByteArray *data = [IOSByteArray newArrayWithBytes:(jbyte[]){ 1 } count:1];
      LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(self, LibOrgBouncycastleCryptoTlsContentType_change_cipher_spec, data, 0, data->size_);
      writeEpoch_ = nextEpoch;
    }
  }
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(self, contentType, buf, off, len);
}

- (void)close {
  if (!JreLoadVolatileBoolean(&closed_)) {
    if (JreLoadVolatileBoolean(&inHandshake_)) {
      [self warnWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_user_canceled withNSString:@"User canceled handshake"];
    }
    LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(self);
  }
}

- (void)failWithShort:(jshort)alertDescription {
  if (!JreLoadVolatileBoolean(&closed_)) {
    @try {
      LibOrgBouncycastleCryptoTlsDTLSRecordLayer_raiseAlertWithShort_withShort_withNSString_withJavaLangThrowable_(self, LibOrgBouncycastleCryptoTlsAlertLevel_fatal, alertDescription, nil, nil);
    }
    @catch (JavaLangException *e) {
    }
    JreAssignVolatileBoolean(&failed_, true);
    LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(self);
  }
}

- (void)failed {
  if (!JreLoadVolatileBoolean(&closed_)) {
    JreAssignVolatileBoolean(&failed_, true);
    LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(self);
  }
}

- (void)warnWithShort:(jshort)alertDescription
         withNSString:(NSString *)message {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_raiseAlertWithShort_withShort_withNSString_withJavaLangThrowable_(self, LibOrgBouncycastleCryptoTlsAlertLevel_warning, alertDescription, message, nil);
}

- (void)closeTransport {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(self);
}

- (void)raiseAlertWithShort:(jshort)alertLevel
                  withShort:(jshort)alertDescription
               withNSString:(NSString *)message
      withJavaLangThrowable:(JavaLangThrowable *)cause {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_raiseAlertWithShort_withShort_withNSString_withJavaLangThrowable_(self, alertLevel, alertDescription, message, cause);
}

- (jint)receiveRecordWithByteArray:(IOSByteArray *)buf
                           withInt:(jint)off
                           withInt:(jint)len
                           withInt:(jint)waitMillis {
  return LibOrgBouncycastleCryptoTlsDTLSRecordLayer_receiveRecordWithByteArray_withInt_withInt_withInt_(self, buf, off, len, waitMillis);
}

- (void)sendRecordWithShort:(jshort)contentType
              withByteArray:(IOSByteArray *)buf
                    withInt:(jint)off
                    withInt:(jint)len {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(self, contentType, buf, off, len);
}

+ (jlong)getMacSequenceNumberWithInt:(jint)epoch
                            withLong:(jlong)sequence_number {
  return LibOrgBouncycastleCryptoTlsDTLSRecordLayer_getMacSequenceNumberWithInt_withLong_(epoch, sequence_number);
}

- (void)__javaClone:(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *)original {
  [super __javaClone:original];
  JreCloneVolatileStrong(&readVersion_, &original->readVersion_);
  JreCloneVolatileStrong(&writeVersion_, &original->writeVersion_);
}

- (void)dealloc {
  JreReleaseVolatile(&readVersion_);
  JreReleaseVolatile(&writeVersion_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleCryptoTlsProtocolVersion;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 5, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 10, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 10, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 10, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, 10, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 10, -1, -1, -1 },
    { NULL, "V", 0x0, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 17, 18, 10, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 19, 20, 10, -1, -1, -1 },
    { NULL, "I", 0x2, 21, 12, 10, -1, -1, -1 },
    { NULL, "V", 0x2, 22, 23, 10, -1, -1, -1 },
    { NULL, "J", 0xa, 24, 25, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibOrgBouncycastleCryptoTlsDatagramTransport:withLibOrgBouncycastleCryptoTlsTlsContext:withLibOrgBouncycastleCryptoTlsTlsPeer:withShort:);
  methods[1].selector = @selector(setPlaintextLimitWithInt:);
  methods[2].selector = @selector(getReadEpoch);
  methods[3].selector = @selector(getReadVersion);
  methods[4].selector = @selector(setReadVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:);
  methods[5].selector = @selector(setWriteVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion:);
  methods[6].selector = @selector(initPendingEpochWithLibOrgBouncycastleCryptoTlsTlsCipher:);
  methods[7].selector = @selector(handshakeSuccessfulWithLibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit:);
  methods[8].selector = @selector(resetWriteEpoch);
  methods[9].selector = @selector(getReceiveLimit);
  methods[10].selector = @selector(getSendLimit);
  methods[11].selector = @selector(receiveWithByteArray:withInt:withInt:withInt:);
  methods[12].selector = @selector(sendWithByteArray:withInt:withInt:);
  methods[13].selector = @selector(close);
  methods[14].selector = @selector(failWithShort:);
  methods[15].selector = @selector(failed);
  methods[16].selector = @selector(warnWithShort:withNSString:);
  methods[17].selector = @selector(closeTransport);
  methods[18].selector = @selector(raiseAlertWithShort:withShort:withNSString:withJavaLangThrowable:);
  methods[19].selector = @selector(receiveRecordWithByteArray:withInt:withInt:withInt:);
  methods[20].selector = @selector(sendRecordWithShort:withByteArray:withInt:withInt:);
  methods[21].selector = @selector(getMacSequenceNumberWithInt:withLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "RECORD_HEADER_LENGTH", "I", .constantValue.asInt = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "MAX_FRAGMENT_LENGTH", "I", .constantValue.asInt = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_MAX_FRAGMENT_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "TCP_MSL", "J", .constantValue.asLong = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_TCP_MSL, 0x1a, -1, -1, -1, -1 },
    { "RETRANSMIT_TIMEOUT", "J", .constantValue.asLong = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RETRANSMIT_TIMEOUT, 0x1a, -1, -1, -1, -1 },
    { "transport_", "LLibOrgBouncycastleCryptoTlsDatagramTransport;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "context_", "LLibOrgBouncycastleCryptoTlsTlsContext;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "peer_", "LLibOrgBouncycastleCryptoTlsTlsPeer;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "recordQueue_", "LLibOrgBouncycastleCryptoTlsByteQueue;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "closed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "failed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "readVersion_", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "writeVersion_", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "inHandshake_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "plaintextLimit_", "I", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "currentEpoch_", "LLibOrgBouncycastleCryptoTlsDTLSEpoch;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pendingEpoch_", "LLibOrgBouncycastleCryptoTlsDTLSEpoch;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "readEpoch_", "LLibOrgBouncycastleCryptoTlsDTLSEpoch;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "writeEpoch_", "LLibOrgBouncycastleCryptoTlsDTLSEpoch;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "retransmit_", "LLibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "retransmitEpoch_", "LLibOrgBouncycastleCryptoTlsDTLSEpoch;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "retransmitExpiry_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoTlsDatagramTransport;LLibOrgBouncycastleCryptoTlsTlsContext;LLibOrgBouncycastleCryptoTlsTlsPeer;S", "setPlaintextLimit", "I", "setReadVersion", "LLibOrgBouncycastleCryptoTlsProtocolVersion;", "setWriteVersion", "initPendingEpoch", "LLibOrgBouncycastleCryptoTlsTlsCipher;", "handshakeSuccessful", "LLibOrgBouncycastleCryptoTlsDTLSHandshakeRetransmit;", "LJavaIoIOException;", "receive", "[BIII", "send", "[BII", "fail", "S", "warn", "SLNSString;", "raiseAlert", "SSLNSString;LJavaLangThrowable;", "receiveRecord", "sendRecord", "S[BII", "getMacSequenceNumber", "IJ" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoTlsDTLSRecordLayer = { "DTLSRecordLayer", "lib.org.bouncycastle.crypto.tls", ptrTable, methods, fields, 7, 0x0, 22, 21, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoTlsDTLSRecordLayer;
}

@end

void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, id<LibOrgBouncycastleCryptoTlsDatagramTransport> transport, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoTlsTlsPeer> peer, jshort contentType) {
  NSObject_init(self);
  self->recordQueue_ = new_LibOrgBouncycastleCryptoTlsByteQueue_init();
  JreAssignVolatileBoolean(&self->closed_, false);
  JreAssignVolatileBoolean(&self->failed_, false);
  (void) JreVolatileStrongAssign(&self->readVersion_, nil);
  (void) JreVolatileStrongAssign(&self->writeVersion_, nil);
  self->retransmit_ = nil;
  self->retransmitEpoch_ = nil;
  self->retransmitExpiry_ = 0;
  self->transport_ = transport;
  self->context_ = context;
  self->peer_ = peer;
  JreAssignVolatileBoolean(&self->inHandshake_, true);
  self->currentEpoch_ = new_LibOrgBouncycastleCryptoTlsDTLSEpoch_initWithInt_withLibOrgBouncycastleCryptoTlsTlsCipher_(0, new_LibOrgBouncycastleCryptoTlsTlsNullCipher_initWithLibOrgBouncycastleCryptoTlsTlsContext_(context));
  self->pendingEpoch_ = nil;
  self->readEpoch_ = self->currentEpoch_;
  self->writeEpoch_ = self->currentEpoch_;
  [self setPlaintextLimitWithInt:LibOrgBouncycastleCryptoTlsDTLSRecordLayer_MAX_FRAGMENT_LENGTH];
}

LibOrgBouncycastleCryptoTlsDTLSRecordLayer *new_LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(id<LibOrgBouncycastleCryptoTlsDatagramTransport> transport, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoTlsTlsPeer> peer, jshort contentType) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_, transport, context, peer, contentType)
}

LibOrgBouncycastleCryptoTlsDTLSRecordLayer *create_LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_(id<LibOrgBouncycastleCryptoTlsDatagramTransport> transport, id<LibOrgBouncycastleCryptoTlsTlsContext> context, id<LibOrgBouncycastleCryptoTlsTlsPeer> peer, jshort contentType) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoTlsDTLSRecordLayer, initWithLibOrgBouncycastleCryptoTlsDatagramTransport_withLibOrgBouncycastleCryptoTlsTlsContext_withLibOrgBouncycastleCryptoTlsTlsPeer_withShort_, transport, context, peer, contentType)
}

void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_closeTransport(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self) {
  if (!JreLoadVolatileBoolean(&self->closed_)) {
    @try {
      if (!JreLoadVolatileBoolean(&self->failed_)) {
        [self warnWithShort:LibOrgBouncycastleCryptoTlsAlertDescription_close_notify withNSString:nil];
      }
      [((id<LibOrgBouncycastleCryptoTlsDatagramTransport>) nil_chk(self->transport_)) close];
    }
    @catch (JavaLangException *e) {
    }
    JreAssignVolatileBoolean(&self->closed_, true);
  }
}

void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_raiseAlertWithShort_withShort_withNSString_withJavaLangThrowable_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, jshort alertLevel, jshort alertDescription, NSString *message, JavaLangThrowable *cause) {
  [((id<LibOrgBouncycastleCryptoTlsTlsPeer>) nil_chk(self->peer_)) notifyAlertRaisedWithShort:alertLevel withShort:alertDescription withNSString:message withJavaLangThrowable:cause];
  IOSByteArray *error = [IOSByteArray newArrayWithLength:2];
  *IOSByteArray_GetRef(error, 0) = (jbyte) alertLevel;
  *IOSByteArray_GetRef(error, 1) = (jbyte) alertDescription;
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(self, LibOrgBouncycastleCryptoTlsContentType_alert, error, 0, 2);
}

jint LibOrgBouncycastleCryptoTlsDTLSRecordLayer_receiveRecordWithByteArray_withInt_withInt_withInt_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, IOSByteArray *buf, jint off, jint len, jint waitMillis) {
  if ([((LibOrgBouncycastleCryptoTlsByteQueue *) nil_chk(self->recordQueue_)) available] > 0) {
    jint length = 0;
    if ([self->recordQueue_ available] >= LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH) {
      IOSByteArray *lengthBytes = [IOSByteArray newArrayWithLength:2];
      [self->recordQueue_ readWithByteArray:lengthBytes withInt:0 withInt:2 withInt:11];
      length = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithByteArray_withInt_(lengthBytes, 0);
    }
    jint received = JavaLangMath_minWithInt_withInt_([self->recordQueue_ available], LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH + length);
    [self->recordQueue_ removeDataWithByteArray:buf withInt:off withInt:received withInt:0];
    return received;
  }
  jint received = [((id<LibOrgBouncycastleCryptoTlsDatagramTransport>) nil_chk(self->transport_)) receiveWithByteArray:buf withInt:off withInt:len withInt:waitMillis];
  if (received >= LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH) {
    jint fragmentLength = LibOrgBouncycastleCryptoTlsTlsUtils_readUint16WithByteArray_withInt_(buf, off + 11);
    jint recordLength = LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH + fragmentLength;
    if (received > recordLength) {
      [self->recordQueue_ addDataWithByteArray:buf withInt:off + recordLength withInt:received - recordLength];
      received = recordLength;
    }
  }
  return received;
}

void LibOrgBouncycastleCryptoTlsDTLSRecordLayer_sendRecordWithShort_withByteArray_withInt_withInt_(LibOrgBouncycastleCryptoTlsDTLSRecordLayer *self, jshort contentType, IOSByteArray *buf, jint off, jint len) {
  if (JreLoadVolatileId(&self->writeVersion_) == nil) {
    return;
  }
  if (len > JreLoadVolatileInt(&self->plaintextLimit_)) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  if (len < 1 && contentType != LibOrgBouncycastleCryptoTlsContentType_application_data) {
    @throw new_LibOrgBouncycastleCryptoTlsTlsFatalAlert_initWithShort_(LibOrgBouncycastleCryptoTlsAlertDescription_internal_error);
  }
  jint recordEpoch = [((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(self->writeEpoch_)) getEpoch];
  jlong recordSequenceNumber = [((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(self->writeEpoch_)) allocateSequenceNumber];
  IOSByteArray *ciphertext = [((id<LibOrgBouncycastleCryptoTlsTlsCipher>) nil_chk([((LibOrgBouncycastleCryptoTlsDTLSEpoch *) nil_chk(self->writeEpoch_)) getCipher])) encodePlaintextWithLong:LibOrgBouncycastleCryptoTlsDTLSRecordLayer_getMacSequenceNumberWithInt_withLong_(recordEpoch, recordSequenceNumber) withShort:contentType withByteArray:buf withInt:off withInt:len];
  IOSByteArray *record = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(ciphertext))->size_ + LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH];
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint8WithShort_withByteArray_withInt_(contentType, record, 0);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeVersionWithLibOrgBouncycastleCryptoTlsProtocolVersion_withByteArray_withInt_(JreLoadVolatileId(&self->writeVersion_), record, 1);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withByteArray_withInt_(recordEpoch, record, 3);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint48WithLong_withByteArray_withInt_(recordSequenceNumber, record, 5);
  LibOrgBouncycastleCryptoTlsTlsUtils_writeUint16WithInt_withByteArray_withInt_(ciphertext->size_, record, 11);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ciphertext, 0, record, LibOrgBouncycastleCryptoTlsDTLSRecordLayer_RECORD_HEADER_LENGTH, ciphertext->size_);
  [((id<LibOrgBouncycastleCryptoTlsDatagramTransport>) nil_chk(self->transport_)) sendWithByteArray:record withInt:0 withInt:record->size_];
}

jlong LibOrgBouncycastleCryptoTlsDTLSRecordLayer_getMacSequenceNumberWithInt_withLong_(jint epoch, jlong sequence_number) {
  LibOrgBouncycastleCryptoTlsDTLSRecordLayer_initialize();
  return (JreLShift64((epoch & (jlong) 0xFFFFFFFFLL), 48)) | sequence_number;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoTlsDTLSRecordLayer)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/macs/Poly1305.java
//

#include "BlockCipher.h"
#include "CipherParameters.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "Pack.h"
#include "ParametersWithIV.h"
#include "Poly1305.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoMacsPoly1305 () {
 @public
  id<LibOrgBouncycastleCryptoBlockCipher> cipher_;
  IOSByteArray *singleByte_;
  jint r0_;
  jint r1_;
  jint r2_;
  jint r3_;
  jint r4_;
  jint s1_;
  jint s2_;
  jint s3_;
  jint s4_;
  jint k0_;
  jint k1_;
  jint k2_;
  jint k3_;
  IOSByteArray *currentBlock_;
  jint currentBlockOffset_;
  jint h0_;
  jint h1_;
  jint h2_;
  jint h3_;
  jint h4_;
}

- (void)setKeyWithByteArray:(IOSByteArray *)key
              withByteArray:(IOSByteArray *)nonce;

- (void)processBlock;

+ (jlong)mul32x32_64WithInt:(jint)i1
                    withInt:(jint)i2;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsPoly1305, cipher_, id<LibOrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsPoly1305, singleByte_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoMacsPoly1305, currentBlock_, IOSByteArray *)

inline jint LibOrgBouncycastleCryptoMacsPoly1305_get_BLOCK_SIZE(void);
#define LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE 16
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoMacsPoly1305, BLOCK_SIZE, jint)

__attribute__((unused)) static void LibOrgBouncycastleCryptoMacsPoly1305_setKeyWithByteArray_withByteArray_(LibOrgBouncycastleCryptoMacsPoly1305 *self, IOSByteArray *key, IOSByteArray *nonce);

__attribute__((unused)) static void LibOrgBouncycastleCryptoMacsPoly1305_processBlock(LibOrgBouncycastleCryptoMacsPoly1305 *self);

__attribute__((unused)) static jlong LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(jint i1, jint i2);

@implementation LibOrgBouncycastleCryptoMacsPoly1305

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoMacsPoly1305_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithLibOrgBouncycastleCryptoBlockCipher:(id<LibOrgBouncycastleCryptoBlockCipher>)cipher {
  LibOrgBouncycastleCryptoMacsPoly1305_initWithLibOrgBouncycastleCryptoBlockCipher_(self, cipher);
  return self;
}

- (void)init__WithLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  IOSByteArray *nonce = nil;
  if (cipher_ != nil) {
    if (!([params isKindOfClass:[LibOrgBouncycastleCryptoParamsParametersWithIV class]])) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"JcajcePoly1305 requires an IV when used with a block cipher.");
    }
    LibOrgBouncycastleCryptoParamsParametersWithIV *ivParams = (LibOrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(params, [LibOrgBouncycastleCryptoParamsParametersWithIV class]);
    nonce = [((LibOrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParams)) getIV];
    params = [ivParams getParameters];
  }
  if (!([params isKindOfClass:[LibOrgBouncycastleCryptoParamsKeyParameter class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"JcajcePoly1305 requires a key.");
  }
  LibOrgBouncycastleCryptoParamsKeyParameter *keyParams = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk(params, [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  LibOrgBouncycastleCryptoMacsPoly1305_setKeyWithByteArray_withByteArray_(self, [((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(keyParams)) getKey], nonce);
  [self reset];
}

- (void)setKeyWithByteArray:(IOSByteArray *)key
              withByteArray:(IOSByteArray *)nonce {
  LibOrgBouncycastleCryptoMacsPoly1305_setKeyWithByteArray_withByteArray_(self, key, nonce);
}

- (NSString *)getAlgorithmName {
  return cipher_ == nil ? @"JcajcePoly1305" : JreStrcat("$$", @"JcajcePoly1305-", [cipher_ getAlgorithmName]);
}

- (jint)getMacSize {
  return LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE;
}

- (void)updateWithByte:(jbyte)inArg {
  *IOSByteArray_GetRef(nil_chk(singleByte_), 0) = inArg;
  [self updateWithByteArray:singleByte_ withInt:0 withInt:1];
}

- (void)updateWithByteArray:(IOSByteArray *)inArg
                    withInt:(jint)inOff
                    withInt:(jint)len {
  jint copied = 0;
  while (len > copied) {
    if (currentBlockOffset_ == LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE) {
      LibOrgBouncycastleCryptoMacsPoly1305_processBlock(self);
      currentBlockOffset_ = 0;
    }
    jint toCopy = JavaLangMath_minWithInt_withInt_((len - copied), LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE - currentBlockOffset_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, copied + inOff, currentBlock_, currentBlockOffset_, toCopy);
    copied += toCopy;
    currentBlockOffset_ += toCopy;
  }
}

- (void)processBlock {
  LibOrgBouncycastleCryptoMacsPoly1305_processBlock(self);
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  if (outOff + LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE > ((IOSByteArray *) nil_chk(outArg))->size_) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer is too short.");
  }
  if (currentBlockOffset_ > 0) {
    LibOrgBouncycastleCryptoMacsPoly1305_processBlock(self);
  }
  h1_ += (JreURShift32(h0_, 26));
  h0_ &= (jint) 0x3ffffff;
  h2_ += (JreURShift32(h1_, 26));
  h1_ &= (jint) 0x3ffffff;
  h3_ += (JreURShift32(h2_, 26));
  h2_ &= (jint) 0x3ffffff;
  h4_ += (JreURShift32(h3_, 26));
  h3_ &= (jint) 0x3ffffff;
  h0_ += (JreURShift32(h4_, 26)) * 5;
  h4_ &= (jint) 0x3ffffff;
  h1_ += (JreURShift32(h0_, 26));
  h0_ &= (jint) 0x3ffffff;
  jint g0;
  jint g1;
  jint g2;
  jint g3;
  jint g4;
  jint b;
  g0 = h0_ + 5;
  b = JreURShift32(g0, 26);
  g0 &= (jint) 0x3ffffff;
  g1 = h1_ + b;
  b = JreURShift32(g1, 26);
  g1 &= (jint) 0x3ffffff;
  g2 = h2_ + b;
  b = JreURShift32(g2, 26);
  g2 &= (jint) 0x3ffffff;
  g3 = h3_ + b;
  b = JreURShift32(g3, 26);
  g3 &= (jint) 0x3ffffff;
  g4 = h4_ + b - (JreLShift32(1, 26));
  b = (JreURShift32(g4, 31)) - 1;
  jint nb = ~b;
  h0_ = (h0_ & nb) | (g0 & b);
  h1_ = (h1_ & nb) | (g1 & b);
  h2_ = (h2_ & nb) | (g2 & b);
  h3_ = (h3_ & nb) | (g3 & b);
  h4_ = (h4_ & nb) | (g4 & b);
  jlong f0;
  jlong f1;
  jlong f2;
  jlong f3;
  f0 = (((h0_) | (JreLShift32(h1_, 26))) & (jlong) 0xffffffffl) + ((jlong) 0xffffffffLL & k0_);
  f1 = (((JreURShift32(h1_, 6)) | (JreLShift32(h2_, 20))) & (jlong) 0xffffffffl) + ((jlong) 0xffffffffLL & k1_);
  f2 = (((JreURShift32(h2_, 12)) | (JreLShift32(h3_, 14))) & (jlong) 0xffffffffl) + ((jlong) 0xffffffffLL & k2_);
  f3 = (((JreURShift32(h3_, 18)) | (JreLShift32(h4_, 8))) & (jlong) 0xffffffffl) + ((jlong) 0xffffffffLL & k3_);
  LibOrgBouncycastleUtilPack_intToLittleEndianWithInt_withByteArray_withInt_((jint) f0, outArg, outOff);
  f1 += (JreURShift64(f0, 32));
  LibOrgBouncycastleUtilPack_intToLittleEndianWithInt_withByteArray_withInt_((jint) f1, outArg, outOff + 4);
  f2 += (JreURShift64(f1, 32));
  LibOrgBouncycastleUtilPack_intToLittleEndianWithInt_withByteArray_withInt_((jint) f2, outArg, outOff + 8);
  f3 += (JreURShift64(f2, 32));
  LibOrgBouncycastleUtilPack_intToLittleEndianWithInt_withByteArray_withInt_((jint) f3, outArg, outOff + 12);
  [self reset];
  return LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE;
}

- (void)reset {
  currentBlockOffset_ = 0;
  h0_ = h1_ = h2_ = h3_ = h4_ = 0;
}

+ (jlong)mul32x32_64WithInt:(jint)i1
                    withInt:(jint)i2 {
  return LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(i1, i2);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, 8, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 9, 10, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 10, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1a, 13, 14, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithLibOrgBouncycastleCryptoBlockCipher:);
  methods[2].selector = @selector(init__WithLibOrgBouncycastleCryptoCipherParameters:);
  methods[3].selector = @selector(setKeyWithByteArray:withByteArray:);
  methods[4].selector = @selector(getAlgorithmName);
  methods[5].selector = @selector(getMacSize);
  methods[6].selector = @selector(updateWithByte:);
  methods[7].selector = @selector(updateWithByteArray:withInt:withInt:);
  methods[8].selector = @selector(processBlock);
  methods[9].selector = @selector(doFinalWithByteArray:withInt:);
  methods[10].selector = @selector(reset);
  methods[11].selector = @selector(mul32x32_64WithInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BLOCK_SIZE", "I", .constantValue.asInt = LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE, 0x1a, -1, -1, -1, -1 },
    { "cipher_", "LLibOrgBouncycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "singleByte_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "r0_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "r1_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "r2_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "r3_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "r4_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s1_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s2_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s3_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s4_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "k0_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "k1_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "k2_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "k3_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "currentBlock_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "currentBlockOffset_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "h0_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "h1_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "h2_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "h3_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "h4_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LLibOrgBouncycastleCryptoBlockCipher;", "init", "LLibOrgBouncycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "setKey", "[B[B", "update", "B", "LJavaLangIllegalStateException;", "[BII", "LLibOrgBouncycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "doFinal", "[BI", "mul32x32_64", "II" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoMacsPoly1305 = { "Poly1305", "lib.org.bouncycastle.crypto.macs", ptrTable, methods, fields, 7, 0x1, 12, 23, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoMacsPoly1305;
}

@end

void LibOrgBouncycastleCryptoMacsPoly1305_init(LibOrgBouncycastleCryptoMacsPoly1305 *self) {
  NSObject_init(self);
  self->singleByte_ = [IOSByteArray newArrayWithLength:1];
  self->currentBlock_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE];
  self->currentBlockOffset_ = 0;
  self->cipher_ = nil;
}

LibOrgBouncycastleCryptoMacsPoly1305 *new_LibOrgBouncycastleCryptoMacsPoly1305_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoMacsPoly1305, init)
}

LibOrgBouncycastleCryptoMacsPoly1305 *create_LibOrgBouncycastleCryptoMacsPoly1305_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoMacsPoly1305, init)
}

void LibOrgBouncycastleCryptoMacsPoly1305_initWithLibOrgBouncycastleCryptoBlockCipher_(LibOrgBouncycastleCryptoMacsPoly1305 *self, id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  NSObject_init(self);
  self->singleByte_ = [IOSByteArray newArrayWithLength:1];
  self->currentBlock_ = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE];
  self->currentBlockOffset_ = 0;
  if ([((id<LibOrgBouncycastleCryptoBlockCipher>) nil_chk(cipher)) getBlockSize] != LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"JcajcePoly1305 requires a 128 bit block cipher.");
  }
  self->cipher_ = cipher;
}

LibOrgBouncycastleCryptoMacsPoly1305 *new_LibOrgBouncycastleCryptoMacsPoly1305_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoMacsPoly1305, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

LibOrgBouncycastleCryptoMacsPoly1305 *create_LibOrgBouncycastleCryptoMacsPoly1305_initWithLibOrgBouncycastleCryptoBlockCipher_(id<LibOrgBouncycastleCryptoBlockCipher> cipher) {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoMacsPoly1305, initWithLibOrgBouncycastleCryptoBlockCipher_, cipher)
}

void LibOrgBouncycastleCryptoMacsPoly1305_setKeyWithByteArray_withByteArray_(LibOrgBouncycastleCryptoMacsPoly1305 *self, IOSByteArray *key, IOSByteArray *nonce) {
  if (((IOSByteArray *) nil_chk(key))->size_ != 32) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"JcajcePoly1305 key must be 256 bits.");
  }
  if (self->cipher_ != nil && (nonce == nil || nonce->size_ != LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE)) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"JcajcePoly1305 requires a 128 bit IV.");
  }
  jint t0 = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(key, 0);
  jint t1 = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(key, 4);
  jint t2 = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(key, 8);
  jint t3 = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(key, 12);
  self->r0_ = t0 & (jint) 0x03FFFFFF;
  self->r1_ = ((JreURShift32(t0, 26)) | (JreLShift32(t1, 6))) & (jint) 0x03FFFF03;
  self->r2_ = ((JreURShift32(t1, 20)) | (JreLShift32(t2, 12))) & (jint) 0x03FFC0FF;
  self->r3_ = ((JreURShift32(t2, 14)) | (JreLShift32(t3, 18))) & (jint) 0x03F03FFF;
  self->r4_ = (JreURShift32(t3, 8)) & (jint) 0x000FFFFF;
  self->s1_ = self->r1_ * 5;
  self->s2_ = self->r2_ * 5;
  self->s3_ = self->r3_ * 5;
  self->s4_ = self->r4_ * 5;
  IOSByteArray *kBytes;
  jint kOff;
  if (self->cipher_ == nil) {
    kBytes = key;
    kOff = LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE;
  }
  else {
    kBytes = [IOSByteArray newArrayWithLength:LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE];
    kOff = 0;
    [self->cipher_ init__WithBoolean:true withLibOrgBouncycastleCryptoCipherParameters:new_LibOrgBouncycastleCryptoParamsKeyParameter_initWithByteArray_withInt_withInt_(key, LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE, LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE)];
    [self->cipher_ processBlockWithByteArray:nonce withInt:0 withByteArray:kBytes withInt:0];
  }
  self->k0_ = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(kBytes, kOff + 0);
  self->k1_ = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(kBytes, kOff + 4);
  self->k2_ = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(kBytes, kOff + 8);
  self->k3_ = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(kBytes, kOff + 12);
}

void LibOrgBouncycastleCryptoMacsPoly1305_processBlock(LibOrgBouncycastleCryptoMacsPoly1305 *self) {
  if (self->currentBlockOffset_ < LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE) {
    *IOSByteArray_GetRef(nil_chk(self->currentBlock_), self->currentBlockOffset_) = 1;
    for (jint i = self->currentBlockOffset_ + 1; i < LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE; i++) {
      *IOSByteArray_GetRef(self->currentBlock_, i) = 0;
    }
  }
  jlong t0 = (jlong) 0xffffffffLL & LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(self->currentBlock_, 0);
  jlong t1 = (jlong) 0xffffffffLL & LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(self->currentBlock_, 4);
  jlong t2 = (jlong) 0xffffffffLL & LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(self->currentBlock_, 8);
  jlong t3 = (jlong) 0xffffffffLL & LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(self->currentBlock_, 12);
  self->h0_ += t0 & (jint) 0x3ffffff;
  self->h1_ += (JreURShift64(((JreLShift64(t1, 32)) | t0), 26)) & (jint) 0x3ffffff;
  self->h2_ += (JreURShift64(((JreLShift64(t2, 32)) | t1), 20)) & (jint) 0x3ffffff;
  self->h3_ += (JreURShift64(((JreLShift64(t3, 32)) | t2), 14)) & (jint) 0x3ffffff;
  self->h4_ += (JreURShift64(t3, 8));
  if (self->currentBlockOffset_ == LibOrgBouncycastleCryptoMacsPoly1305_BLOCK_SIZE) {
    self->h4_ += (JreLShift32(1, 24));
  }
  jlong tp0 = LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h0_, self->r0_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h1_, self->s4_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h2_, self->s3_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h3_, self->s2_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h4_, self->s1_);
  jlong tp1 = LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h0_, self->r1_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h1_, self->r0_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h2_, self->s4_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h3_, self->s3_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h4_, self->s2_);
  jlong tp2 = LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h0_, self->r2_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h1_, self->r1_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h2_, self->r0_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h3_, self->s4_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h4_, self->s3_);
  jlong tp3 = LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h0_, self->r3_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h1_, self->r2_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h2_, self->r1_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h3_, self->r0_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h4_, self->s4_);
  jlong tp4 = LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h0_, self->r4_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h1_, self->r3_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h2_, self->r2_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h3_, self->r1_) + LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(self->h4_, self->r0_);
  self->h0_ = (jint) tp0 & (jint) 0x3ffffff;
  tp1 += (JreURShift64(tp0, 26));
  self->h1_ = (jint) tp1 & (jint) 0x3ffffff;
  tp2 += (JreURShift64(tp1, 26));
  self->h2_ = (jint) tp2 & (jint) 0x3ffffff;
  tp3 += (JreURShift64(tp2, 26));
  self->h3_ = (jint) tp3 & (jint) 0x3ffffff;
  tp4 += (JreURShift64(tp3, 26));
  self->h4_ = (jint) tp4 & (jint) 0x3ffffff;
  self->h0_ += (jint) (JreURShift64(tp4, 26)) * 5;
  self->h1_ += (JreURShift32(self->h0_, 26));
  self->h0_ &= (jint) 0x3ffffff;
}

jlong LibOrgBouncycastleCryptoMacsPoly1305_mul32x32_64WithInt_withInt_(jint i1, jint i2) {
  LibOrgBouncycastleCryptoMacsPoly1305_initialize();
  return (i1 & (jlong) 0xFFFFFFFFLL) * i2;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoMacsPoly1305)

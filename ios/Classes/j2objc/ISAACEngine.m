//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/org/bouncycastle/crypto/engines/ISAACEngine.java
//

#include "CipherParameters.h"
#include "DataLengthException.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "ISAACEngine.h"
#include "J2ObjC_source.h"
#include "KeyParameter.h"
#include "OutputLengthException.h"
#include "Pack.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"

@interface LibOrgBouncycastleCryptoEnginesISAACEngine () {
 @public
  IOSIntArray *engineState_;
  IOSIntArray *results_;
  jint a_;
  jint b_;
  jint c_;
  jint index_;
  IOSByteArray *keyStream_;
  IOSByteArray *workingKey_;
  jboolean initialised_;
}

- (void)setKeyWithByteArray:(IOSByteArray *)keyBytes;

- (void)isaac;

- (void)mixWithIntArray:(IOSIntArray *)x;

@end

J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesISAACEngine, engineState_, IOSIntArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesISAACEngine, results_, IOSIntArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesISAACEngine, keyStream_, IOSByteArray *)
J2OBJC_FIELD_SETTER(LibOrgBouncycastleCryptoEnginesISAACEngine, workingKey_, IOSByteArray *)

inline jint LibOrgBouncycastleCryptoEnginesISAACEngine_get_sizeL(void);
#define LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL 8
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoEnginesISAACEngine, sizeL, jint)

inline jint LibOrgBouncycastleCryptoEnginesISAACEngine_get_stateArraySize(void);
#define LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize 256
J2OBJC_STATIC_FIELD_CONSTANT(LibOrgBouncycastleCryptoEnginesISAACEngine, stateArraySize, jint)

__attribute__((unused)) static void LibOrgBouncycastleCryptoEnginesISAACEngine_setKeyWithByteArray_(LibOrgBouncycastleCryptoEnginesISAACEngine *self, IOSByteArray *keyBytes);

__attribute__((unused)) static void LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(LibOrgBouncycastleCryptoEnginesISAACEngine *self);

__attribute__((unused)) static void LibOrgBouncycastleCryptoEnginesISAACEngine_mixWithIntArray_(LibOrgBouncycastleCryptoEnginesISAACEngine *self, IOSIntArray *x);

@implementation LibOrgBouncycastleCryptoEnginesISAACEngine

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibOrgBouncycastleCryptoEnginesISAACEngine_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)init__WithBoolean:(jboolean)forEncryption
withLibOrgBouncycastleCryptoCipherParameters:(id<LibOrgBouncycastleCryptoCipherParameters>)params {
  if (!([params isKindOfClass:[LibOrgBouncycastleCryptoParamsKeyParameter class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"invalid parameter passed to ISAAC init - ", [[((id<LibOrgBouncycastleCryptoCipherParameters>) nil_chk(params)) java_getClass] getName]));
  }
  LibOrgBouncycastleCryptoParamsKeyParameter *p = (LibOrgBouncycastleCryptoParamsKeyParameter *) cast_chk(params, [LibOrgBouncycastleCryptoParamsKeyParameter class]);
  LibOrgBouncycastleCryptoEnginesISAACEngine_setKeyWithByteArray_(self, [((LibOrgBouncycastleCryptoParamsKeyParameter *) nil_chk(p)) getKey]);
  return;
}

- (jbyte)returnByteWithByte:(jbyte)inArg {
  if (index_ == 0) {
    LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(self);
    keyStream_ = LibOrgBouncycastleUtilPack_intToBigEndianWithIntArray_(results_);
  }
  jbyte out = (jbyte) (IOSByteArray_Get(nil_chk(keyStream_), index_) ^ inArg);
  index_ = (index_ + 1) & 1023;
  return out;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (!initialised_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" not initialised"));
  }
  if ((inOff + len) > ((IOSByteArray *) nil_chk(inArg))->size_) {
    @throw new_LibOrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  if ((outOff + len) > ((IOSByteArray *) nil_chk(outArg))->size_) {
    @throw new_LibOrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"output buffer too short");
  }
  for (jint i = 0; i < len; i++) {
    if (index_ == 0) {
      LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(self);
      keyStream_ = LibOrgBouncycastleUtilPack_intToBigEndianWithIntArray_(results_);
    }
    *IOSByteArray_GetRef(outArg, i + outOff) = (jbyte) (IOSByteArray_Get(nil_chk(keyStream_), index_) ^ IOSByteArray_Get(inArg, i + inOff));
    index_ = (index_ + 1) & 1023;
  }
  return len;
}

- (NSString *)getAlgorithmName {
  return @"ISAAC";
}

- (void)reset {
  LibOrgBouncycastleCryptoEnginesISAACEngine_setKeyWithByteArray_(self, workingKey_);
}

- (void)setKeyWithByteArray:(IOSByteArray *)keyBytes {
  LibOrgBouncycastleCryptoEnginesISAACEngine_setKeyWithByteArray_(self, keyBytes);
}

- (void)isaac {
  LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(self);
}

- (void)mixWithIntArray:(IOSIntArray *)x {
  LibOrgBouncycastleCryptoEnginesISAACEngine_mixWithIntArray_(self, x);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "B", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(init__WithBoolean:withLibOrgBouncycastleCryptoCipherParameters:);
  methods[2].selector = @selector(returnByteWithByte:);
  methods[3].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[4].selector = @selector(getAlgorithmName);
  methods[5].selector = @selector(reset);
  methods[6].selector = @selector(setKeyWithByteArray:);
  methods[7].selector = @selector(isaac);
  methods[8].selector = @selector(mixWithIntArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "sizeL", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL, 0x12, 10, -1, -1, -1 },
    { "stateArraySize", "I", .constantValue.asInt = LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize, 0x12, 11, -1, -1, -1 },
    { "engineState_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "results_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "a_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "b_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "c_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "index_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "keyStream_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "workingKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialised_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "init", "ZLLibOrgBouncycastleCryptoCipherParameters;", "returnByte", "B", "processBytes", "[BII[BI", "setKey", "[B", "mix", "[I", "sizeL", "stateArraySize" };
  static const J2ObjcClassInfo _LibOrgBouncycastleCryptoEnginesISAACEngine = { "ISAACEngine", "lib.org.bouncycastle.crypto.engines", ptrTable, methods, fields, 7, 0x1, 9, 11, -1, -1, -1, -1, -1 };
  return &_LibOrgBouncycastleCryptoEnginesISAACEngine;
}

@end

void LibOrgBouncycastleCryptoEnginesISAACEngine_init(LibOrgBouncycastleCryptoEnginesISAACEngine *self) {
  NSObject_init(self);
  self->engineState_ = nil;
  self->results_ = nil;
  self->a_ = 0;
  self->b_ = 0;
  self->c_ = 0;
  self->index_ = 0;
  self->keyStream_ = [IOSByteArray newArrayWithLength:JreLShift32(LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize, 2)];
  self->workingKey_ = nil;
  self->initialised_ = false;
}

LibOrgBouncycastleCryptoEnginesISAACEngine *new_LibOrgBouncycastleCryptoEnginesISAACEngine_init() {
  J2OBJC_NEW_IMPL(LibOrgBouncycastleCryptoEnginesISAACEngine, init)
}

LibOrgBouncycastleCryptoEnginesISAACEngine *create_LibOrgBouncycastleCryptoEnginesISAACEngine_init() {
  J2OBJC_CREATE_IMPL(LibOrgBouncycastleCryptoEnginesISAACEngine, init)
}

void LibOrgBouncycastleCryptoEnginesISAACEngine_setKeyWithByteArray_(LibOrgBouncycastleCryptoEnginesISAACEngine *self, IOSByteArray *keyBytes) {
  self->workingKey_ = keyBytes;
  if (self->engineState_ == nil) {
    self->engineState_ = [IOSIntArray newArrayWithLength:LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize];
  }
  if (self->results_ == nil) {
    self->results_ = [IOSIntArray newArrayWithLength:LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize];
  }
  jint i;
  jint j;
  jint k;
  for (i = 0; i < LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize; i++) {
    *IOSIntArray_GetRef(self->engineState_, i) = *IOSIntArray_GetRef(self->results_, i) = 0;
  }
  self->a_ = self->b_ = self->c_ = 0;
  self->index_ = 0;
  IOSByteArray *t = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(keyBytes))->size_ + (keyBytes->size_ & 3)];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(keyBytes, 0, t, 0, keyBytes->size_);
  for (i = 0; i < t->size_; i += 4) {
    *IOSIntArray_GetRef(nil_chk(self->results_), JreURShift32(i, 2)) = LibOrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_(t, i);
  }
  IOSIntArray *abcdefgh = [IOSIntArray newArrayWithLength:LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL];
  for (i = 0; i < LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL; i++) {
    *IOSIntArray_GetRef(abcdefgh, i) = (jint) 0x9e3779b9;
  }
  for (i = 0; i < 4; i++) {
    LibOrgBouncycastleCryptoEnginesISAACEngine_mixWithIntArray_(self, abcdefgh);
  }
  for (i = 0; i < 2; i++) {
    for (j = 0; j < LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize; j += LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL) {
      for (k = 0; k < LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL; k++) {
        *IOSIntArray_GetRef(abcdefgh, k) += (i < 1) ? IOSIntArray_Get(nil_chk(self->results_), j + k) : IOSIntArray_Get(nil_chk(self->engineState_), j + k);
      }
      LibOrgBouncycastleCryptoEnginesISAACEngine_mixWithIntArray_(self, abcdefgh);
      for (k = 0; k < LibOrgBouncycastleCryptoEnginesISAACEngine_sizeL; k++) {
        *IOSIntArray_GetRef(nil_chk(self->engineState_), j + k) = IOSIntArray_Get(abcdefgh, k);
      }
    }
  }
  LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(self);
  self->initialised_ = true;
}

void LibOrgBouncycastleCryptoEnginesISAACEngine_isaac(LibOrgBouncycastleCryptoEnginesISAACEngine *self) {
  jint i;
  jint x;
  jint y;
  self->b_ += ++self->c_;
  for (i = 0; i < LibOrgBouncycastleCryptoEnginesISAACEngine_stateArraySize; i++) {
    x = IOSIntArray_Get(nil_chk(self->engineState_), i);
    switch (i & 3) {
      case 0:
      self->a_ ^= (JreLShift32(self->a_, 13));
      break;
      case 1:
      self->a_ ^= (JreURShift32(self->a_, 6));
      break;
      case 2:
      self->a_ ^= (JreLShift32(self->a_, 2));
      break;
      case 3:
      self->a_ ^= (JreURShift32(self->a_, 16));
      break;
    }
    self->a_ += IOSIntArray_Get(self->engineState_, (i + 128) & (jint) 0xFF);
    *IOSIntArray_GetRef(self->engineState_, i) = y = IOSIntArray_Get(self->engineState_, (JreURShift32(x, 2)) & (jint) 0xFF) + self->a_ + self->b_;
    *IOSIntArray_GetRef(nil_chk(self->results_), i) = self->b_ = IOSIntArray_Get(self->engineState_, (JreURShift32(y, 10)) & (jint) 0xFF) + x;
  }
}

void LibOrgBouncycastleCryptoEnginesISAACEngine_mixWithIntArray_(LibOrgBouncycastleCryptoEnginesISAACEngine *self, IOSIntArray *x) {
  *IOSIntArray_GetRef(nil_chk(x), 0) ^= JreLShift32(IOSIntArray_Get(x, 1), 11);
  *IOSIntArray_GetRef(x, 3) += IOSIntArray_Get(x, 0);
  *IOSIntArray_GetRef(x, 1) += IOSIntArray_Get(x, 2);
  *IOSIntArray_GetRef(x, 1) ^= JreURShift32(IOSIntArray_Get(x, 2), 2);
  *IOSIntArray_GetRef(x, 4) += IOSIntArray_Get(x, 1);
  *IOSIntArray_GetRef(x, 2) += IOSIntArray_Get(x, 3);
  *IOSIntArray_GetRef(x, 2) ^= JreLShift32(IOSIntArray_Get(x, 3), 8);
  *IOSIntArray_GetRef(x, 5) += IOSIntArray_Get(x, 2);
  *IOSIntArray_GetRef(x, 3) += IOSIntArray_Get(x, 4);
  *IOSIntArray_GetRef(x, 3) ^= JreURShift32(IOSIntArray_Get(x, 4), 16);
  *IOSIntArray_GetRef(x, 6) += IOSIntArray_Get(x, 3);
  *IOSIntArray_GetRef(x, 4) += IOSIntArray_Get(x, 5);
  *IOSIntArray_GetRef(x, 4) ^= JreLShift32(IOSIntArray_Get(x, 5), 10);
  *IOSIntArray_GetRef(x, 7) += IOSIntArray_Get(x, 4);
  *IOSIntArray_GetRef(x, 5) += IOSIntArray_Get(x, 6);
  *IOSIntArray_GetRef(x, 5) ^= JreURShift32(IOSIntArray_Get(x, 6), 4);
  *IOSIntArray_GetRef(x, 0) += IOSIntArray_Get(x, 5);
  *IOSIntArray_GetRef(x, 6) += IOSIntArray_Get(x, 7);
  *IOSIntArray_GetRef(x, 6) ^= JreLShift32(IOSIntArray_Get(x, 7), 8);
  *IOSIntArray_GetRef(x, 1) += IOSIntArray_Get(x, 6);
  *IOSIntArray_GetRef(x, 7) += IOSIntArray_Get(x, 0);
  *IOSIntArray_GetRef(x, 7) ^= JreURShift32(IOSIntArray_Get(x, 0), 9);
  *IOSIntArray_GetRef(x, 2) += IOSIntArray_Get(x, 7);
  *IOSIntArray_GetRef(x, 0) += IOSIntArray_Get(x, 1);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibOrgBouncycastleCryptoEnginesISAACEngine)
